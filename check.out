Array_creation\NAFPack_meshgrid.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 | MODULE NAFPack_meshgrid
5 |
6 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
7 |
8 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

FFT\FFTW3.f90:1:1: C131 module 'FFTW3' missing default accessibility statement
  |
1 | MODULE FFTW3
  | ^^^^^^^^^^^^ C131
2 |     USE, INTRINSIC :: iso_c_binding
3 |     INCLUDE '../../fftw-3.3.10/fftw3.f03'
4 | END MODULE FFTW3
  |

FFT\FFTW3.f90:2:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE FFTW3
2 |     USE, INTRINSIC :: iso_c_binding
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
3 |     INCLUDE '../../fftw-3.3.10/fftw3.f03'
4 | END MODULE FFTW3
  |

FFT\NAFPack_fft.f90:8:5: C121 'use' statement missing 'only' clause
   |
 6 | MODULE NAFPack_fft
 7 |
 8 |     USE FFTW3
   |     ^^^^^^^^^ C121
 9 |
10 |     USE NAFPack_constant
   |

FFT\NAFPack_fft.f90:10:5: C121 'use' statement missing 'only' clause
   |
 8 |     USE FFTW3
 9 |
10 |     USE NAFPack_constant
   |     ^^^^^^^^^^^^^^^^^^^^ C121
11 |     IMPLICIT NONE(TYPE, EXTERNAL)
   |

FFT\NAFPack_fft.f90:259:101: S001 line length of 110, exceeds maximum 100
    |
257 |         TYPE(c_ptr) :: plan
258 |
259 |         plan = fftw_plan_dft_2d(size(signal, 2), size(signal, 1), signal, RESULT, FFTW_FORWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^ S001
260 |         CALL fftw_execute_dft(plan, signal, RESULT)
261 |         CALL fftw_destroy_plan(plan)
    |

FFT\NAFPack_fft.f90:279:101: S001 line length of 110, exceeds maximum 100
    |
277 |         CALL fftw_plan_with_nthreads(threads)
278 |
279 |         plan = fftw_plan_dft_2d(size(signal, 2), size(signal, 1), signal, RESULT, FFTW_FORWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^ S001
280 |         CALL fftw_execute_dft(plan, signal, RESULT)
281 |         CALL fftw_destroy_plan(plan)
    |

FFT\NAFPack_fft.f90:294:101: S001 line length of 111, exceeds maximum 100
    |
292 |         TYPE(c_ptr) :: plan
293 |
294 |         plan = fftw_plan_dft_2d(size(signal, 2), size(signal, 1), signal, RESULT, FFTW_BACKWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^ S001
295 |         CALL fftw_execute_dft(plan, signal, RESULT)
296 |         RESULT = RESULT / (size(signal, 1) * size(signal, 2))
    |

FFT\NAFPack_fft.f90:315:101: S001 line length of 111, exceeds maximum 100
    |
313 |         CALL fftw_plan_with_nthreads(threads)
314 |
315 |         plan = fftw_plan_dft_2d(size(signal, 2), size(signal, 1), signal, RESULT, FFTW_BACKWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^ S001
316 |         CALL fftw_execute_dft(plan, signal, RESULT)
317 |         RESULT = RESULT / (size(signal, 1) * size(signal, 2))
    |

FFT\NAFPack_fft.f90:328:101: S001 line length of 105, exceeds maximum 100
    |
327 |         COMPLEX(c_double_complex), DIMENSION(:, :, :), INTENT(INOUT) :: signal
328 |         COMPLEX(c_double_complex), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) :: RESULT
    |                                                                                                     ^^^^^ S001
329 |         TYPE(c_ptr) :: plan
    |

FFT\NAFPack_fft.f90:331:101: S001 line length of 127, exceeds maximum 100
    |
329 |         TYPE(c_ptr) :: plan
330 |
331 |         plan = fftw_plan_dft_3d(size(signal, 3), size(signal, 2), size(signal, 1), signal, RESULT, FFTW_FORWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
332 |         CALL fftw_execute_dft(plan, signal, RESULT)
333 |         CALL fftw_destroy_plan(plan)
    |

FFT\NAFPack_fft.f90:342:101: S001 line length of 105, exceeds maximum 100
    |
340 |         COMPLEX(c_double_complex), DIMENSION(:, :, :), INTENT(INOUT) :: signal
341 |         INTEGER, INTENT(IN) :: threads
342 |         COMPLEX(c_double_complex), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) :: RESULT
    |                                                                                                     ^^^^^ S001
343 |         INTEGER :: error_init_thread
344 |         TYPE(c_ptr) :: plan
    |

FFT\NAFPack_fft.f90:351:101: S001 line length of 127, exceeds maximum 100
    |
349 |         CALL fftw_plan_with_nthreads(threads)
350 |
351 |         plan = fftw_plan_dft_3d(size(signal, 3), size(signal, 2), size(signal, 1), signal, RESULT, FFTW_FORWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
352 |         CALL fftw_execute_dft(plan, signal, RESULT)
353 |         CALL fftw_destroy_plan(plan)
    |

FFT\NAFPack_fft.f90:363:101: S001 line length of 105, exceeds maximum 100
    |
362 |         COMPLEX(c_double_complex), DIMENSION(:, :, :), INTENT(INOUT) :: signal
363 |         COMPLEX(c_double_complex), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) :: RESULT
    |                                                                                                     ^^^^^ S001
364 |         TYPE(c_ptr) :: plan
    |

FFT\NAFPack_fft.f90:366:101: S001 line length of 128, exceeds maximum 100
    |
364 |         TYPE(c_ptr) :: plan
365 |
366 |         plan = fftw_plan_dft_3d(size(signal, 3), size(signal, 2), size(signal, 1), signal, RESULT, FFTW_BACKWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
367 |         CALL fftw_execute_dft(plan, signal, RESULT)
368 |         RESULT = RESULT / (size(signal, 1) * size(signal, 2) * size(signal, 3))
    |

FFT\NAFPack_fft.f90:378:101: S001 line length of 105, exceeds maximum 100
    |
376 |         COMPLEX(c_double_complex), DIMENSION(:, :, :), INTENT(INOUT) :: signal
377 |         INTEGER, INTENT(IN) :: threads
378 |         COMPLEX(c_double_complex), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) :: RESULT
    |                                                                                                     ^^^^^ S001
379 |         INTEGER :: error_init_thread
380 |         TYPE(c_ptr) :: plan
    |

FFT\NAFPack_fft.f90:387:101: S001 line length of 128, exceeds maximum 100
    |
385 |         CALL fftw_plan_with_nthreads(threads)
386 |
387 |         plan = fftw_plan_dft_3d(size(signal, 3), size(signal, 2), size(signal, 1), signal, RESULT, FFTW_BACKWARD, FFTW_ESTIMATE)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
388 |         CALL fftw_execute_dft(plan, signal, RESULT)
389 |         RESULT = RESULT / (size(signal, 1) * size(signal, 2) * size(signal, 3))
    |

NAFPack_Logger_mod.f90:4:5: C121 'use' statement missing 'only' clause
  |
2 | MODULE NAFPack_Logger_mod
3 |
4 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
5 |
6 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

NAFPack_Logger_mod.f90:27:101: S001 line length of 108, exceeds maximum 100
   |
25 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_BIN = Format_file(0, "binary", "Binary file format")
26 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_TXT = Format_file(1, "txt", "Text file format")
27 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_CSV = Format_file(2, "csv", "Comma-separated values format")
   |                                                                                                     ^^^^^^^^ S001
28 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_LOG = Format_file(3, "log", "Log file format")
29 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_TSV = Format_file(4, "tsv", "Tab-separated values format")
   |

NAFPack_Logger_mod.f90:29:101: S001 line length of 106, exceeds maximum 100
   |
27 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_CSV = Format_file(2, "csv", "Comma-separated values format")
28 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_LOG = Format_file(3, "log", "Log file format")
29 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_TSV = Format_file(4, "tsv", "Tab-separated values format")
   |                                                                                                     ^^^^^^ S001
30 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_JSON = Format_file(5, "json", "JSON file format")
31 |     TYPE(Format_file), PARAMETER :: FORMAT_FILE_XML = Format_file(6, "xml", "XML file format")
   |

NAFPack_Logger_mod.f90:79:101: S001 line length of 119, exceeds maximum 100
   |
78 |         IF (this%to_file) THEN
79 |             OPEN (UNIT=this%file_unit, FILE=trim(this%filename)//"."//this%file_format%format_name, STATUS='REPLACE', &
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^ S001
80 |                   ACTION='WRITE', ENCODING='UTF-8')
81 |         END IF
   |

NAFPack_Logger_mod.f90:88:101: S001 line length of 118, exceeds maximum 100
   |
87 |         IF (this%show_Logger_initialization) THEN
88 |             CALL this%WRITE(center_with_fill("NAFPack Logger initialized", width=100, fill_char="="), box_style="top")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^ S001
89 |             CALL this%WRITE(ucs4_"", box_style="middle")
   |

NAFPack_Logger_mod.f90:97:101: S001 line length of 111, exceeds maximum 100
   |
95 |                 CALL log_field(this, "File unit", this%file_unit)
96 |                 CALL log_field(this, "File format", this%file_format%format_name)
97 |                 CALL log_field(this, "File name", trim(this%filename)//"."//trim(this%file_format%format_name))
   |                                                                                                     ^^^^^^^^^^^ S001
98 |             END IF
   |

NAFPack_Logger_mod.f90:120:101: S001 line length of 105, exceeds maximum 100
    |
118 |         CHARACTER(KIND=ucs4, LEN=*), INTENT(IN) :: msg
119 |
120 |         IF (this%verbosity_level >= 3) CALL this%WRITE(ucs4_"    "//msg, ucs4_"DETAIL", green_color_ucs4)
    |                                                                                                     ^^^^^ S001
121 |
122 |     END SUBROUTINE log_detail
    |

NAFPack_Logger_mod.f90:162:29: C081 'box_char' is initialised in its declaration and has no explicit `save` or `parameter` attribute
    |
160 |         CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: box_style
161 |         CHARACTER(KIND=ucs4, LEN=100) :: info_char
162 |         CHARACTER(LEN=4) :: box_char = " "
    |                             ^^^^^^^^^^^^^^ C081
163 |
164 |         IF (present(box_style)) THEN
    |

NAFPack_config.f90:4:5: C121 'use' statement missing 'only' clause
  |
2 | MODULE NAFPack_config
3 |
4 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
5 |
6 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

NAFPack_config.f90:67:23: C072 character 'error_msg' has assumed size but does not have `intent(in)`
   |
65 |         TYPE(config_type), INTENT(IN) :: config
66 |         LOGICAL, INTENT(OUT) :: is_valid
67 |         CHARACTER(LEN=*), INTENT(OUT) :: error_msg
   |                       ^ C072
68 |
69 |         is_valid = .TRUE.
   |

NAFPack_constant.f90:8:101: S001 line length of 109, exceeds maximum 100
  |
7 |     USE, INTRINSIC :: iso_fortran_env, ONLY: sp => real32, dp => real64, &
8 |                                                                                 isp => int32, idp => int64, &
  |                                                                                                     ^^^^^^^^^ S001
9 |                                                                                 output_unit
  |

NAFPack_constant.f90:16:101: S001 line length of 114, exceeds maximum 100
   |
14 |     PUBLIC :: pi, im, epsi, kmax, sp, dp, epsi_test, idp, isp, int_inf, output_unit
15 |     PUBLIC :: status_len
16 |     PUBLIC :: red_color, green_color, yellow_color, blue_color, white_color, cyan_color, purple_color, reset_color
   |                                                                                                     ^^^^^^^^^^^^^^ S001
17 |     PUBLIC :: red_color_ucs4, green_color_ucs4, yellow_color_ucs4, blue_color_ucs4, &
18 |               white_color_ucs4, cyan_color_ucs4, purple_color_ucs4, reset_color_ucs4
   |

NAFPack_constant.f90:20:101: S001 line length of 110, exceeds maximum 100
   |
18 |               white_color_ucs4, cyan_color_ucs4, purple_color_ucs4, reset_color_ucs4
19 |     PUBLIC :: ascii, ucs4
20 |     PUBLIC :: NAF_SUCCESS, NAF_ERROR_DIMENSION, NAF_ERROR_SINGULAR, NAF_ERROR_CONVERGENCE, NAF_ERROR_MEMORY, &
   |                                                                                                     ^^^^^^^^^^ S001
21 |               NAF_ERROR_INVALID_METHOD
22 |     PUBLIC :: TOL_PIVOT, TOL_CONVERGENCE
   |

io\NAFPack_matrix_market.f90:1:1: C131 module 'NAFPack_matrix_market' missing default accessibility statement
  |
1 | MODULE NAFPack_matrix_market
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C131
2 |
3 |     USE NAFPack_constant
  |

io\NAFPack_matrix_market.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_matrix_market
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |
5 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:4:5: C121 'use' statement missing 'only' clause
  |
2 | MODULE NAFPack_Direct_method
3 |
4 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
5 |     USE NAFPack_matrix_decomposition
6 |     USE NAFPack_matrix_properties
  |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:5:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_constant
5 |     USE NAFPack_matrix_decomposition
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
6 |     USE NAFPack_matrix_properties
7 |     USE NAFPack_Direct_types
  |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_constant
5 |     USE NAFPack_matrix_decomposition
6 |     USE NAFPack_matrix_properties
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
7 |     USE NAFPack_Direct_types
8 |     USE NAFPack_matrix_tools
  |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:7:5: C121 'use' statement missing 'only' clause
  |
5 |     USE NAFPack_matrix_decomposition
6 |     USE NAFPack_matrix_properties
7 |     USE NAFPack_Direct_types
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ C121
8 |     USE NAFPack_matrix_tools
  |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:8:5: C121 'use' statement missing 'only' clause
   |
 6 |     USE NAFPack_matrix_properties
 7 |     USE NAFPack_Direct_types
 8 |     USE NAFPack_matrix_tools
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ C121
 9 |
10 |     IMPLICIT NONE(TYPE, EXTERNAL)
   |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:42:9: C002 interface 'function' missing 'implicit none'
   |
41 |     ABSTRACT INTERFACE
42 |         FUNCTION solve_interface_Direct(this, A, b) RESULT(x)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C002
43 |             IMPORT :: dp
44 |             IMPORT :: DirectMethod
45 |             CLASS(DirectMethod), INTENT(IN) :: this
   |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:57:30: C061 subroutine argument 'set_pivot_partial' missing 'intent' attribute
   |
55 |         CLASS(DirectMethod), INTENT(INOUT) :: this
56 |         TYPE(MethodTypeDirect), INTENT(IN) :: method
57 |         LOGICAL, OPTIONAL :: set_pivot_partial, set_pivot_total
   |                              ^^^^^^^^^^^^^^^^^ C061
58 |
59 |         this%use_total_pivot = .FALSE.
   |

linear_algebra\Direct_method\NAFPack_Direct_methode.f90:57:49: C061 subroutine argument 'set_pivot_total' missing 'intent' attribute
   |
55 |         CLASS(DirectMethod), INTENT(INOUT) :: this
56 |         TYPE(MethodTypeDirect), INTENT(IN) :: method
57 |         LOGICAL, OPTIONAL :: set_pivot_partial, set_pivot_total
   |                                                 ^^^^^^^^^^^^^^^ C061
58 |
59 |         this%use_total_pivot = .FALSE.
   |

linear_algebra\Direct_method\NAFPack_Direct_types.f90:45:101: S001 line length of 108, exceeds maximum 100
   |
43 |     TYPE(MethodTypeDirect), PARAMETER :: METHOD_QR = MethodTypeDirect(7, "QR")
44 |     TYPE(MethodTypeDirect), PARAMETER :: METHOD_TDMA = MethodTypeDirect(8, "TDMA")
45 |     TYPE(MethodTypeDirect), PARAMETER :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect(9, "Faddeev-Leverrier")
   |                                                                                                     ^^^^^^^^ S001
46 |
47 |     TYPE(MethodQR), PARAMETER :: QR_HOUSEHOLDER = MethodQR(1, "Householder")
   |

linear_algebra\Eigen\NAFPack_Eigen.f90:4:5: C121 'use' statement missing 'only' clause
  |
2 | MODULE NAFPack_Eigen
3 |
4 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
5 |     USE NAFPack_matrix_decomposition
6 |     USE NAFPack_matricielle
  |

linear_algebra\Eigen\NAFPack_Eigen.f90:5:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_constant
5 |     USE NAFPack_matrix_decomposition
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
6 |     USE NAFPack_matricielle
  |

linear_algebra\Eigen\NAFPack_Eigen.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_constant
5 |     USE NAFPack_matrix_decomposition
6 |     USE NAFPack_matricielle
  |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
7 |
8 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Eigen\NAFPack_Eigen.f90:161:101: S001 line length of 105, exceeds maximum 100
    |
160 |             IF (i == k) THEN
161 |                 PRINT*," WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues "//method
    |                                                                                                     ^^^^^ S001
162 |                 PRINT*,"convergence = ", diff
163 |                 EXIT
    |

linear_algebra\Iterative_method\NAFPack_Iterative_Params.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_Iterative_Params
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_Preconditioners
  |

linear_algebra\Iterative_method\NAFPack_Iterative_Params.f90:4:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_Iterative_types
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
5 |     USE NAFPack_Preconditioners
6 |     USE NAFPack_matrix_decomposition
  |

linear_algebra\Iterative_method\NAFPack_Iterative_Params.f90:5:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_Preconditioners
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
6 |     USE NAFPack_matrix_decomposition
  |

linear_algebra\Iterative_method\NAFPack_Iterative_Params.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_Preconditioners
6 |     USE NAFPack_matrix_decomposition
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
7 |
8 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:9:5: C121 'use' statement missing 'only' clause
   |
 7 | MODULE NAFPack_Iterative_methods
 8 |
 9 |     USE NAFPack_constant
   |     ^^^^^^^^^^^^^^^^^^^^ C121
10 |     USE NAFPack_matrix_decomposition
11 |     USE NAFPack_matricielle
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:10:5: C121 'use' statement missing 'only' clause
   |
 9 |     USE NAFPack_constant
10 |     USE NAFPack_matrix_decomposition
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
11 |     USE NAFPack_matricielle
12 |     USE NAFPack_Iterative_types
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:11:5: C121 'use' statement missing 'only' clause
   |
 9 |     USE NAFPack_constant
10 |     USE NAFPack_matrix_decomposition
11 |     USE NAFPack_matricielle
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
12 |     USE NAFPack_Iterative_types
13 |     USE NAFPack_Logger_mod
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:12:5: C121 'use' statement missing 'only' clause
   |
10 |     USE NAFPack_matrix_decomposition
11 |     USE NAFPack_matricielle
12 |     USE NAFPack_Iterative_types
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
13 |     USE NAFPack_Logger_mod
14 |     USE NAFPack_Preconditioners
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:13:5: C121 'use' statement missing 'only' clause
   |
11 |     USE NAFPack_matricielle
12 |     USE NAFPack_Iterative_types
13 |     USE NAFPack_Logger_mod
   |     ^^^^^^^^^^^^^^^^^^^^^^ C121
14 |     USE NAFPack_Preconditioners
15 |     USE NAFPack_Iterative_Params
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:14:5: C121 'use' statement missing 'only' clause
   |
12 |     USE NAFPack_Iterative_types
13 |     USE NAFPack_Logger_mod
14 |     USE NAFPack_Preconditioners
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
15 |     USE NAFPack_Iterative_Params
16 |     USE NAFPack_matrix_properties
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:15:5: C121 'use' statement missing 'only' clause
   |
13 |     USE NAFPack_Logger_mod
14 |     USE NAFPack_Preconditioners
15 |     USE NAFPack_Iterative_Params
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
16 |     USE NAFPack_matrix_properties
17 |     USE NAFPack_memory_monitor
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:16:5: C121 'use' statement missing 'only' clause
   |
14 |     USE NAFPack_Preconditioners
15 |     USE NAFPack_Iterative_Params
16 |     USE NAFPack_matrix_properties
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
17 |     USE NAFPack_memory_monitor
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:17:5: C121 'use' statement missing 'only' clause
   |
15 |     USE NAFPack_Iterative_Params
16 |     USE NAFPack_matrix_properties
17 |     USE NAFPack_memory_monitor
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
18 |
19 |     IMPLICIT NONE(TYPE, EXTERNAL)
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:78:9: C002 interface 'function' missing 'implicit none'
   |
77 |     ABSTRACT INTERFACE
78 |         FUNCTION solve_interface_Iterative(this, A, b, x0, params) RESULT(x)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C002
79 |             IMPORT :: dp
80 |             IMPORT :: IterativeParams
81 |             IMPORT :: IterativeMethod
   |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:174:101: S001 line length of 110, exceeds maximum 100
    |
172 |     END SUBROUTINE set_method
173 |
174 |     FUNCTION Init_IterativeParams(this, N, A, x0, max_iter_choice, epsi_tol, omega, Norm_choice, fill_level, &
    |                                                                                                     ^^^^^^^^^^ S001
175 |                                   method_preconditioner, alpha, is_stationary, is_strict_mode) RESULT(params)
176 |         CLASS(IterativeMethod), INTENT(INOUT) :: this
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:175:101: S001 line length of 109, exceeds maximum 100
    |
174 |     FUNCTION Init_IterativeParams(this, N, A, x0, max_iter_choice, epsi_tol, omega, Norm_choice, fill_level, &
175 |                                   method_preconditioner, alpha, is_stationary, is_strict_mode) RESULT(params)
    |                                                                                                     ^^^^^^^^^ S001
176 |         CLASS(IterativeMethod), INTENT(INOUT) :: this
177 |         INTEGER, INTENT(IN) :: N
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:274:101: S001 line length of 126, exceeds maximum 100
    |
272 |                 IF (allocate_status /= 0) STOP "ERROR :: Unable to allocate U"
273 |                 IF (params%fill_level%id /= FILL_LEVEL_NONE%id) THEN
274 |                     CALL Calculate_ILU_preconditioner(A, params%L, params%U, params%omega, params%alpha, params%fill_level%id)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
275 |                 ELSE
276 |                     CALL Calculate_ILU_preconditioner(A, params%L, params%U, params%omega, params%alpha)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:276:101: S001 line length of 104, exceeds maximum 100
    |
274 |                     CALL Calculate_ILU_preconditioner(A, params%L, params%U, params%omega, params%alpha, params%fill_level%id)
275 |                 ELSE
276 |                     CALL Calculate_ILU_preconditioner(A, params%L, params%U, params%omega, params%alpha)
    |                                                                                                     ^^^^ S001
277 |                 END IF
278 |                 this%preconditioner_type = METHOD_PRECOND_ILU
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:284:101: S001 line length of 112, exceeds maximum 100
    |
282 |                 IF (allocate_status /= 0) STOP "ERROR :: Unable to allocate L"
283 |                 IF (params%fill_level%id /= FILL_LEVEL_NONE%id) THEN
284 |                     params%L = Calculate_ICF_preconditioner(A, params%omega, params%alpha, params%fill_level%id)
    |                                                                                                     ^^^^^^^^^^^^ S001
285 |                 ELSE
286 |                     params%L = Calculate_ICF_preconditioner(A, params%omega, params%alpha)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:296:101: S001 line length of 101, exceeds maximum 100
    |
294 |                 ALLOCATE (params%D(N, N), STAT=allocate_status)
295 |                 IF (allocate_status /= 0) STOP "ERROR :: Unable to allocate D"
296 |                 CALL Calculate_SSOR_preconditioner(A, params%L, params%D, params%omega, params%alpha)
    |                                                                                                     ^ S001
297 |                 this%preconditioner_type = METHOD_PRECOND_SSOR
298 |                 this%requirements%needs_SPD = .TRUE.
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:338:101: S001 line length of 119, exceeds maximum 100
    |
337 |         IF (show_matrix_test) THEN
338 |             CALL verbose%WRITE(center_with_fill("Testing matrix properties for method:"//trim(this%method_type%name), &
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^ S001
339 |                                                 100, fill_char="="), box_style="top")
340 |             CALL verbose%WRITE(ucs4_"", box_style="middle")
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:357:101: S001 line length of 126, exceeds maximum 100
    |
356 |         IF (this%requirements%needs_SPD) THEN
357 |             IF (show_matrix_test) CALL verbose%log_info(ucs4_"Checking if the matrix is symmetric positive definite (SPD)...")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ S001
358 |             IF (.NOT. is_SPD(A)) THEN
359 |                 WRITE (msg, '(2A)') trim(this%method_type%name), " method requires a symmetric positive definite matrix."
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:370:101: S001 line length of 112, exceeds maximum 100
    |
369 |         IF (this%requirements%needs_diag_dom) THEN
370 |             IF (show_matrix_test) CALL verbose%log_info(ucs4_"Checking if the matrix is diagonally dominant...")
    |                                                                                                     ^^^^^^^^^^^^ S001
371 |             IF (.NOT. is_diagonally_dominant(A)) THEN
372 |                 WRITE (msg, '(2A)') trim(this%method_type%name), " method requires a diagonally dominant matrix."
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:383:101: S001 line length of 102, exceeds maximum 100
    |
382 |         IF (this%requirements%needs_symetric) THEN
383 |             IF (show_matrix_test) CALL verbose%log_info(ucs4_"Checking if the matrix is symmetric...")
    |                                                                                                     ^^ S001
384 |             IF (.NOT. is_symmetric(A)) THEN
385 |                 WRITE (msg, '(2A)') trim(this%method_type%name), " method requires a symmetric matrix."
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:495:101: S001 line length of 114, exceeds maximum 100
    |
493 |         END DO
494 |
495 |         IF (show_iteration) CALL verbose%WRITE(center_with_fill("", width=100, fill_char="="), box_style="bottom")
    |                                                                                                     ^^^^^^^^^^^^^^ S001
496 |
497 |         IF (show_final) THEN
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:520:101: S001 line length of 113, exceeds maximum 100
    |
519 |         CALL verbose%WRITE(ucs4_"")
520 |         CALL verbose%WRITE(center_with_fill("Starting system solver", width=100, fill_char="="), box_style="top")
    |                                                                                                     ^^^^^^^^^^^^^ S001
521 |         CALL verbose%WRITE(ucs4_"", box_style="middle")
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:530:101: S001 line length of 118, exceeds maximum 100
    |
529 |         IF (solver%relaxation_factor%id == RELAXATION_FACTOR_OMEGA%id) THEN
530 |             CALL log_field(verbose, "Method used", trim(solver%method_type%name)//" "//trim(solver%method_type%name2))
    |                                                                                                     ^^^^^^^^^^^^^^^^^^ S001
531 |             WRITE (msg, '(A, T40, 3A, ES0.4)') "Relaxation factor used", ": ", trim(solver%relaxation_factor%name), &
532 |                 " = ", params%omega
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:531:101: S001 line length of 117, exceeds maximum 100
    |
529 |         IF (solver%relaxation_factor%id == RELAXATION_FACTOR_OMEGA%id) THEN
530 |             CALL log_field(verbose, "Method used", trim(solver%method_type%name)//" "//trim(solver%method_type%name2))
531 |             WRITE (msg, '(A, T40, 3A, ES0.4)') "Relaxation factor used", ": ", trim(solver%relaxation_factor%name), &
    |                                                                                                     ^^^^^^^^^^^^^^^^^ S001
532 |                 " = ", params%omega
533 |             CALL verbose%log_info(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:536:101: S001 line length of 117, exceeds maximum 100
    |
534 |         ELSE IF (solver%relaxation_factor%id == RELAXATION_FACTOR_ALPHA%id) THEN
535 |             CALL log_field(verbose, "Method used", trim(solver%method_type%name))
536 |             WRITE (msg, '(A, T40, 3A, ES0.4)') "Relaxation factor used", ": ", trim(solver%relaxation_factor%name), &
    |                                                                                                     ^^^^^^^^^^^^^^^^^ S001
537 |                 " = ", params%alpha
538 |             CALL verbose%log_info(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:545:101: S001 line length of 101, exceeds maximum 100
    |
543 |         IF (solver%preconditioner_type%id /= METHOD_PRECOND_NONE%id) THEN
544 |             IF (solver%relaxation_factor_preconditioner%id == RELAXATION_FACTOR_OMEGA%id) THEN
545 |                 CALL log_field(verbose, "Preconditioner used", trim(solver%preconditioner_type%name))
    |                                                                                                     ^ S001
546 |                 WRITE (msg, '(A, T40, 3A, ES0.4)') "Relaxation factor used", ": ", &
547 |                     trim(solver%relaxation_factor_preconditioner%name), " = ", params%omega
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:550:101: S001 line length of 101, exceeds maximum 100
    |
548 |                 CALL verbose%log_info(msg)
549 |             ELSE
550 |                 CALL log_field(verbose, "Preconditioner used", trim(solver%preconditioner_type%name))
    |                                                                                                     ^ S001
551 |             END IF
552 |         END IF
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:559:101: S001 line length of 107, exceeds maximum 100
    |
557 |                 CALL log_field(verbose, "Fill level used", trim(params%fill_level%name))
558 |             ELSE
559 |                 CALL log_field(verbose, "Fill level used", "basic "//trim(solver%preconditioner_type%name))
    |                                                                                                     ^^^^^^^ S001
560 |             END IF
561 |         ELSE IF (solver%method_type%id == METHOD_SIP_ILU%id .OR. &
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:578:101: S001 line length of 101, exceeds maximum 100
    |
576 |         CALL log_field(verbose, "Norme used", trim(params%norm%name))
577 |
578 |         WRITE (msg, '(A,T40,A, ES0.2)') "Convergence criterion (Tolerance)", ": ||r|| < ", params%tol
    |                                                                                                     ^ S001
579 |         CALL verbose%log_info(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:583:101: S001 line length of 107, exceeds maximum 100
    |
581 |         CALL log_field(verbose, "Max iterations", params%max_iter)
582 |
583 |         WRITE (msg, '(A,T36,A,ES0.7)') "Initial residual norm", ": ||r0|| = ", params%norm_initial_residual
    |                                                                                                     ^^^^^^^ S001
584 |         CALL verbose%log_detail(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:595:101: S001 line length of 101, exceeds maximum 100
    |
593 |         CHARACTER(KIND=ucs4, LEN=100) :: msg
594 |
595 |         CALL verbose%WRITE(center_with_fill("Iterations", width=100, fill_char="="), box_style="top")
    |                                                                                                     ^ S001
596 |         CALL verbose%WRITE(ucs4_"", box_style="middle")
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:640:101: S001 line length of 108, exceeds maximum 100
    |
638 |             CALL log_field(verbose, "Status", "CONVERGED")
639 |
640 |             WRITE (msg, '(A,T40,A,ES0.7,A,ES0.1,A)') "Final residual", ": ||r|| = ", params%norm_residual, &
    |                                                                                                     ^^^^^^^^ S001
641 |                 " < ", params%tol, " (convergence achieved)"
642 |             CALL verbose%log_info(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:656:101: S001 line length of 108, exceeds maximum 100
    |
654 |                 END DO
655 |             ELSE
656 |                 WRITE (msg, '(2A,ES0.7,3X,ES0.7,3X,ES0.7,3X,A,ES0.7,3X,ES0.7,3X,ES0.7,A)') trim(msg), " ", &
    |                                                                                                     ^^^^^^^^ S001
657 |                     x_new(1), x_new(2), x_new(3), x_new(N - 3), x_new(N - 2), x_new(N - 1)
658 |             END IF
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:672:101: S001 line length of 108, exceeds maximum 100
    |
670 |             CALL log_field(verbose, "Status", "NOT CONVERGED")
671 |
672 |             WRITE (msg, '(A,T40,A,ES0.7,A,ES0.1,A)') "Final residual", ": ||r|| = ", params%norm_residual, &
    |                                                                                                     ^^^^^^^^ S001
673 |                 " >= ", params%tol, " (convergence not achieved)"
674 |             CALL verbose%log_info(msg)
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:677:5: S061 [*] end statement should be named.
    |
675 |         END IF
676 |         CALL verbose%WRITE(center_with_fill("", width=100, fill_char="="), box_style="bottom")
677 |     END SUBROUTINE
    |     ^^^^^^^^^^^^^^ S061
678 |
679 |     !======================
680 |     ! Solve methods
    |
    = help: Write as 'end subroutine log_final_result'.

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:698:101: S001 line length of 107, exceeds maximum 100
    |
696 |         ! forward
697 |         DO i = 1, N
698 |             x(i) = b(i) - dot_product(A(i, 1:i - 1), x0(1:i - 1)) - dot_product(A(i, i + 1:N), x0(i + 1:N))
    |                                                                                                     ^^^^^^^ S001
699 |             x(i) = x(i) / A(i, i)
700 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:719:101: S001 line length of 106, exceeds maximum 100
    |
717 |         ! forward
718 |         DO i = 1, N
719 |             x(i) = b(i) - dot_product(A(i, 1:i - 1), x(1:i - 1)) - dot_product(A(i, i + 1:N), x0(i + 1:N))
    |                                                                                                     ^^^^^^ S001
720 |             x(i) = x(i) / A(i, i)
721 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:740:101: S001 line length of 106, exceeds maximum 100
    |
738 |         ! forward
739 |         DO i = 1, N
740 |             x(i) = b(i) - dot_product(A(i, 1:i - 1), x(1:i - 1)) - dot_product(A(i, i + 1:N), x0(i + 1:N))
    |                                                                                                     ^^^^^^ S001
741 |             x(i) = params%omega * (x(i) / A(i, i) - x0(i)) + x0(i)
742 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:761:101: S001 line length of 107, exceeds maximum 100
    |
759 |         ! forward
760 |         DO i = 1, N
761 |             x(i) = b(i) - dot_product(A(i, 1:i - 1), x0(1:i - 1)) - dot_product(A(i, i + 1:N), x0(i + 1:N))
    |                                                                                                     ^^^^^^^ S001
762 |             x(i) = params%omega * (x(i) / A(i, i) - x0(i)) + x0(i)
763 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:827:101: S001 line length of 114, exceeds maximum 100
    |
825 |         ! forward
826 |         DO i = 1, N
827 |             x_tmp(i) = b(i) - dot_product(A(i, 1:i - 1), x_tmp(1:i - 1)) - dot_product(A(i, i + 1:N), x0(i + 1:N))
    |                                                                                                     ^^^^^^^^^^^^^^ S001
828 |             x_tmp(i) = params%omega * (x_tmp(i) / A(i, i) - x0(i)) + x0(i)
829 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:833:101: S001 line length of 109, exceeds maximum 100
    |
831 |         ! backward
832 |         DO i = N, 1, -1
833 |             x(i) = b(i) - dot_product(A(i, 1:i - 1), x_tmp(1:i - 1)) - dot_product(A(i, i + 1:N), x(i + 1:N))
    |                                                                                                     ^^^^^^^^^ S001
834 |             x(i) = params%omega * (x(i) / A(i, i) - x_tmp(i)) + x_tmp(i)
835 |         END DO
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:886:101: S001 line length of 117, exceeds maximum 100
    |
884 |             END IF
885 |
886 |             params%alpha = dot_product(params%residual, params%residual) / dot_product(params%p, matmul(A, params%p))
    |                                                                                                     ^^^^^^^^^^^^^^^^^ S001
887 |
888 |             x = x0 + params%alpha * params%p
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:906:101: S001 line length of 108, exceeds maximum 100
    |
904 |             END IF
905 |
906 |             params%alpha = dot_product(z_prec, params%residual) / dot_product(params%p, matmul(A, params%p))
    |                                                                                                     ^^^^^^^^ S001
907 |
908 |             x = x0 + params%alpha * params%p
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:930:101: S001 line length of 111, exceeds maximum 100
    |
928 |                 params%p = params%residual
929 |             ELSE IF (params%k /= 1) THEN
930 |                 params%beta = dot_product(params%residual, matmul(A, params%residual)) / params%old_dot_product
    |                                                                                                     ^^^^^^^^^^^ S001
931 |                 params%p = params%residual + params%beta * params%p
932 |             END IF
    |

linear_algebra\Iterative_method\NAFPack_Iterative_methods.f90:951:101: S001 line length of 102, exceeds maximum 100
    |
949 |             ELSE IF (params%k /= 1) THEN
950 |                 z_prec = params%precond(this%preconditioner_type, params%residual)
951 |                 params%beta = dot_product(z_prec, matmul(A, params%residual)) / params%old_dot_product
    |                                                                                                     ^^ S001
952 |                 params%p = z_prec + params%beta * params%p
953 |             END IF
    |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_Iterative_types
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |
5 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:57:101: S001 line length of 104, exceeds maximum 100
   |
55 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_ITERATIVE_NONE = MethodTypeIterative(0, "None")
56 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_Jacobi = MethodTypeIterative(1, "Jacobi")
57 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, "Gauss-Seidel")
   |                                                                                                     ^^^^ S001
58 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SOR = MethodTypeIterative(3, "Successive Over-Relaxation")
59 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_JOR = MethodTypeIterative(4, "Jacobi Over-Relaxation")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:58:101: S001 line length of 109, exceeds maximum 100
   |
56 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_Jacobi = MethodTypeIterative(1, "Jacobi")
57 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, "Gauss-Seidel")
58 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SOR = MethodTypeIterative(3, "Successive Over-Relaxation")
   |                                                                                                     ^^^^^^^^^ S001
59 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_JOR = MethodTypeIterative(4, "Jacobi Over-Relaxation")
60 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative(5, "Strongly Implicit Procedure", "ILU")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:59:101: S001 line length of 105, exceeds maximum 100
   |
57 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, "Gauss-Seidel")
58 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SOR = MethodTypeIterative(3, "Successive Over-Relaxation")
59 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_JOR = MethodTypeIterative(4, "Jacobi Over-Relaxation")
   |                                                                                                     ^^^^^ S001
60 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative(5, "Strongly Implicit Procedure", "ILU")
61 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative(6, "Strongly Implicit Procedure", "ICF")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:60:101: S001 line length of 121, exceeds maximum 100
   |
58 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SOR = MethodTypeIterative(3, "Successive Over-Relaxation")
59 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_JOR = MethodTypeIterative(4, "Jacobi Over-Relaxation")
60 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative(5, "Strongly Implicit Procedure", "ILU")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^ S001
61 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative(6, "Strongly Implicit Procedure", "ICF")
62 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SSOR = MethodTypeIterative(7, "Symmetric Successive Over-Relaxation")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:61:101: S001 line length of 121, exceeds maximum 100
   |
59 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_JOR = MethodTypeIterative(4, "Jacobi Over-Relaxation")
60 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative(5, "Strongly Implicit Procedure", "ILU")
61 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative(6, "Strongly Implicit Procedure", "ICF")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^ S001
62 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SSOR = MethodTypeIterative(7, "Symmetric Successive Over-Relaxation")
63 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative(8, "Richardson")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:62:101: S001 line length of 120, exceeds maximum 100
   |
60 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative(5, "Strongly Implicit Procedure", "ILU")
61 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative(6, "Strongly Implicit Procedure", "ICF")
62 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SSOR = MethodTypeIterative(7, "Symmetric Successive Over-Relaxation")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^ S001
63 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative(8, "Richardson")
64 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, "Conjugate Gradient")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:64:101: S001 line length of 116, exceeds maximum 100
   |
62 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_SSOR = MethodTypeIterative(7, "Symmetric Successive Over-Relaxation")
63 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative(8, "Richardson")
64 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, "Conjugate Gradient")
   |                                                                                                     ^^^^^^^^^^^^^^^^ S001
65 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, "Conjugate Residual")
66 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNE = MethodTypeIterative(11, "Conjugate Gradient on Normal Equations")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:65:101: S001 line length of 117, exceeds maximum 100
   |
63 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative(8, "Richardson")
64 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, "Conjugate Gradient")
65 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, "Conjugate Residual")
   |                                                                                                     ^^^^^^^^^^^^^^^^^ S001
66 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNE = MethodTypeIterative(11, "Conjugate Gradient on Normal Equations")
67 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNR = MethodTypeIterative(12, "Conjugate Gradient on Normal Residual")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:66:101: S001 line length of 123, exceeds maximum 100
   |
64 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, "Conjugate Gradient")
65 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, "Conjugate Residual")
66 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNE = MethodTypeIterative(11, "Conjugate Gradient on Normal Equations")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^ S001
67 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNR = MethodTypeIterative(12, "Conjugate Gradient on Normal Residual")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:67:101: S001 line length of 122, exceeds maximum 100
   |
65 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, "Conjugate Residual")
66 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNE = MethodTypeIterative(11, "Conjugate Gradient on Normal Equations")
67 |     TYPE(MethodTypeIterative), PARAMETER :: METHOD_CGNR = MethodTypeIterative(12, "Conjugate Gradient on Normal Residual")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^ S001
68 |
69 |     TYPE(Norm_used), PARAMETER :: NORM_2 = Norm_used(1, "Norm L2 or Euclidean")
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:73:101: S001 line length of 103, exceeds maximum 100
   |
71 |     TYPE(Norm_used), PARAMETER :: NORM_INF = Norm_used(3, "Norm LInfini or Maximum")
72 |
73 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_NONE = relaxation_factor_used(0, NONE)
   |                                                                                                     ^^^ S001
74 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used(1, omega)
75 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used(2, alpha)
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:74:101: S001 line length of 105, exceeds maximum 100
   |
73 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_NONE = relaxation_factor_used(0, NONE)
74 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used(1, omega)
   |                                                                                                     ^^^^^ S001
75 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used(2, alpha)
   |

linear_algebra\Iterative_method\NAFPack_Iterative_types.f90:75:101: S001 line length of 105, exceeds maximum 100
   |
73 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_NONE = relaxation_factor_used(0, NONE)
74 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used(1, omega)
75 |     TYPE(relaxation_factor_used), PARAMETER :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used(2, alpha)
   |                                                                                                     ^^^^^ S001
76 |
77 | END MODULE NAFPack_Iterative_types
   |

linear_algebra\Iterative_method\NAFPack_Krylov_method.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_Krylov_method
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |
5 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Matrix\NAFPack_matricielle.f90:4:5: C121 'use' statement missing 'only' clause
  |
2 | MODULE NAFPack_matricielle
3 |
4 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
5 |
6 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Matrix\NAFPack_matricielle.f90:41:35: C061 function argument 'a' missing 'intent' attribute
   |
39 |     FUNCTION cross(a, b) RESULT(RESULT)
40 |
41 |         REAL(dp), DIMENSION(3) :: a, b
   |                                   ^ C061
42 |         REAL(dp), DIMENSION(3) :: RESULT
   |

linear_algebra\Matrix\NAFPack_matricielle.f90:41:38: C061 function argument 'b' missing 'intent' attribute
   |
39 |     FUNCTION cross(a, b) RESULT(RESULT)
40 |
41 |         REAL(dp), DIMENSION(3) :: a, b
   |                                      ^ C061
42 |         REAL(dp), DIMENSION(3) :: RESULT
   |

linear_algebra\Matrix\NAFPack_matricielle.f90:56:35: C061 function argument 'a' missing 'intent' attribute
   |
54 |     FUNCTION norm_2_real(a) RESULT(RESULT)
55 |
56 |         REAL(dp), DIMENSION(:) :: a
   |                                   ^ C061
57 |         REAL(dp) :: RESULT
   |

linear_algebra\Matrix\NAFPack_matricielle.f90:84:38: C061 function argument 'a' missing 'intent' attribute
   |
82 |     FUNCTION norm_2_complex(a) RESULT(RESULT)
83 |
84 |         COMPLEX(dp), DIMENSION(:) :: a
   |                                      ^ C061
85 |         REAL(dp) :: RESULT
   |

linear_algebra\Matrix\NAFPack_matricielle.f90:96:35: C061 function argument 'a' missing 'intent' attribute
   |
94 |     FUNCTION normalise(a) RESULT(RESULT)
95 |
96 |         REAL(dp), DIMENSION(:) :: a
   |                                   ^ C061
97 |         REAL(dp), DIMENSION(size(a)) :: RESULT
   |

linear_algebra\Matrix\NAFPack_matricielle.f90:107:38: C061 function argument 'a' missing 'intent' attribute
    |
105 |     !> \[ \hat{a} = \frac{\vec{a}}{||\vec{a}||_2} \]
106 |     FUNCTION normalise_complexe(a) RESULT(RESULT)
107 |         COMPLEX(dp), DIMENSION(:) :: a
    |                                      ^ C061
108 |         COMPLEX(dp), DIMENSION(size(a)) :: RESULT
    |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 | MODULE NAFPack_matrix_decomposition
5 |
6 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
7 |     USE NAFPack_matricielle
  |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:7:5: C121 'use' statement missing 'only' clause
  |
6 |     USE NAFPack_constant
7 |     USE NAFPack_matricielle
  |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
8 |
9 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:111:101: S001 line length of 113, exceeds maximum 100
    |
110 |             DO i = 1, j - 1
111 |                 U(i, j) = (A(i, j) - dot_product(L(i, 1:i - 1), U(1:i - 1, j)*[(D(k, k), k=1, i - 1)])) / D(i, i)
    |                                                                                                     ^^^^^^^^^^^^^ S001
112 |             END DO
    |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:118:101: S001 line length of 113, exceeds maximum 100
    |
117 |             DO i = j + 1, N
118 |                 L(i, j) = (A(i, j) - dot_product(L(i, 1:j - 1), U(1:j - 1, j)*[(D(k, k), k=1, j - 1)])) / D(j, j)
    |                                                                                                     ^^^^^^^^^^^^^ S001
119 |             END DO
120 |         END DO
    |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:162:101: S001 line length of 102, exceeds maximum 100
    |
161 |             DO i = j + 1, N
162 |                 IF (S(i, j)) L(i, j) = (A(i, j) - dot_product(L(i, 1:j - 1), U(1:j - 1, j))) / U(j, j)
    |                                                                                                     ^^ S001
163 |             END DO
164 |         END DO
    |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:207:101: S001 line length of 113, exceeds maximum 100
    |
206 |             DO i = j + 1, N
207 |                 L(i, j) = (A(i, j) - dot_product(L(i, 1:j - 1), L(j, 1:j - 1)*[(D(k, k), k=1, j - 1)])) / D(j, j)
    |                                                                                                     ^^^^^^^^^^^^^ S001
208 |             END DO
209 |         END DO
    |

linear_algebra\Matrix\NAFPack_matrix_decomposition.f90:238:101: S001 line length of 102, exceeds maximum 100
    |
236 |         DO i = 1, N
237 |             DO j = 1, i - 1
238 |                 IF (S(i, j)) L(i, j) = (A(i, j) - dot_product(L(i, 1:j - 1), L(j, 1:j - 1))) / L(j, j)
    |                                                                                                     ^^ S001
239 |             END DO
    |

linear_algebra\Matrix\NAFPack_matrix_properties.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_matrix_properties
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |     USE NAFPack_matricielle
5 |     USE NAFPack_Eigen
  |

linear_algebra\Matrix\NAFPack_matrix_properties.f90:4:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_matricielle
  |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
5 |     USE NAFPack_Eigen
  |

linear_algebra\Matrix\NAFPack_matrix_properties.f90:5:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_matricielle
5 |     USE NAFPack_Eigen
  |     ^^^^^^^^^^^^^^^^^ C121
6 |
7 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Matrix\NAFPack_matrix_tools.f90:1:1: C131 module 'NAFPack_matrix_tools' missing default accessibility statement
  |
1 | MODULE NAFPack_matrix_tools
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C131
2 |
3 |     USE NAFPack_constant
4 |     USE NAFPack_matricielle
  |

linear_algebra\Matrix\NAFPack_matrix_tools.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_matrix_tools
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |     USE NAFPack_matricielle
  |

linear_algebra\Matrix\NAFPack_matrix_tools.f90:4:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_matricielle
  |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
5 |
6 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\Matrix\NAFPack_matrix_tools.f90:18:20: C081 'do_check' is initialised in its declaration and has no explicit `save` or `parameter` attribute
   |
16 |         LOGICAL, OPTIONAL, INTENT(OUT) :: success
17 |         REAL(dp), DIMENSION(size(A, 1), size(A, 1)) :: Bk, I, B_Nm1, AB
18 |         LOGICAL :: do_check = .TRUE.
   |                    ^^^^^^^^^^^^^^^^^ C081
19 |         INTEGER :: N, k
   |

linear_algebra\NAFPack_Preconditioners.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_Preconditioners
2 |
3 |     USE NAFPack_constant
  |     ^^^^^^^^^^^^^^^^^^^^ C121
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_matricielle
  |

linear_algebra\NAFPack_Preconditioners.f90:4:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_Iterative_types
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
5 |     USE NAFPack_matricielle
6 |     USE NAFPack_matrix_decomposition
  |

linear_algebra\NAFPack_Preconditioners.f90:5:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_constant
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_matricielle
  |     ^^^^^^^^^^^^^^^^^^^^^^^ C121
6 |     USE NAFPack_matrix_decomposition
  |

linear_algebra\NAFPack_Preconditioners.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_Iterative_types
5 |     USE NAFPack_matricielle
6 |     USE NAFPack_matrix_decomposition
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
7 |
8 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

linear_algebra\NAFPack_Preconditioners.f90:43:101: S001 line length of 102, exceeds maximum 100
   |
42 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_NONE = MethodPreconditioner(0, "None")
43 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, "Jacobi")
   |                                                                                                     ^^ S001
44 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner(2, "Gauss-Seidel")
45 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner(3, "Successive Over-Relaxation")
   |

linear_algebra\NAFPack_Preconditioners.f90:44:101: S001 line length of 104, exceeds maximum 100
   |
42 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_NONE = MethodPreconditioner(0, "None")
43 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, "Jacobi")
44 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner(2, "Gauss-Seidel")
   |                                                                                                     ^^^^ S001
45 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner(3, "Successive Over-Relaxation")
46 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JOR = MethodPreconditioner(4, "Jacobi Over-Relaxation")
   |

linear_algebra\NAFPack_Preconditioners.f90:45:101: S001 line length of 119, exceeds maximum 100
   |
43 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, "Jacobi")
44 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner(2, "Gauss-Seidel")
45 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner(3, "Successive Over-Relaxation")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^ S001
46 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JOR = MethodPreconditioner(4, "Jacobi Over-Relaxation")
47 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_ILU = MethodPreconditioner(5, "ILU")
   |

linear_algebra\NAFPack_Preconditioners.f90:46:101: S001 line length of 115, exceeds maximum 100
   |
44 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner(2, "Gauss-Seidel")
45 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner(3, "Successive Over-Relaxation")
46 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_JOR = MethodPreconditioner(4, "Jacobi Over-Relaxation")
   |                                                                                                     ^^^^^^^^^^^^^^^ S001
47 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_ILU = MethodPreconditioner(5, "ILU")
48 |     TYPE(MethodPreconditioner), PARAMETER :: METHOD_PRECOND_ICF = MethodPreconditioner(6, "ICF")
   |

linear_algebra\NAFPack_linalg.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_linalg
2 |
3 |     USE NAFPack_Direct_types
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ C121
4 |     USE NAFPack_Direct_method
  |

linear_algebra\NAFPack_linalg.f90:4:5: C121 'use' statement missing 'only' clause
  |
3 |     USE NAFPack_Direct_types
4 |     USE NAFPack_Direct_method
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ C121
5 |
6 |     USE NAFPack_Iterative_types
  |

linear_algebra\NAFPack_linalg.f90:6:5: C121 'use' statement missing 'only' clause
  |
4 |     USE NAFPack_Direct_method
5 |
6 |     USE NAFPack_Iterative_types
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
7 |     USE NAFPack_Iterative_methods
  |

linear_algebra\NAFPack_linalg.f90:7:5: C121 'use' statement missing 'only' clause
  |
6 |     USE NAFPack_Iterative_types
7 |     USE NAFPack_Iterative_methods
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C121
8 |
9 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

memory\NAFPack_memory_monitor.f90:3:5: C121 'use' statement missing 'only' clause
  |
1 | MODULE NAFPack_memory_monitor
2 |
3 |     USE iso_c_binding
  |     ^^^^^^^^^^^^^^^^^ C121
4 |
5 |     IMPLICIT NONE(TYPE, EXTERNAL)
  |

memory\NAFPack_memory_monitor.f90:13:9: C002 interface 'subroutine' missing 'implicit none'
   |
11 | #ifdef _WIN32
12 |     INTERFACE
13 |         SUBROUTINE get_windows_memory(mem_kb) BIND(C, name="get_windows_memory")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C002
14 |             IMPORT c_int
15 |             INTEGER(c_int), INTENT(OUT) :: mem_kb
16 |         END SUBROUTINE
   |

memory\NAFPack_memory_monitor.f90:16:9: S061 [*] end statement should be named.
   |
14 |             IMPORT c_int
15 |             INTEGER(c_int), INTENT(OUT) :: mem_kb
16 |         END SUBROUTINE
   |         ^^^^^^^^^^^^^^ S061
17 |     END INTERFACE
18 | #else
19 |     INTERFACE
   |
   = help: Write as 'end subroutine get_windows_memory'.

memory\NAFPack_memory_monitor.f90:20:9: C002 interface 'subroutine' missing 'implicit none'
   |
18 | #else
19 |     INTERFACE
20 |         SUBROUTINE get_linux_memory(mem_kb) BIND(C, NAME="get_linux_memory")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C002
21 |             IMPORT c_int
22 |             INTEGER(c_int), INTENT(OUT) :: mem_kb
23 |         END SUBROUTINE
   |

memory\NAFPack_memory_monitor.f90:23:9: S061 [*] end statement should be named.
   |
21 |             IMPORT c_int
22 |             INTEGER(c_int), INTENT(OUT) :: mem_kb
23 |         END SUBROUTINE
   |         ^^^^^^^^^^^^^^ S061
24 |     END INTERFACE
25 | #endif
   |
   = help: Write as 'end subroutine get_linux_memory'.

fortitude: 21 files scanned.
Number of errors: 148

For more information about specific rules, run:

    fortitude explain X001,Y002,...

[*] 3 fixable with the `--fix` option.
