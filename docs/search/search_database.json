var tipuesearch = {"pages":[{"title":" NAFPack ","text":"NAFPack NAFPack Features Author License About This Documentation Warning This documentation is a work in progress NAFPack A modern, modular, and open-source Fortran package for numerical analysis, designed to provide robust and efficient tools for scientific computing. Features Fast Fourier Transform (FFT) Linear system solvers Eigenvalue and eigenvector computations And more... Author Minard-Jules License This project is licensed under the MIT License . About This Documentation This documentation provides an overview of the NAFPack project, including installation instructions, usage examples. Please note that this documentation is a work in progress and may be updated frequently. Developer Info Minard Jules","tags":"home","url":"index.html"},{"title":"config_type – NAFPack ","text":"type, public :: config_type Configuration type for NAFPack Components Type Visibility Attributes Name Initial real(kind=dp), public :: pivot_tolerance = 1.0e-14_dp real(kind=dp), public :: convergence_tolerance = 1.0e-12_dp real(kind=dp), public :: residual_tolerance = 1.0e-10_dp integer, public :: max_iterations = 10000 integer, public :: block_size = 64 logical, public :: use_openmp = .TRUE. logical, public :: use_blas = .TRUE. logical, public :: preallocate_workspace = .TRUE. integer, public :: workspace_size = 1000 logical, public :: enable_debug = .FALSE. logical, public :: enable_timing = .FALSE. character(len=100), public :: log_file = \"nafpack.log\" character(len=50), public :: default_direct_method = \"A_LU\" character(len=50), public :: default_iterative_method = \"Gauss_Seidel\" character(len=50), public :: default_preconditioner = \"ILU\" Source Code TYPE :: config_type ! Numerical tolerances REAL ( dp ) :: pivot_tolerance = 1.0e-14_dp REAL ( dp ) :: convergence_tolerance = 1.0e-12_dp REAL ( dp ) :: residual_tolerance = 1.0e-10_dp ! Performance settings INTEGER :: max_iterations = 10000 INTEGER :: block_size = 64 LOGICAL :: use_openmp = . TRUE . LOGICAL :: use_blas = . TRUE . ! Memory management LOGICAL :: preallocate_workspace = . TRUE . INTEGER :: workspace_size = 1000 ! Debugging and logging LOGICAL :: enable_debug = . FALSE . LOGICAL :: enable_timing = . FALSE . CHARACTER ( LEN = 100 ) :: log_file = \"nafpack.log\" ! Method selection CHARACTER ( LEN = 50 ) :: default_direct_method = \"A_LU\" CHARACTER ( LEN = 50 ) :: default_iterative_method = \"Gauss_Seidel\" CHARACTER ( LEN = 50 ) :: default_preconditioner = \"ILU\" END TYPE config_type","tags":"","url":"type\\config_type.html"},{"title":"MethodTypeIterative – NAFPack ","text":"type, public :: MethodTypeIterative Inherited by type~~methodtypeiterative~~InheritedByGraph type~methodtypeiterative MethodTypeIterative type~iterativemethod IterativeMethod type~iterativemethod->type~methodtypeiterative method_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name character(len=64), public :: name2 = \"\" Source Code TYPE :: MethodTypeIterative INTEGER :: id CHARACTER ( LEN = 64 ) :: name CHARACTER ( LEN = 64 ) :: name2 = \"\" END TYPE MethodTypeIterative","tags":"","url":"type\\methodtypeiterative.html"},{"title":"IterativeMethodRequirements – NAFPack ","text":"type, public :: IterativeMethodRequirements Inherited by type~~iterativemethodrequirements~~InheritedByGraph type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod IterativeMethod type~iterativemethod->type~iterativemethodrequirements requirements type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_diag_dom = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_symetric = .FALSE. Source Code TYPE :: IterativeMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_diag_dom = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_symetric = . FALSE . END TYPE IterativeMethodRequirements","tags":"","url":"type\\iterativemethodrequirements.html"},{"title":"Norm_used – NAFPack ","text":"type, public :: Norm_used Inherited by type~~norm_used~~InheritedByGraph type~norm_used Norm_used type~iterativeparams IterativeParams type~iterativeparams->type~norm_used norm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code TYPE :: Norm_used INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE Norm_used","tags":"","url":"type\\norm_used.html"},{"title":"relaxation_factor_used – NAFPack ","text":"type, public :: relaxation_factor_used Inherited by type~~relaxation_factor_used~~InheritedByGraph type~relaxation_factor_used relaxation_factor_used type~iterativemethod IterativeMethod type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(kind=ucs4, len=64), public :: name Source Code TYPE :: relaxation_factor_used INTEGER :: id CHARACTER ( KIND = ucs4 , LEN = 64 ) :: name END TYPE relaxation_factor_used","tags":"","url":"type\\relaxation_factor_used.html"},{"title":"MethodPreconditioner – NAFPack ","text":"type, public :: MethodPreconditioner Inherited by type~~methodpreconditioner~~InheritedByGraph type~methodpreconditioner MethodPreconditioner type~iterativemethod IterativeMethod type~iterativemethod->type~methodpreconditioner preconditioner_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code TYPE :: MethodPreconditioner INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodPreconditioner","tags":"","url":"type\\methodpreconditioner.html"},{"title":"Fill_level_used – NAFPack ","text":"type, public :: Fill_level_used Inherited by type~~fill_level_used~~InheritedByGraph type~fill_level_used Fill_level_used type~iterativeparams IterativeParams type~iterativeparams->type~fill_level_used fill_level Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name integer, public :: VALUE Source Code TYPE :: Fill_level_used INTEGER :: id CHARACTER ( LEN = 64 ) :: name INTEGER :: VALUE END TYPE Fill_level_used","tags":"","url":"type\\fill_level_used.html"},{"title":"linalg – NAFPack ","text":"type, public :: linalg Inherits type~~linalg~~InheritsGraph type~linalg linalg type~directmethod DirectMethod type~linalg->type~directmethod direct type~iterativemethod IterativeMethod type~linalg->type~iterativemethod iterative type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type type~relaxation_factor_used relaxation_factor_used type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative Source Code TYPE :: linalg TYPE ( DirectMethod ) :: direct TYPE ( IterativeMethod ) :: iterative END TYPE linalg","tags":"","url":"type\\linalg.html"},{"title":"MethodTypeDirect – NAFPack ","text":"type, public :: MethodTypeDirect Inherited by type~~methodtypedirect~~InheritedByGraph type~methodtypedirect MethodTypeDirect type~directmethod DirectMethod type~directmethod->type~methodtypedirect method_type type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code TYPE :: MethodTypeDirect INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeDirect","tags":"","url":"type\\methodtypedirect.html"},{"title":"MethodQR – NAFPack ","text":"type, public :: MethodQR Inherited by type~~methodqr~~InheritedByGraph type~methodqr MethodQR type~directmethod DirectMethod type~directmethod->type~methodqr qr_method type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code TYPE :: MethodQR INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodQR","tags":"","url":"type\\methodqr.html"},{"title":"DirectMethodRequirements – NAFPack ","text":"type, public :: DirectMethodRequirements Inherited by type~~directmethodrequirements~~InheritedByGraph type~directmethodrequirements DirectMethodRequirements type~directmethod DirectMethod type~directmethod->type~directmethodrequirements requirements type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_non_zero_diag = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_tridiagonal = .FALSE. logical, public :: needs_symmetric = .FALSE. Source Code TYPE :: DirectMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_non_zero_diag = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_tridiagonal = . FALSE . LOGICAL :: needs_symmetric = . FALSE . END TYPE DirectMethodRequirements","tags":"","url":"type\\directmethodrequirements.html"},{"title":"IterativeMethod – NAFPack ","text":"type, public :: IterativeMethod Inherits type~~iterativemethod~~InheritsGraph type~iterativemethod IterativeMethod type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type type~relaxation_factor_used relaxation_factor_used type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~iterativemethod~~InheritedByGraph type~iterativemethod IterativeMethod type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( MethodTypeIterative ), intent(in) :: method procedure, public :: solve => IterativeMethod_solve private  function IterativeMethod_solve(this, A, b, params, verbose) result(x) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(in) :: this real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b type( IterativeParams ), intent(inout) :: params type( Logger ), intent(inout), optional :: verbose Return Value real(kind=dp), DIMENSION(size(A, 1)) procedure, public :: Init_IterativeParams private  function Init_IterativeParams(this, N, A, x0, max_iter_choice, epsi_tol, omega, Norm_choice, fill_level, method_preconditioner, alpha, is_stationary, is_strict_mode) result(params) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this integer, intent(in) :: N real(kind=dp), intent(in), optional, DIMENSION(:, :) :: A real(kind=dp), intent(in), optional, DIMENSION(:) :: x0 integer, intent(in), optional :: max_iter_choice real(kind=dp), intent(in), optional :: epsi_tol real(kind=dp), intent(in), optional :: omega type( Norm_used ), intent(in), optional :: Norm_choice type( Fill_level_used ), intent(in), optional :: fill_level type( MethodPreconditioner ), intent(in), optional :: method_preconditioner real(kind=dp), intent(in), optional :: alpha logical, intent(in), optional :: is_stationary logical, intent(in), optional :: is_strict_mode Return Value type( IterativeParams ) procedure, public :: Dealocate_IterativeParams private  subroutine Dealocate_IterativeParams(this, params, success) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( IterativeParams ), intent(inout) :: params logical, intent(out), optional :: success procedure, public :: test_matrix private  subroutine test_matrix(this, A, params, verbose) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this real(kind=dp), intent(in), DIMENSION(:, :) :: A type( IterativeParams ), intent(in) :: params type( Logger ), intent(inout), optional :: verbose Source Code TYPE :: IterativeMethod PRIVATE TYPE ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE TYPE ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE TYPE ( IterativeMethodRequirements ) :: requirements TYPE ( relaxation_factor_used ) :: relaxation_factor = RELAXATION_FACTOR_NONE TYPE ( relaxation_factor_used ) :: relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE PROCEDURE ( solve_interface_Iterative ), PASS ( this ), POINTER :: solve_method => null () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: solve => IterativeMethod_solve PROCEDURE :: Init_IterativeParams => Init_IterativeParams PROCEDURE :: Dealocate_IterativeParams => Dealocate_IterativeParams PROCEDURE :: test_matrix => test_matrix END TYPE IterativeMethod","tags":"","url":"type\\iterativemethod.html"},{"title":"IterativeParams – NAFPack ","text":"type, public :: IterativeParams Inherits type~~iterativeparams~~InheritsGraph type~iterativeparams IterativeParams type~fill_level_used Fill_level_used type~iterativeparams->type~fill_level_used fill_level type~norm_used Norm_used type~iterativeparams->type~norm_used norm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: x_init real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: L real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: U real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: D real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: p real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: residual real(kind=dp), public :: norm_residual real(kind=dp), public :: norm_initial_residual = 1.d0 real(kind=dp), public :: tol = 1.0d-12 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: omega = 1.d0 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 type( Fill_level_used ), public :: fill_level = FILL_LEVEL_NONE logical, public :: is_stationary = .TRUE. logical, public :: strict_mode = .FALSE. real(kind=dp), public :: old_dot_product = 0.d0 type( Norm_used ), public :: norm = NORM_2 procedure( ApplyPreconditioner ), public, PASS(params), POINTER :: precond Type-Bound Procedures procedure, public :: norm_function private  function norm_function(this, vector) result(RESULT) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: this real(kind=dp), intent(in), DIMENSION(:) :: vector Return Value real(kind=dp) Source Code TYPE :: IterativeParams ! Solution and initial guess REAL ( dp ), DIMENSION (:), ALLOCATABLE :: x_init ! Preconditioner matrices REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: L , U , D ! Algorithm vectors REAL ( dp ), DIMENSION (:), ALLOCATABLE :: p REAL ( dp ), DIMENSION (:), ALLOCATABLE :: residual ! Norms and tolerances REAL ( dp ) :: norm_residual REAL ( dp ) :: norm_initial_residual = 1.d0 REAL ( dp ) :: tol = 1.0d-12 ! Iteration control INTEGER :: k = 0 INTEGER :: max_iter = 1000 ! Method parameters REAL ( dp ) :: omega = 1.d0 REAL ( dp ) :: alpha = 1.d0 REAL ( dp ) :: beta = 1.d0 ! ILU/IC fill level TYPE ( FILL_LEVEL_USED ) :: fill_level = FILL_LEVEL_NONE ! Flags LOGICAL :: is_stationary = . TRUE . LOGICAL :: strict_mode = . FALSE . ! Miscellaneous REAL ( dp ) :: old_dot_product = 0.d0 TYPE ( Norm_used ) :: norm = NORM_2 ! Preconditioner procedure pointer PROCEDURE ( ApplyPreconditioner ), PASS ( params ), POINTER :: precond CONTAINS PROCEDURE :: norm_function END TYPE IterativeParams","tags":"","url":"type\\iterativeparams.html"},{"title":"DirectMethod – NAFPack ","text":"type, public :: DirectMethod Inherits type~~directmethod~~InheritsGraph type~directmethod DirectMethod type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~directmethod~~InheritedByGraph type~directmethod DirectMethod type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method, set_pivot_partial, set_pivot_total) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodTypeDirect ), intent(in) :: method logical, optional :: set_pivot_partial logical, optional :: set_pivot_total procedure, public :: set_qr_method private  subroutine set_qr_method(this, qr_method) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodQR ), intent(in) :: qr_method procedure, public :: solve => DirectMethod_solve private  function DirectMethod_solve(this, A, b) result(x) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(in) :: this real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(size(A, 1)) procedure, public :: test_matrix private  subroutine test_matrix(this, A, strict_mode) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this real(kind=dp), intent(in), DIMENSION(:, :) :: A logical, intent(in), optional :: strict_mode Source Code TYPE :: DirectMethod PRIVATE TYPE ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE TYPE ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT LOGICAL :: use_partial_pivot = . FALSE . LOGICAL :: use_total_pivot = . FALSE . TYPE ( DirectMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Direct ), PASS ( this ), POINTER :: solve_method => null () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: set_qr_method => set_qr_method PROCEDURE :: solve => DirectMethod_solve PROCEDURE :: test_matrix => test_matrix END TYPE DirectMethod","tags":"","url":"type\\directmethod.html"},{"title":"Format_file – NAFPack ","text":"type, public :: Format_file Inherited by type~~format_file~~InheritedByGraph type~format_file Format_file type~logger Logger type~logger->type~format_file file_format Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id = 1 character(len=10), public :: format_name = \"txt\" character(len=100), public :: format_description = \"Text file format\" Source Code TYPE :: Format_file INTEGER :: id = 1 CHARACTER ( LEN = 10 ) :: format_name = \"txt\" CHARACTER ( LEN = 100 ) :: format_description = \"Text file format\" END TYPE Format_file","tags":"","url":"type\\format_file.html"},{"title":"Logger – NAFPack ","text":"type, public :: Logger Inherits type~~logger~~InheritsGraph type~logger Logger type~format_file Format_file type~logger->type~format_file file_format Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: verbosity_level = 1 logical, public :: to_terminal = .TRUE. logical, public :: to_file = .FALSE. integer, public :: frequency = 10 character(len=100), public :: filename = \"Log\" type( Format_file ), public :: file_format = FORMAT_FILE_LOG integer, public :: file_unit = 99 character(len=100), public :: message = \"Default log message\" logical, public :: show_Logger_initialization = .TRUE. logical, public :: show_matrix_test = .TRUE. logical, public :: show_info_solver = .TRUE. logical, public :: show_iteration = .TRUE. logical, public :: show_final = .TRUE. Type-Bound Procedures procedure, public :: init => init_logger private  subroutine init_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this procedure, public :: log_info private  subroutine log_info(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_detail private  subroutine log_detail(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_warning private  subroutine log_warning(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_error private  subroutine log_error(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_time private  subroutine log_time(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: WRITE => write_output private  subroutine write_output(this, msg, name_level, color_level, box_style) Arguments Type Intent Optional Attributes Name class( Logger ), intent(in) :: this character(kind=ucs4, len=*), intent(in) :: msg character(kind=ucs4, len=*), intent(in), optional :: name_level character(kind=ucs4, len=*), intent(in), optional :: color_level character(len=*), intent(in), optional :: box_style procedure, public :: CLOSE => close_logger private  subroutine close_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this Source Code TYPE :: Logger INTEGER :: verbosity_level = 1 LOGICAL :: to_terminal = . TRUE . LOGICAL :: to_file = . FALSE . INTEGER :: frequency = 10 CHARACTER ( LEN = 100 ) :: filename = \"Log\" TYPE ( Format_file ) :: file_format = FORMAT_FILE_LOG INTEGER :: file_unit = 99 CHARACTER ( LEN = 100 ) :: message = \"Default log message\" LOGICAL :: show_Logger_initialization = . TRUE . LOGICAL :: show_matrix_test = . TRUE . LOGICAL :: show_info_solver = . TRUE . LOGICAL :: show_iteration = . TRUE . LOGICAL :: show_final = . TRUE . CONTAINS PROCEDURE :: init => init_logger PROCEDURE :: log_info PROCEDURE :: log_detail PROCEDURE :: log_warning PROCEDURE :: log_error PROCEDURE :: log_time PROCEDURE :: WRITE => write_output PROCEDURE :: CLOSE => close_logger END TYPE Logger","tags":"","url":"type\\logger.html"},{"title":"Eigen – NAFPack","text":"public  subroutine Eigen(A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Power iteration QR algorithm (with or without shift)\nThe default method is Power iteration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k Calls proc~~eigen~~CallsGraph proc~eigen Eigen proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~eigen~~CalledByGraph proc~eigen Eigen proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( present ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = size ( A , 1 ) IF ( size ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( size ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( present ( vp ) . AND . ( size ( vp , 1 ) /= N . OR . size ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( present ( vp )) vp = vp_tmp ELSE IF ( index ( method , \"QR\" ) == 1 ) THEN IF ( present ( vp )) vp = 0 IF ( present ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = index ( trim ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == len_trim ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen","tags":"","url":"proc\\eigen.html"},{"title":"get_default_config – NAFPack","text":"public  function get_default_config() result(config) Get default configuration Arguments None Return Value type( config_type ) Source Code FUNCTION get_default_config () RESULT ( config ) TYPE ( config_type ) :: config ! Default values are already set in the type definition ! No need to explicitly set them as they're defined in the type config = config_type ( pivot_tolerance = TOL_PIVOT , & convergence_tolerance = TOL_CONVERGENCE , & residual_tolerance = epsi , & max_iterations = kmax , & block_size = 64 , & use_openmp = . TRUE ., & use_blas = . TRUE ., & preallocate_workspace = . TRUE ., & workspace_size = 1000 , & enable_debug = . FALSE ., & enable_timing = . FALSE ., & log_file = \"nafpack.log\" , & default_direct_method = \"A_LU\" , & default_iterative_method = \"Gauss_Seidel\" , & default_preconditioner = \"ILU\" ) END FUNCTION get_default_config","tags":"","url":"proc\\get_default_config.html"},{"title":"validate_config – NAFPack","text":"public  subroutine validate_config(config, is_valid, error_msg) Validate configuration parameters Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: config logical, intent(out) :: is_valid character(len=*), intent(out) :: error_msg Source Code SUBROUTINE validate_config ( config , is_valid , error_msg ) TYPE ( config_type ), INTENT ( IN ) :: config LOGICAL , INTENT ( OUT ) :: is_valid CHARACTER ( LEN =* ), INTENT ( OUT ) :: error_msg is_valid = . TRUE . error_msg = \"\" ! Check tolerances IF ( config % pivot_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Pivot tolerance must be positive\" RETURN END IF IF ( config % convergence_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Convergence tolerance must be positive\" RETURN END IF ! Check iteration limits IF ( config % max_iterations <= 0 ) THEN is_valid = . FALSE . error_msg = \"Maximum iterations must be positive\" RETURN END IF ! Check block size IF ( config % block_size <= 0 ) THEN is_valid = . FALSE . error_msg = \"Block size must be positive\" RETURN END IF END SUBROUTINE validate_config","tags":"","url":"proc\\validate_config.html"},{"title":"get_memory_kb – NAFPack","text":"public  function get_memory_kb() result(memory_kb) Arguments None Return Value integer Source Code FUNCTION get_memory_kb () RESULT ( memory_kb ) INTEGER :: memory_kb memory_kb = 0 #ifdef _WIN32 CALL get_windows_memory ( memory_kb ) #else CALL get_linux_memory ( memory_kb ) #endif END FUNCTION get_memory_kb","tags":"","url":"proc\\get_memory_kb.html"},{"title":"forward – NAFPack","text":"public  function forward(L, b) result(y) forward algorithm,\nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(size(L, 1)) Called by proc~~forward~~CalledByGraph proc~forward forward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( L , 1 )) :: y INTEGER :: i , N N = size ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - dot_product ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward","tags":"","url":"proc\\forward.html"},{"title":"backward – NAFPack","text":"public  function backward(U, y) result(x) backward algorithm,\nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(size(U, 1)) Called by proc~~backward~~CalledByGraph proc~backward backward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~backward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( size ( U , 1 )) :: x INTEGER :: i , N N = size ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - dot_product ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward","tags":"","url":"proc\\backward.html"},{"title":"LU_decomposition – NAFPack","text":"public  subroutine LU_decomposition(A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U Source Code SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = size ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition","tags":"","url":"proc\\lu_decomposition.html"},{"title":"LDU_decomposition – NAFPack","text":"public  subroutine LDU_decomposition(A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U Source Code SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = size ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [( D ( k , k ), k = 1 , i - 1 )])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition","tags":"","url":"proc\\ldu_decomposition.html"},{"title":"ILU_decomposition – NAFPack","text":"public  subroutine ILU_decomposition(A, L, U, level) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U integer, intent(in), optional :: level Called by proc~~ilu_decomposition~~CalledByGraph proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~calculate_ilu_preconditioner->proc~ilu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE ILU_decomposition ( A , L , U , level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER , OPTIONAL , INTENT ( IN ) :: level INTEGER :: N , i , j INTEGER , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: fill_level LOGICAL , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: S N = size ( A , 1 ) L = 0.d0 U = 0.d0 IF ( present ( level )) THEN CALL compute_fill_pattern_ILU ( A , fill_level , level , N ) S = ( fill_level <= level ) ELSE S = A /= 0 END IF DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j IF ( S ( i , j )) U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO IF ( abs ( U ( j , j )) < 1.0e-12_dp ) THEN PRINT * , \"Warning: Near-zero pivot at row \" , j , \", value =\" , U ( j , j ) PRINT * , \"Replacing with small value, value =\" , sign ( 1.0e-12_dp , U ( j , j )) U ( j , j ) = sign ( 1.0e-12_dp , U ( j , j )) END IF DO i = j + 1 , N IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE ILU_decomposition","tags":"","url":"proc\\ilu_decomposition.html"},{"title":"Cholesky_decomposition – NAFPack","text":"public  subroutine Cholesky_decomposition(A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L Source Code SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = size ( A , 1 ) DO j = 1 , N L ( j , j ) = sqrt ( A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition","tags":"","url":"proc\\cholesky_decomposition.html"},{"title":"LDL_Cholesky_decomposition – NAFPack","text":"public  subroutine LDL_Cholesky_decomposition(A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: D Calls proc~~ldl_cholesky_decomposition~~CallsGraph proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~identity_n Identity_n proc~ldl_cholesky_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE LDL_Cholesky_decomposition ( A , L , D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , D INTEGER :: i , j , N , k N = size ( A , 1 ) L = Identity_n ( N ) D = 0.d0 DO j = 1 , N D ( j , j ) = A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )])) / D ( j , j ) END DO END DO END SUBROUTINE LDL_Cholesky_decomposition","tags":"","url":"proc\\ldl_cholesky_decomposition.html"},{"title":"Incomplete_Cholesky_decomposition – NAFPack","text":"public  subroutine Incomplete_Cholesky_decomposition(A, L, level) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L integer, intent(in), optional :: level Called by proc~~incomplete_cholesky_decomposition~~CalledByGraph proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Incomplete_Cholesky_decomposition ( A , L , level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , OPTIONAL , INTENT ( IN ) :: level REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L LOGICAL , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: S INTEGER :: N , i , j INTEGER , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: fill_level N = size ( A , 1 ) L = 0.d0 IF ( present ( level )) THEN CALL compute_fill_pattern_IC ( A , fill_level , level , N ) S = ( fill_level <= level ) ELSE S = A /= 0 END IF DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO IF ( S ( i , i )) L ( i , i ) = sqrt ( A ( i , i ) - dot_product ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) END DO END SUBROUTINE Incomplete_Cholesky_decomposition","tags":"","url":"proc\\incomplete_cholesky_decomposition.html"},{"title":"QR_decomposition – NAFPack","text":"public  subroutine QR_decomposition(A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R Calls proc~~qr_decomposition~~CallsGraph proc~qr_decomposition QR_decomposition proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_decomposition~~CalledByGraph proc~qr_decomposition QR_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) END IF END SUBROUTINE QR_decomposition","tags":"","url":"proc\\qr_decomposition.html"},{"title":"QR_Householder_decomposition – NAFPack","text":"public  subroutine QR_Householder_decomposition(A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R Calls proc~~qr_householder_decomposition~~CallsGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~identity_n Identity_n proc~qr_householder_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_householder_decomposition~~CalledByGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Householder_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( size ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = size ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = norm2 ( R ( k : N , k )) signe = - sign ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = norm2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = matmul ( Q , H ) R ( k : N , k : N ) = matmul ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder_decomposition","tags":"","url":"proc\\qr_householder_decomposition.html"},{"title":"QR_Givens_decomposition – NAFPack","text":"public  subroutine QR_Givens_decomposition(A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R Calls proc~~qr_givens_decomposition~~CallsGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_givens_decomposition~~CalledByGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Givens_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: G INTEGER :: N , i , j N = size ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = matmul ( G , R ) Q = matmul ( Q , transpose ( G )) END DO END DO END SUBROUTINE QR_Givens_decomposition","tags":"","url":"proc\\qr_givens_decomposition.html"},{"title":"QR_Gram_Schmidt_Classical_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Classical_decomposition(A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R Called by proc~~qr_gram_schmidt_classical_decomposition~~CalledByGraph proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 )) :: u INTEGER :: N , i , j N = size ( A , 1 ) Q = 0.d0 R = 0.d0 DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = dot_product ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = norm2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical_decomposition","tags":"","url":"proc\\qr_gram_schmidt_classical_decomposition.html"},{"title":"QR_Gram_Schmidt_Modified_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Modified_decomposition(A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R Called by proc~~qr_gram_schmidt_modified_decomposition~~CalledByGraph proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: u INTEGER :: N , i , j N = size ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = norm2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = dot_product ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified_decomposition","tags":"","url":"proc\\qr_gram_schmidt_modified_decomposition.html"},{"title":"pivot_partial – NAFPack","text":"public  subroutine pivot_partial(A, P) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: P Calls proc~~pivot_partial~~CallsGraph proc~pivot_partial pivot_partial proc~identity_n Identity_n proc~pivot_partial->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE pivot_partial ( A , P ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: P INTEGER , DIMENSION ( 1 ) :: vlmax INTEGER :: N , lmax , k REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: P_tmp N = size ( A , 1 ) P = Identity_n ( N ) DO k = 1 , N - 1 ! Find the maximum absolute value in the column from row k to N vlmax = maxloc ( abs ( A ( k : N , k ))) lmax = vlmax ( 1 ) + k - 1 !calculate permutation matrix P P_tmp = Identity_n ( N ) IF ( k /= lmax ) THEN P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) END IF P = matmul ( P_tmp , P ) END DO END SUBROUTINE pivot_partial","tags":"","url":"proc\\pivot_partial.html"},{"title":"pivot_total – NAFPack","text":"public  subroutine pivot_total(A, P, Q) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: P real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: Q Calls proc~~pivot_total~~CallsGraph proc~pivot_total pivot_total proc~identity_n Identity_n proc~pivot_total->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE pivot_total ( A , P , Q ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: P , Q REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: P_tmp , Q_tmp INTEGER , DIMENSION ( 2 ) :: vlmax INTEGER :: N , lmax , cmax , k N = size ( A , 1 ) P = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N - 1 ! Find max abs element in submatrix vlmax = maxloc ( abs ( A ( k : N , k : N ))) lmax = vlmax ( 1 ) + k - 1 cmax = vlmax ( 2 ) + k - 1 ! permute line if necessary P_tmp = Identity_n ( N ) IF ( k /= lmax ) THEN P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) END IF P = matmul ( P_tmp , P ) ! permute column if necessary Q_tmp = Identity_n ( N ) IF ( cmax /= k ) THEN Q_tmp (:, [ k , cmax ]) = Q_tmp (:, [ cmax , k ]) END IF Q = matmul ( Q_tmp , Q ) END DO END SUBROUTINE pivot_total","tags":"","url":"proc\\pivot_total.html"},{"title":"Calculate_Jacobi_preconditioner – NAFPack","text":"public  function Calculate_Jacobi_preconditioner(A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~calculate_jacobi_preconditioner~~CallsGraph proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~diag Diag proc~calculate_jacobi_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_Jacobi_preconditioner ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: D INTEGER :: N , i N = size ( A , 1 ) D = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Jacobi preconditioner\" FORALL ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) END FUNCTION Calculate_Jacobi_preconditioner","tags":"","url":"proc\\calculate_jacobi_preconditioner.html"},{"title":"Calculate_Gauss_Seidel_preconditioner – NAFPack","text":"public  function Calculate_Gauss_Seidel_preconditioner(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~calculate_gauss_seidel_preconditioner~~CallsGraph proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~diag Diag proc~calculate_gauss_seidel_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_Gauss_Seidel_preconditioner ( A ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER :: N , i , j N = size ( A , 1 ) L = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" FORALL ( i = 1 : size ( A , 1 ), j = 1 : size ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) END FUNCTION Calculate_Gauss_Seidel_preconditioner","tags":"","url":"proc\\calculate_gauss_seidel_preconditioner.html"},{"title":"Calculate_SOR_preconditioner – NAFPack","text":"public  function Calculate_SOR_preconditioner(A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~calculate_sor_preconditioner~~CallsGraph proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~diag Diag proc~calculate_sor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_SOR_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER :: N , i N = size ( A , 1 ) L = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in SOR preconditioner\" DO i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) END DO L = alpha * L END FUNCTION Calculate_SOR_preconditioner","tags":"","url":"proc\\calculate_sor_preconditioner.html"},{"title":"Calculate_JOR_preconditioner – NAFPack","text":"public  function Calculate_JOR_preconditioner(A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~calculate_jor_preconditioner~~CallsGraph proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~diag Diag proc~calculate_jor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_JOR_preconditioner ( A , omega , alpha ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: D INTEGER :: N , i N = size ( A , 1 ) D = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in JOR preconditioner\" FORALL ( i = 1 : size ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha END FUNCTION Calculate_JOR_preconditioner","tags":"","url":"proc\\calculate_jor_preconditioner.html"},{"title":"Calculate_ICF_preconditioner – NAFPack","text":"public  function Calculate_ICF_preconditioner(A, omega, alpha, fill_level) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~calculate_icf_preconditioner~~CallsGraph proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_ICF_preconditioner ( A , omega , alpha , fill_level ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER , OPTIONAL , INTENT ( IN ) :: fill_level INTEGER :: N N = size ( A , 1 ) L = 0.d0 IF ( present ( fill_level )) THEN CALL Incomplete_Cholesky_decomposition ( A , L , fill_level ) ELSE CALL Incomplete_Cholesky_decomposition ( A , L ) END IF L = alpha / omega * L END FUNCTION Calculate_ICF_preconditioner","tags":"","url":"proc\\calculate_icf_preconditioner.html"},{"title":"Calculate_ILU_preconditioner – NAFPack","text":"public  subroutine Calculate_ILU_preconditioner(A, L, U, omega, alpha, fill_level) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Calls proc~~calculate_ilu_preconditioner~~CallsGraph proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner->proc~ilu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Calculate_ILU_preconditioner ( A , L , U , omega , alpha , fill_level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: L , U INTEGER , OPTIONAL , INTENT ( IN ) :: fill_level INTEGER :: N N = size ( A , 1 ) L = 0.d0 U = 0.d0 IF ( present ( fill_level )) THEN CALL ILU_decomposition ( A , L , U , fill_level ) ELSE CALL ILU_decomposition ( A , L , U ) END IF L = alpha / omega * L END SUBROUTINE Calculate_ILU_preconditioner","tags":"","url":"proc\\calculate_ilu_preconditioner.html"},{"title":"Calculate_SSOR_preconditioner – NAFPack","text":"public  subroutine Calculate_SSOR_preconditioner(A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Source Code SUBROUTINE Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: L , D INTEGER :: N , i N = size ( A , 1 ) L = 0.d0 D = 0.d0 DO i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) END DO L = ( alpha * omega ) / ( 2 - omega ) * L END SUBROUTINE Calculate_SSOR_preconditioner","tags":"","url":"proc\\calculate_ssor_preconditioner.html"},{"title":"is_square_matrix – NAFPack","text":"public  function is_square_matrix(A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_square_matrix ( A ) RESULT ( is_square ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_square is_square = ( size ( A , 1 ) == size ( A , 2 )) END FUNCTION is_square_matrix","tags":"","url":"proc\\is_square_matrix.html"},{"title":"is_symmetric – NAFPack","text":"public  function is_symmetric(A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Called by proc~~is_symmetric~~CalledByGraph proc~is_symmetric is_symmetric proc~is_spd is_SPD proc~is_spd->proc~is_symmetric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_symmetric ( A ) RESULT ( is_sym ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_sym is_sym = all ( A == transpose ( A )) END FUNCTION is_symmetric","tags":"","url":"proc\\is_symmetric.html"},{"title":"is_orthogonal – NAFPack","text":"public  function is_orthogonal(A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Calls proc~~is_orthogonal~~CallsGraph proc~is_orthogonal is_orthogonal proc~identity_n Identity_n proc~is_orthogonal->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_orthogonal ( A ) RESULT ( is_orth ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_orth is_orth = all ( abs ( matmul ( A , transpose ( A )) - Identity_n ( size ( A , 1 ))) < epsi_test ) END FUNCTION is_orthogonal","tags":"","url":"proc\\is_orthogonal.html"},{"title":"is_SPD – NAFPack","text":"public  function is_SPD(A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical Calls proc~~is_spd~~CallsGraph proc~is_spd is_SPD proc~eigen Eigen proc~is_spd->proc~eigen proc~is_symmetric is_symmetric proc~is_spd->proc~is_symmetric proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_SPD ( A , is_sym ) RESULT ( is_spd_matrix ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: is_sym REAL ( dp ), DIMENSION ( size ( A , 1 )) :: lambda LOGICAL :: is_spd_matrix IF ( present ( is_sym )) THEN IF (. NOT . is_sym ) THEN is_spd_matrix = . FALSE . RETURN END IF ELSE IF (. NOT . is_symmetric ( A )) THEN is_spd_matrix = . FALSE . RETURN END IF CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( minval ( lambda ) < 0 ) THEN is_spd_matrix = . FALSE . ELSE is_spd_matrix = . TRUE . END IF END FUNCTION is_SPD","tags":"","url":"proc\\is_spd.html"},{"title":"is_tridiagonal – NAFPack","text":"public  function is_tridiagonal(A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_tridiagonal ( A ) RESULT ( is_tridiag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_tridiag INTEGER :: i , j , N N = size ( A , 1 ) is_tridiag = . TRUE . DO i = 1 , N DO j = 1 , N IF ( abs ( i - j ) > 1 ) THEN IF ( abs ( A ( i , j )) > epsi ) THEN is_tridiag = . FALSE . RETURN END IF END IF END DO END DO END FUNCTION is_tridiagonal","tags":"","url":"proc\\is_tridiagonal.html"},{"title":"is_diagonally_dominant – NAFPack","text":"public  function is_diagonally_dominant(A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_diagonally_dominant ( A ) RESULT ( is_diag_dom ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_diag_dom INTEGER :: i , N REAL ( dp ) :: row_sum N = size ( A , 1 ) is_diag_dom = . TRUE . DO i = 1 , N row_sum = sum ( abs ( A ( i , :))) - abs ( A ( i , i )) IF ( abs ( A ( i , i )) < row_sum ) THEN is_diag_dom = . FALSE . RETURN END IF END DO END FUNCTION is_diagonally_dominant","tags":"","url":"proc\\is_diagonally_dominant.html"},{"title":"is_non_zero_diagonal – NAFPack","text":"public  function is_non_zero_diagonal(A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Calls proc~~is_non_zero_diagonal~~CallsGraph proc~is_non_zero_diagonal is_non_zero_diagonal proc~diag Diag proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_non_zero_diagonal ( A ) RESULT ( is_non_zero_diag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_non_zero_diag is_non_zero_diag = . TRUE . IF ( any ( abs ( Diag ( A )) < epsi )) is_non_zero_diag = . FALSE . END FUNCTION is_non_zero_diagonal","tags":"","url":"proc\\is_non_zero_diagonal.html"},{"title":"readMatrixMarket – NAFPack","text":"public  subroutine readMatrixMarket(filename, A) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), DIMENSION(:, :), ALLOCATABLE :: A Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nrows integer, public :: ncols integer, public :: nnz integer, public :: ios integer, public :: k integer, public :: row_idx integer, public :: col_idx character(len=256), public :: line character(len=256), public :: header character(len=50), public :: object character(len=50), public :: format_type character(len=50), public :: field character(len=50), public :: symmetry integer, public :: unit real(kind=dp), public :: val Source Code SUBROUTINE readMatrixMarket ( filename , A ) CHARACTER ( LEN =* ), INTENT ( IN ) :: filename REAL ( dp ), DIMENSION (:, :), ALLOCATABLE , INTENT ( OUT ) :: A INTEGER :: i , j , nrows , ncols , nnz , ios , k , row_idx , col_idx CHARACTER ( LEN = 256 ) :: line , header CHARACTER ( LEN = 50 ) :: object , format_type , field , symmetry INTEGER :: unit REAL ( dp ) :: val unit = 10 ! Open the file OPEN ( NEWUNIT = unit , FILE = filename , STATUS = 'old' , ACTION = 'read' , IOSTAT = ios ) IF ( ios /= 0 ) THEN PRINT * , 'Error: opening file: ' , filename STOP END IF ! read the header READ ( unit , '(A)' , IOSTAT = ios ) header IF ( ios /= 0 ) THEN PRINT * , 'Error: reading header Matrix Market' CLOSE ( unit ) STOP END IF ! Check Matrix Market format IF ( index ( header , '%%MatrixMarket' ) == 0 ) THEN PRINT * , 'Error: file is not in Matrix Market format' CLOSE ( unit ) RETURN END IF ! Parse the header to extract information READ ( header , * , iostat = ios ) object , object , format_type , field , symmetry IF ( ios /= 0 ) THEN PRINT * , 'Error reading Matrix Market header' CLOSE ( unit ) STOP END IF ! Skip comment lines and find the size line DO READ ( unit , '(A)' , IOSTAT = ios ) line IF ( ios /= 0 ) THEN PRINT * , 'Error: malformed file' CLOSE ( unit ) STOP END IF IF ( line ( 1 : 1 ) /= '%' ) THEN EXIT END IF END DO ! Read matrix dimensions READ ( line , * , iostat = ios ) nrows , ncols , nnz IF ( ios /= 0 ) THEN PRINT * , 'Error: unable to read dimensions' CLOSE ( unit ) RETURN END IF ALLOCATE ( A ( nrows , ncols )) A = 0.0_dp ! Read matrix entries IF ( trim ( format_type ) == 'coordinate' ) THEN ! Coordinate format (sparse) DO k = 1 , nnz READ ( unit , * , iostat = ios ) row_idx , col_idx , val IF ( ios /= 0 ) THEN PRINT * , 'Error: reading entry' , k EXIT END IF A ( row_idx , col_idx ) = val ! If the matrix is symmetric, also fill A(j,i) IF ( trim ( symmetry ) == 'symmetric' . AND . row_idx /= col_idx ) THEN A ( col_idx , row_idx ) = val END IF END DO ELSE IF ( trim ( format_type ) == 'array' ) THEN ! Dense format (array) DO j = 1 , ncols DO i = 1 , nrows READ ( unit , * , iostat = ios ) val IF ( ios /= 0 ) THEN PRINT * , 'Error: reading element (' , i , ',' , j , ')' CLOSE ( unit ) RETURN END IF A ( i , j ) = val END DO END DO ELSE PRINT * , 'Error: unsupported format: ' , trim ( format_type ) CLOSE ( unit ) RETURN END IF CLOSE ( unit ) END SUBROUTINE readMatrixMarket","tags":"","url":"proc\\readmatrixmarket.html"},{"title":"dot – NAFPack","text":"public  function dot(a, b) result(RESULT) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) Source Code FUNCTION dot ( a , b ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: RESULT INTEGER :: i IF ( size ( a ) /= size ( b )) STOP \"Error: Vectors must be of the same size.\" RESULT = 0.0_dp DO i = 1 , size ( a ) RESULT = RESULT + a ( i ) * b ( i ) END DO END FUNCTION dot","tags":"","url":"proc\\dot.html"},{"title":"cross – NAFPack","text":"public  function cross(a, b) result(RESULT) function that calculates the cross product between two real 3-dimensional vectors and 1 the wedge notation can sometimes be used to denote the vector product. ↩ Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) Source Code FUNCTION cross ( a , b ) RESULT ( RESULT ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: RESULT RESULT ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) RESULT ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) RESULT ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross","tags":"","url":"proc\\cross.html"},{"title":"norm_2_real – NAFPack","text":"public  function norm_2_real(a) result(RESULT) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_real~~CalledByGraph proc~norm_2_real norm_2_real proc~normalise normalise proc~normalise->proc~norm_2_real proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2_real ( a ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: RESULT RESULT = sqrt ( dot_product ( a , a )) END FUNCTION norm_2_real","tags":"","url":"proc\\norm_2_real.html"},{"title":"norm_2_complex – NAFPack","text":"public  function norm_2_complex(a) result(RESULT) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_complex~~CalledByGraph proc~norm_2_complex norm_2_complex proc~normalise_complexe normalise_complexe proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2_complex ( a ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: RESULT RESULT = sqrt ( REAL ( dot_product ( a , conjg ( a )))) END FUNCTION norm_2_complex","tags":"","url":"proc\\norm_2_complex.html"},{"title":"normalise – NAFPack","text":"public  function normalise(a) result(RESULT) function that normalises a real vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(size(a)) Calls proc~~normalise~~CallsGraph proc~normalise normalise proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~normalise~~CalledByGraph proc~normalise normalise proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise ( a ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( size ( a )) :: RESULT RESULT = a / norm_2_real ( a ) END FUNCTION normalise","tags":"","url":"proc\\normalise.html"},{"title":"normalise_complexe – NAFPack","text":"public  function normalise_complexe(a) result(RESULT) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(size(a)) Calls proc~~normalise_complexe~~CallsGraph proc~normalise_complexe normalise_complexe proc~norm_2_complex norm_2_complex proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise_complexe ( a ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( size ( a )) :: RESULT RESULT = a / norm_2_complex ( a ) END FUNCTION normalise_complexe","tags":"","url":"proc\\normalise_complexe.html"},{"title":"Trace – NAFPack","text":"public  function Trace(A) result(RESULT) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp) Called by proc~~trace~~CalledByGraph proc~trace Trace proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Trace ( A ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ) :: RESULT INTEGER :: i , N N = size ( A , 1 ) IF ( size ( A , 2 ) /= N ) STOP \"Error: Matrix must be square.\" RESULT = sum ([( A ( i , i ), i = 1 , N )]) END FUNCTION Trace","tags":"","url":"proc\\trace.html"},{"title":"Diagonally_Dominant_Matrix – NAFPack","text":"public  function Diagonally_Dominant_Matrix(A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = size ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = sum ( abs ( A ( i , :) - A ( i , i ))) IF ( abs ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix","tags":"","url":"proc\\diagonally_dominant_matrix.html"},{"title":"Identity_n – NAFPack","text":"public  function Identity_n(N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) Called by proc~~identity_n~~CalledByGraph proc~identity_n Identity_n proc~eigen Eigen proc~eigen->proc~identity_n proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~identity_n proc~is_orthogonal is_orthogonal proc~is_orthogonal->proc~identity_n proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~ldl_cholesky_decomposition->proc~identity_n proc~pivot_partial pivot_partial proc~pivot_partial->proc~identity_n proc~pivot_total pivot_total proc~pivot_total->proc~identity_n proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n proc~is_spd is_SPD proc~is_spd->proc~eigen proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_decomposition->proc~qr_householder_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( present ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n","tags":"","url":"proc\\identity_n.html"},{"title":"Diag – NAFPack","text":"public  function Diag(A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1)) Called by proc~~diag~~CalledByGraph proc~diag Diag proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~calculate_gauss_seidel_preconditioner->proc~diag proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~calculate_jacobi_preconditioner->proc~diag proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~calculate_jor_preconditioner->proc~diag proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~calculate_sor_preconditioner->proc~diag proc~is_non_zero_diagonal is_non_zero_diagonal proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Diag ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 )) :: D INTEGER :: i , N N = size ( A , 1 ) FORALL ( i = 1 : N ) D ( i ) = A ( i , i ) END FUNCTION Diag","tags":"","url":"proc\\diag.html"},{"title":"Make_Tridiagonal – NAFPack","text":"public  function Make_Tridiagonal(d_minus, d, d_plus) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: d_minus real(kind=dp), intent(in), DIMENSION(:) :: d real(kind=dp), intent(in), DIMENSION(:) :: d_plus Return Value real(kind=dp), DIMENSION(size(d, 1), size(d, 1)) Source Code FUNCTION Make_Tridiagonal ( d_minus , d , d_plus ) RESULT ( T ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: d_minus , d , d_plus REAL ( dp ), DIMENSION ( size ( d , 1 ), size ( d , 1 )) :: T INTEGER :: i , N N = size ( d , 1 ) T = 0.d0 DO i = 1 , N T ( i , i ) = d ( i ) IF ( i > 1 ) T ( i , i - 1 ) = d_minus ( i ) IF ( i < N ) T ( i , i + 1 ) = d_plus ( i ) END DO END FUNCTION Make_Tridiagonal","tags":"","url":"proc\\make_tridiagonal.html"},{"title":"rotation_matrix – NAFPack","text":"public  function rotation_matrix(A, rotation) result(G) Function to create a rotation matrix This function generates a rotation matrix G based on the input matrix A and the specified rotation indices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Calls proc~~rotation_matrix~~CallsGraph proc~rotation_matrix rotation_matrix proc~identity_n Identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation_matrix~~CalledByGraph proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( size ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = sqrt ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix","tags":"","url":"proc\\rotation_matrix.html"},{"title":"FFT_1D – NAFPack","text":"public  function FFT_1D(signal, method, threads) result(RESULT) Perform a 1D Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_DFT\": Direct Discrete Fourier Transform \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal)) Calls proc~~fft_1d~~CallsGraph proc~fft_1d FFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~fft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~fft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_1D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT IF ( method == \"NAFPack_DFT\" ) THEN RESULT = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN RESULT = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D","tags":"","url":"proc\\fft_1d.html"},{"title":"IFFT_1D – NAFPack","text":"public  function IFFT_1D(signal, method, threads) result(RESULT) Perform a 1D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal)) Calls proc~~ifft_1d~~CallsGraph proc~ifft_1d IFFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~ifft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT IF ( method == \"NAFPack_IFFT_1D\" ) THEN RESULT = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D","tags":"","url":"proc\\ifft_1d.html"},{"title":"FFT_2D – NAFPack","text":"public  function FFT_2D(signal, method, threads) result(RESULT) Perform a 2D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2)) Calls proc~~fft_2d~~CallsGraph proc~fft_2d FFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~fft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~fft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_2D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT IF ( method == \"NAFPack_FFT_2D\" ) THEN RESULT = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D","tags":"","url":"proc\\fft_2d.html"},{"title":"IFFT_2D – NAFPack","text":"public  function IFFT_2D(signal, method, threads) result(RESULT) Perform a 2D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2)) Calls proc~~ifft_2d~~CallsGraph proc~ifft_2d IFFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~ifft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT IF ( method == \"NAFPack_IFFT_2D\" ) THEN RESULT = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D","tags":"","url":"proc\\ifft_2d.html"},{"title":"FFT_3D – NAFPack","text":"public  function FFT_3D(signal, method, threads) result(RESULT) Perform a 3D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) Calls proc~~fft_3d~~CallsGraph proc~fft_3d FFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~fft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~fft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_3D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D","tags":"","url":"proc\\fft_3d.html"},{"title":"IFFT_3D – NAFPack","text":"public  function IFFT_3D(signal, method, threads) result(RESULT) Perform a 3D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) Calls proc~~ifft_3d~~CallsGraph proc~ifft_3d IFFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~ifft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D","tags":"","url":"proc\\ifft_3d.html"},{"title":"ApplyPreconditioner – NAFPack","text":"public  function ApplyPreconditioner(params, method, x) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method real(kind=dp), intent(in), DIMENSION(:) :: x Return Value real(kind=dp), DIMENSION(size(params%x_init)) Calls proc~~applypreconditioner~~CallsGraph proc~applypreconditioner ApplyPreconditioner proc~backward backward proc~applypreconditioner->proc~backward proc~forward forward proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION ApplyPreconditioner ( params , method , x ) RESULT ( y ) CLASS ( IterativeParams ), INTENT ( IN ) :: params CLASS ( MethodPreconditioner ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x REAL ( dp ), DIMENSION ( size ( params % x_init )) :: y SELECT CASE ( method % id ) CASE ( METHOD_PRECOND_JACOBI % id ) IF (. NOT . allocated ( params % D )) STOP \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) CASE ( METHOD_PRECOND_GS % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) CASE ( METHOD_PRECOND_SOR % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) CASE ( METHOD_PRECOND_JOR % id ) IF (. NOT . allocated ( params % D )) STOP \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) CASE ( METHOD_PRECOND_ILU % id ) IF (. NOT . allocated ( params % L ) . OR . & . NOT . allocated ( params % U )) STOP \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , x ) y = backward ( params % U , y ) CASE ( METHOD_PRECOND_ICF % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) y = backward ( transpose ( params % L ), y ) CASE ( METHOD_PRECOND_SSOR % id ) IF (. NOT . allocated ( params % L ) . OR . & . NOT . allocated ( params % D )) STOP \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , x ) y = matmul ( params % D , y ) y = backward ( transpose ( params % L ), y ) CASE DEFAULT STOP \"ERROR :: Unknown preconditioner method\" END SELECT END FUNCTION ApplyPreconditioner","tags":"","url":"proc\\applypreconditioner.html"},{"title":"meshgrid – NAFPack","text":"public  subroutine meshgrid(x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(size(y_vector), size(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(size(y_vector), size(x_vector)) :: Y Source Code SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( size ( y_vector ), size ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid","tags":"","url":"proc\\meshgrid.html"},{"title":"Faddeev_Leverrier – NAFPack","text":"public  subroutine Faddeev_Leverrier(A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: c real(kind=dp), intent(out), optional, DIMENSION(size(A, 1), size(A, 1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check Calls proc~~faddeev_leverrier~~CallsGraph proc~faddeev_leverrier Faddeev_Leverrier proc~identity_n Identity_n proc~faddeev_leverrier->proc~identity_n proc~trace Trace proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(1.0d0) real(kind=dp), public, DIMENSION(size(A, 1), size(A, 1)) :: Bk real(kind=dp), public, DIMENSION(size(A, 1), size(A, 1)) :: I real(kind=dp), public, DIMENSION(size(A, 1), size(A, 1)) :: B_Nm1 real(kind=dp), public, DIMENSION(size(A, 1), size(A, 1)) :: AB logical, public :: do_check = .TRUE. integer, public :: N integer, public :: k Source Code SUBROUTINE Faddeev_Leverrier ( A , c , Ainv , success , check ) INTEGER , PARAMETER :: dp = kind ( 1.0d0 ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: c REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), OPTIONAL , INTENT ( OUT ) :: Ainv LOGICAL , OPTIONAL , INTENT ( OUT ) :: success REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: Bk , I , B_Nm1 , AB LOGICAL :: do_check = . TRUE . INTEGER :: N , k N = size ( A , 1 ) IF ( present ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is square and size of c is correct\" IF ( size ( A , 2 ) /= N . OR . size ( c ) < N + 1 ) THEN PRINT * , \"Error : Matrix A must be square and size of c must be at least N+1\" STOP END IF END IF ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I DO k = 2 , N AB = matmul ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / REAL ( k , dp ) Bk = AB + c ( k + 1 ) * I IF ( k == N - 1 . AND . present ( Ainv )) B_Nm1 = - Bk END DO IF ( present ( Ainv ) . AND . present ( success )) THEN IF ( abs ( c ( N + 1 )) < 1.0e-12_dp ) THEN success = . FALSE . Ainv = 0.0_dp ELSE success = . TRUE . Ainv = B_Nm1 / c ( N + 1 ) END IF ELSE IF ( present ( Ainv )) THEN IF ( abs ( c ( N + 1 )) < 1.0e-12_dp ) THEN Ainv = 0.0_dp ELSE Ainv = B_Nm1 / c ( N + 1 ) END IF END IF END SUBROUTINE Faddeev_Leverrier","tags":"","url":"proc\\faddeev_leverrier.html"},{"title":"center_with_fill – NAFPack","text":"public  function center_with_fill(text, width, fill_char) result(centered_text) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text integer, intent(in) :: width character(len=1), intent(in), optional :: fill_char Return Value character(kind=ucs4, len=width) Source Code FUNCTION center_with_fill ( text , width , fill_char ) RESULT ( centered_text ) CHARACTER ( LEN =* ), INTENT ( IN ) :: text INTEGER , INTENT ( IN ) :: width CHARACTER ( LEN = 1 ), OPTIONAL , INTENT ( IN ) :: fill_char CHARACTER ( LEN = 1 ) :: fill CHARACTER ( KIND = ucs4 , LEN = width ) :: centered_text INTEGER :: text_len , padding , left_padding , right_padding , i IF ( present ( fill_char )) THEN fill = fill_char ELSE fill = \" \" END IF text_len = len_trim ( text ) IF ( text_len >= width ) THEN centered_text = text ( 1 : width ) RETURN END IF ! Calculate the total padding required padding = width - text_len IF ( trim ( text ) == \"\" ) THEN left_padding = padding / 2 right_padding = padding - left_padding - mod ( padding , 2 ) ELSE text_len = text_len + 1 left_padding = padding / 2 - 1 right_padding = padding - left_padding - mod ( padding , 2 ) END IF ! Initialize the result centered_text = repeat ( ' ' , width ) ! Fill with fill on the left DO i = 1 , left_padding centered_text ( i : i ) = fill END DO ! Place the text in the center IF ( trim ( text ) == \"\" ) THEN centered_text ( left_padding + 1 : left_padding + text_len ) = trim ( text ) ELSE centered_text ( left_padding + 1 : left_padding + text_len ) = \" \" // trim ( text ) // \" \" END IF ! Fill with fill on the right DO i = right_padding + text_len , width centered_text ( i : i ) = fill END DO END FUNCTION center_with_fill","tags":"","url":"proc\\center_with_fill.html"},{"title":"log_field – NAFPack","text":"public interface log_field Module Procedures private  subroutine log_field_str(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(len=*), intent(in) :: VALUE private  subroutine log_field_real(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label real(kind=dp), intent(in) :: VALUE private  subroutine log_field_int(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label integer, intent(in) :: VALUE private  subroutine log_field_ucs4(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(kind=ucs4, len=*), intent(in) :: VALUE private  subroutine log_field_logical(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label logical, intent(in) :: VALUE","tags":"","url":"interface\\log_field.html"},{"title":"NAFPack_Eigen – NAFPack","text":"Module for eigenvalue and eigenvector computations in NAFPack Uses NAFPack_matricielle NAFPack_constant NAFPack_matrix_decomposition module~~nafpack_eigen~~UsesGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_constant NAFPack_constant module~nafpack_eigen->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_eigen~~UsedByGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Eigen (A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"module\\nafpack_eigen.html"},{"title":"NAFPack_config – NAFPack","text":"Module for advanced configuration and tuning parameters Uses NAFPack_constant module~~nafpack_config~~UsesGraph module~nafpack_config NAFPack_config module~nafpack_constant NAFPack_constant module~nafpack_config->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: config_type Configuration type for NAFPack Components Type Visibility Attributes Name Initial real(kind=dp), public :: pivot_tolerance = 1.0e-14_dp real(kind=dp), public :: convergence_tolerance = 1.0e-12_dp real(kind=dp), public :: residual_tolerance = 1.0e-10_dp integer, public :: max_iterations = 10000 integer, public :: block_size = 64 logical, public :: use_openmp = .TRUE. logical, public :: use_blas = .TRUE. logical, public :: preallocate_workspace = .TRUE. integer, public :: workspace_size = 1000 logical, public :: enable_debug = .FALSE. logical, public :: enable_timing = .FALSE. character(len=100), public :: log_file = \"nafpack.log\" character(len=50), public :: default_direct_method = \"A_LU\" character(len=50), public :: default_iterative_method = \"Gauss_Seidel\" character(len=50), public :: default_preconditioner = \"ILU\" Functions public  function get_default_config () result(config) Get default configuration Arguments None Return Value type( config_type ) Subroutines public  subroutine validate_config (config, is_valid, error_msg) Validate configuration parameters Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: config logical, intent(out) :: is_valid character(len=*), intent(out) :: error_msg","tags":"","url":"module\\nafpack_config.html"},{"title":"NAFPack_memory_monitor – NAFPack","text":"Uses iso_c_binding module~~nafpack_memory_monitor~~UsesGraph module~nafpack_memory_monitor NAFPack_memory_monitor iso_c_binding iso_c_binding module~nafpack_memory_monitor->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_memory_monitor~~UsedByGraph module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_memory_kb () result(memory_kb) Arguments None Return Value integer","tags":"","url":"module\\nafpack_memory_monitor.html"},{"title":"NAFPack_Iterative_types – NAFPack","text":"Uses NAFPack_constant module~~nafpack_iterative_types~~UsesGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_constant NAFPack_constant module~nafpack_iterative_types->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_types~~UsedByGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_preconditioners->module~nafpack_iterative_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeIterative ), public, parameter :: METHOD_ITERATIVE_NONE = MethodTypeIterative(0, \"None\") type( MethodTypeIterative ), public, parameter :: METHOD_Jacobi = MethodTypeIterative(1, \"Jacobi\") type( MethodTypeIterative ), public, parameter :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, \"Gauss-Seidel\") type( MethodTypeIterative ), public, parameter :: METHOD_SOR = MethodTypeIterative(3, \"Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_JOR = MethodTypeIterative(4, \"Jacobi Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ILU = MethodTypeIterative(5, \"Strongly Implicit Procedure\", \"ILU\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ICF = MethodTypeIterative(6, \"Strongly Implicit Procedure\", \"ICF\") type( MethodTypeIterative ), public, parameter :: METHOD_SSOR = MethodTypeIterative(7, \"Symmetric Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_RICHARDSON = MethodTypeIterative(8, \"Richardson\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, \"Conjugate Gradient\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, \"Conjugate Residual\") type( MethodTypeIterative ), public, parameter :: METHOD_CGNE = MethodTypeIterative(11, \"Conjugate Gradient on Normal Equations\") type( MethodTypeIterative ), public, parameter :: METHOD_CGNR = MethodTypeIterative(12, \"Conjugate Gradient on Normal Residual\") type( MethodTypeIterative ), public, parameter :: METHOD_GMRES = MethodTypeIterative(13, \"Generalized Minimal Residual\") type( Norm_used ), public, parameter :: NORM_2 = Norm_used(1, \"Norm L2 or Euclidean\") type( Norm_used ), public, parameter :: NORM_1 = Norm_used(2, \"Norm L1 or Manhattan\") type( Norm_used ), public, parameter :: NORM_INF = Norm_used(3, \"Norm LInfini or Maximum\") type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_NONE = relaxation_factor_used(0, NONE) type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used(1, omega) type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used(2, alpha) Derived Types type, public :: MethodTypeIterative Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name character(len=64), public :: name2 = \"\" type, public :: IterativeMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_diag_dom = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_symetric = .FALSE. type, public :: Norm_used Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: relaxation_factor_used Components Type Visibility Attributes Name Initial integer, public :: id character(kind=ucs4, len=64), public :: name","tags":"","url":"module\\nafpack_iterative_types.html"},{"title":"NAFPack_matrix_decomposition – NAFPack","text":"Module for matrix decomposition methods This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. Uses NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_decomposition~~UsesGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_decomposition~~UsedByGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_matrix_properties->module~nafpack_eigen Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function forward (L, b) result(y) forward algorithm,\nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(size(L, 1)) public  function backward (U, y) result(x) backward algorithm,\nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(size(U, 1)) Subroutines public  subroutine LU_decomposition (A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U public  subroutine LDU_decomposition (A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U public  subroutine ILU_decomposition (A, L, U, level) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: U integer, intent(in), optional :: level public  subroutine Cholesky_decomposition (A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L public  subroutine LDL_Cholesky_decomposition (A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: D public  subroutine Incomplete_Cholesky_decomposition (A, L, level) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: L integer, intent(in), optional :: level public  subroutine QR_decomposition (A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R public  subroutine QR_Householder_decomposition (A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R public  subroutine QR_Givens_decomposition (A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Classical_decomposition (A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Modified_decomposition (A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: R public  subroutine pivot_partial (A, P) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: P public  subroutine pivot_total (A, P, Q) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: P real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 1)) :: Q","tags":"","url":"module\\nafpack_matrix_decomposition.html"},{"title":"NAFPack_Preconditioners – NAFPack","text":"Uses NAFPack_Iterative_types NAFPack_constant NAFPack_matricielle NAFPack_matrix_decomposition module~~nafpack_preconditioners~~UsesGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_constant NAFPack_constant module~nafpack_preconditioners->module~nafpack_constant module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_matricielle NAFPack_matricielle module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_types->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_preconditioners~~UsedByGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_NONE = MethodPreconditioner(0, \"None\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, \"Jacobi\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_GS = MethodPreconditioner(2, \"Gauss-Seidel\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SOR = MethodPreconditioner(3, \"Successive Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JOR = MethodPreconditioner(4, \"Jacobi Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ILU = MethodPreconditioner(5, \"ILU\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ICF = MethodPreconditioner(6, \"ICF\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SSOR = MethodPreconditioner(7, \"SSOR\") type( Fill_level_used ), public, parameter :: FILL_LEVEL_NONE = Fill_level_used(-1, \"None\", -huge(1)) type( Fill_level_used ), public, parameter :: FILL_LEVEL_0 = Fill_level_used(0, \"Level 0\", 0) type( Fill_level_used ), public, parameter :: FILL_LEVEL_1 = Fill_level_used(1, \"Level 1\", 1) type( Fill_level_used ), public, parameter :: FILL_LEVEL_2 = Fill_level_used(2, \"Level 2\", 2) type( Fill_level_used ), public, parameter :: FILL_LEVEL_3 = Fill_level_used(3, \"Level 3\", 3) type( Fill_level_used ), public :: FILL_LEVEL_N = Fill_level_used(3, \"Level N\", 0) Derived Types type, public :: MethodPreconditioner Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: Fill_level_used Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name integer, public :: VALUE Functions public  function Calculate_Jacobi_preconditioner (A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) public  function Calculate_Gauss_Seidel_preconditioner (A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) public  function Calculate_SOR_preconditioner (A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) public  function Calculate_JOR_preconditioner (A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) public  function Calculate_ICF_preconditioner (A, omega, alpha, fill_level) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2)) Subroutines public  subroutine Calculate_ILU_preconditioner (A, L, U, omega, alpha, fill_level) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level public  subroutine Calculate_SSOR_preconditioner (A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(size(A, 1), size(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha","tags":"","url":"module\\nafpack_preconditioners.html"},{"title":"NAFPack_Krylov_method – NAFPack","text":"Uses NAFPack_constant NAFPack_matricielle module~~nafpack_krylov_method~~UsesGraph module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_constant NAFPack_constant module~nafpack_krylov_method->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_krylov_method->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_krylov_method.html"},{"title":"NAFPack_matrix_properties – NAFPack","text":"Uses NAFPack_Eigen NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_properties~~UsesGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_constant NAFPack_constant module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_properties~~UsedByGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function is_square_matrix (A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_symmetric (A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_orthogonal (A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_SPD (A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical public  function is_tridiagonal (A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_diagonally_dominant (A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_non_zero_diagonal (A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical","tags":"","url":"module\\nafpack_matrix_properties.html"},{"title":"NAFPack_linalg – NAFPack","text":"Uses NAFPack_Iterative_types NAFPack_Direct_method NAFPack_Iterative_methods NAFPack_Direct_types module~~nafpack_linalg~~UsesGraph module~nafpack_linalg NAFPack_linalg module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg->module~nafpack_direct_method module~nafpack_direct_types NAFPack_Direct_types module~nafpack_linalg->module~nafpack_direct_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_matricielle NAFPack_matricielle module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle iso_c_binding iso_c_binding module~nafpack_memory_monitor->iso_c_binding module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: linalg Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative","tags":"","url":"module\\nafpack_linalg.html"},{"title":"NAFPack_matrix_market – NAFPack","text":"Uses NAFPack_constant module~~nafpack_matrix_market~~UsesGraph module~nafpack_matrix_market NAFPack_matrix_market module~nafpack_constant NAFPack_constant module~nafpack_matrix_market->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine readMatrixMarket (filename, A) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), DIMENSION(:, :), ALLOCATABLE :: A","tags":"","url":"module\\nafpack_matrix_market.html"},{"title":"NAFPack_Direct_types – NAFPack","text":"Used by module~~nafpack_direct_types~~UsedByGraph module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_types module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeDirect ), public, parameter :: METHOD_DIRECT_NONE = MethodTypeDirect(0, \"None\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss = MethodTypeDirect(1, \"Gauss\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss_JORDAN = MethodTypeDirect(2, \"Gauss-Jordan\") type( MethodTypeDirect ), public, parameter :: METHOD_LU = MethodTypeDirect(3, \"LU\") type( MethodTypeDirect ), public, parameter :: METHOD_LDU = MethodTypeDirect(4, \"LDU\") type( MethodTypeDirect ), public, parameter :: METHOD_CHOLESKY = MethodTypeDirect(5, \"Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_LDL_Cholesky = MethodTypeDirect(6, \"LDL-Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_QR = MethodTypeDirect(7, \"QR\") type( MethodTypeDirect ), public, parameter :: METHOD_TDMA = MethodTypeDirect(8, \"TDMA\") type( MethodTypeDirect ), public, parameter :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect(9, \"Faddeev-Leverrier\") type( MethodQR ), public, parameter :: QR_HOUSEHOLDER = MethodQR(1, \"Householder\") type( MethodQR ), public, parameter :: QR_GIVENS = MethodQR(2, \"Givens\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT = MethodQR(3, \"Gram-Schmidt\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT_Modified = MethodQR(4, \"Gram_Schmidt_Modified\") Derived Types type, public :: MethodTypeDirect Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: MethodQR Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: DirectMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_non_zero_diag = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_tridiagonal = .FALSE. logical, public :: needs_symmetric = .FALSE.","tags":"","url":"module\\nafpack_direct_types.html"},{"title":"NAFPack_matricielle – NAFPack","text":"Module for Tensor operations in NAFPack Uses NAFPack_constant module~~nafpack_matricielle~~UsesGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_constant NAFPack_constant module~nafpack_matricielle->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matricielle~~UsedByGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_krylov_method->module~nafpack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function dot (a, b) result(RESULT) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) public  function cross (a, b) result(RESULT) function that calculates the cross product between two real 3-dimensional vectors and 1 Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) public  function norm_2_real (a) result(RESULT) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function norm_2_complex (a) result(RESULT) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function normalise (a) result(RESULT) function that normalises a real vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(size(a)) public  function normalise_complexe (a) result(RESULT) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(size(a)) public  function Trace (A) result(RESULT) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp) public  function Diagonally_Dominant_Matrix (A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function Identity_n (N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) public  function Diag (A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(size(A, 1)) public  function Make_Tridiagonal (d_minus, d, d_plus) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: d_minus real(kind=dp), intent(in), DIMENSION(:) :: d real(kind=dp), intent(in), DIMENSION(:) :: d_plus Return Value real(kind=dp), DIMENSION(size(d, 1), size(d, 1)) public  function rotation_matrix (A, rotation) result(G) Function to create a rotation matrix Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(size(A, 1), size(A, 2))","tags":"","url":"module\\nafpack_matricielle.html"},{"title":"NAFPack_fft – NAFPack","text":"Module for Fourier Transform This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals.\nIt supports both forward and inverse transforms.\nIt allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. Uses FFTW3 NAFPack_constant module~~nafpack_fft~~UsesGraph module~nafpack_fft NAFPack_fft FFTW3 FFTW3 module~nafpack_fft->FFTW3 module~nafpack_constant NAFPack_constant module~nafpack_fft->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function FFT_1D (signal, method, threads) result(RESULT) Perform a 1D Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal)) public  function IFFT_1D (signal, method, threads) result(RESULT) Perform a 1D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal)) public  function FFT_2D (signal, method, threads) result(RESULT) Perform a 2D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2)) public  function IFFT_2D (signal, method, threads) result(RESULT) Perform a 2D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2)) public  function FFT_3D (signal, method, threads) result(RESULT) Perform a 3D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3)) public  function IFFT_3D (signal, method, threads) result(RESULT) Perform a 3D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(size(signal, 1), size(signal, 2), size(signal, 3))","tags":"","url":"module\\nafpack_fft.html"},{"title":"NAFPack_Iterative_methods – NAFPack","text":"Module for iterative methods in NAFPack Uses NAFPack_Preconditioners NAFPack_Iterative_Params NAFPack_constant NAFPack_matricielle NAFPack_Logger_mod NAFPack_Iterative_types NAFPack_memory_monitor NAFPack_matrix_properties NAFPack_matrix_decomposition module~~nafpack_iterative_methods~~UsesGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_constant NAFPack_constant module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_matricielle NAFPack_matricielle module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen iso_c_binding iso_c_binding module~nafpack_memory_monitor->iso_c_binding module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_methods~~UsedByGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: solve => IterativeMethod_solve procedure, public :: Init_IterativeParams procedure, public :: Dealocate_IterativeParams procedure, public :: test_matrix","tags":"","url":"module\\nafpack_iterative_methods.html"},{"title":"NAFPack_Iterative_Params – NAFPack","text":"Uses NAFPack_Iterative_types NAFPack_constant NAFPack_Preconditioners NAFPack_matrix_decomposition module~~nafpack_iterative_params~~UsesGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_constant NAFPack_constant module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_params->module~nafpack_preconditioners iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_types->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_params~~UsedByGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeParams Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: x_init real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: L real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: U real(kind=dp), public, DIMENSION(:, :), ALLOCATABLE :: D real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: p real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: residual real(kind=dp), public :: norm_residual real(kind=dp), public :: norm_initial_residual = 1.d0 real(kind=dp), public :: tol = 1.0d-12 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: omega = 1.d0 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 type( Fill_level_used ), public :: fill_level = FILL_LEVEL_NONE logical, public :: is_stationary = .TRUE. logical, public :: strict_mode = .FALSE. real(kind=dp), public :: old_dot_product = 0.d0 type( Norm_used ), public :: norm = NORM_2 procedure( ApplyPreconditioner ), public, PASS(params), POINTER :: precond Type-Bound Procedures procedure, public :: norm_function Functions public  function ApplyPreconditioner (params, method, x) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method real(kind=dp), intent(in), DIMENSION(:) :: x Return Value real(kind=dp), DIMENSION(size(params%x_init))","tags":"","url":"module\\nafpack_iterative_params.html"},{"title":"NAFPack_meshgrid – NAFPack","text":"Module for creating a meshgrid from two vectors This module provides a subroutine to create a meshgrid. Uses NAFPack_constant module~~nafpack_meshgrid~~UsesGraph module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_constant NAFPack_constant module~nafpack_meshgrid->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine meshgrid (x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(size(y_vector), size(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(size(y_vector), size(x_vector)) :: Y","tags":"","url":"module\\nafpack_meshgrid.html"},{"title":"NAFPack_Direct_method – NAFPack","text":"Module for direct methods in NAFPack Uses NAFPack_constant NAFPack_matrix_tools NAFPack_Direct_types NAFPack_matrix_properties NAFPack_matrix_decomposition module~~nafpack_direct_method~~UsesGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_direct_method~~UsedByGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: DirectMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: set_qr_method procedure, public :: solve => DirectMethod_solve procedure, public :: test_matrix","tags":"","url":"module\\nafpack_direct_method.html"},{"title":"NAFPack_constant – NAFPack","text":"Module for defining constants used in NAFPack This module includes mathematical constants, colors for terminal output,\nand other parameters that are used throughout the NAFPack library. Uses iso_fortran_env module~~nafpack_constant~~UsesGraph module~nafpack_constant NAFPack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_constant~~UsedByGraph module~nafpack_constant NAFPack_constant module~nafpack_config NAFPack_config module~nafpack_config->module~nafpack_constant module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_constant module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_fft NAFPack_fft module~nafpack_fft->module~nafpack_constant module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_krylov_method->module~nafpack_constant module~nafpack_krylov_method->module~nafpack_matricielle module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_market NAFPack_matrix_market module~nafpack_matrix_market->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = acos(-1.d0) constant complex(kind=dp), public, parameter :: im = (0.d0, 1.d0) Imaginary unit real(kind=dp), public, parameter :: epsi = 1.d-12 Small value real(kind=dp), public, parameter :: epsi_test = 1.d-6 Small value integer, public, parameter :: int_inf = huge(1) integer, public, parameter :: kmax = 10000 Maximum number of iterations for iterative methods character(len=*), public, parameter :: status_len = repeat(\" \", 15) len of status messages integer, public, parameter :: ascii = selected_char_kind('ascii') integer, public, parameter :: ucs4 = selected_char_kind('ISO_10646') character(len=10), public :: red_color = char(27)//\"[31m\" red colors for terminal output character(kind=ucs4, len=10), public, parameter :: red_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[31m\" character(len=10), public :: green_color = char(27)//\"[32m\" green colors for terminal output character(kind=ucs4, len=10), public, parameter :: green_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[32m\" character(len=10), public :: yellow_color = char(27)//\"[33m\" yellow colors for terminal output character(kind=ucs4, len=10), public, parameter :: yellow_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[33m\" character(len=10), public :: blue_color = char(27)//\"[34m\" blue colors for terminal output character(kind=ucs4, len=10), public, parameter :: blue_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[34m\" character(len=10), public :: purple_color = char(27)//\"[35m\" purple colors for terminal output character(kind=ucs4, len=10), public, parameter :: purple_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[35m\" character(len=10), public :: cyan_color = char(27)//\"[36m\" cyan colors for terminal output character(kind=ucs4, len=10), public, parameter :: cyan_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[36m\" character(len=10), public :: white_color = char(27)//\"[37m\" white colors for terminal output character(kind=ucs4, len=10), public, parameter :: white_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[37m\" character(len=10), public :: reset_color = char(27)//\"[0m\" reset colors for terminal output character(kind=ucs4, len=10), public, parameter :: reset_color_ucs4 = char(27, KIND=ucs4)//ucs4_\"[0m\" integer, public, parameter :: NAF_SUCCESS = 0 Error codes for better error handling integer, public, parameter :: NAF_ERROR_DIMENSION = 1 integer, public, parameter :: NAF_ERROR_SINGULAR = 2 integer, public, parameter :: NAF_ERROR_CONVERGENCE = 3 integer, public, parameter :: NAF_ERROR_MEMORY = 4 integer, public, parameter :: NAF_ERROR_INVALID_METHOD = 5 real(kind=dp), public, parameter :: TOL_PIVOT = 1.0e-14_dp Improved tolerance parameters real(kind=dp), public, parameter :: TOL_CONVERGENCE = 1.0e-12_dp","tags":"","url":"module\\nafpack_constant.html"},{"title":"NAFPack_matrix_tools – NAFPack","text":"Uses NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_tools~~UsesGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_constant NAFPack_constant module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_tools->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_tools~~UsedByGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Faddeev_Leverrier (A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: c real(kind=dp), intent(out), optional, DIMENSION(size(A, 1), size(A, 1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check","tags":"","url":"module\\nafpack_matrix_tools.html"},{"title":"NAFPack_Logger_mod – NAFPack","text":"Uses NAFPack_constant module~~nafpack_logger_mod~~UsesGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_constant NAFPack_constant module~nafpack_logger_mod->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_logger_mod~~UsedByGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( Format_file ), public, parameter :: FORMAT_FILE_BIN = Format_file(0, \"binary\", \"Binary file format\") type( Format_file ), public, parameter :: FORMAT_FILE_TXT = Format_file(1, \"txt\", \"Text file format\") type( Format_file ), public, parameter :: FORMAT_FILE_CSV = Format_file(2, \"csv\", \"Comma-separated values format\") type( Format_file ), public, parameter :: FORMAT_FILE_LOG = Format_file(3, \"log\", \"Log file format\") type( Format_file ), public, parameter :: FORMAT_FILE_TSV = Format_file(4, \"tsv\", \"Tab-separated values format\") type( Format_file ), public, parameter :: FORMAT_FILE_JSON = Format_file(5, \"json\", \"JSON file format\") type( Format_file ), public, parameter :: FORMAT_FILE_XML = Format_file(6, \"xml\", \"XML file format\") type( Format_file ), public, parameter :: FORMAT_FILE_YAML = Format_file(7, \"yaml\", \"YAML file format\") Interfaces public        interface log_field private  subroutine log_field_str(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(len=*), intent(in) :: VALUE private  subroutine log_field_real(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label real(kind=dp), intent(in) :: VALUE private  subroutine log_field_int(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label integer, intent(in) :: VALUE private  subroutine log_field_ucs4(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(kind=ucs4, len=*), intent(in) :: VALUE private  subroutine log_field_logical(verbose, label, VALUE) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label logical, intent(in) :: VALUE Derived Types type, public :: Format_file Components Type Visibility Attributes Name Initial integer, public :: id = 1 character(len=10), public :: format_name = \"txt\" character(len=100), public :: format_description = \"Text file format\" type, public :: Logger Components Type Visibility Attributes Name Initial integer, public :: verbosity_level = 1 logical, public :: to_terminal = .TRUE. logical, public :: to_file = .FALSE. integer, public :: frequency = 10 character(len=100), public :: filename = \"Log\" type( Format_file ), public :: file_format = FORMAT_FILE_LOG integer, public :: file_unit = 99 character(len=100), public :: message = \"Default log message\" logical, public :: show_Logger_initialization = .TRUE. logical, public :: show_matrix_test = .TRUE. logical, public :: show_info_solver = .TRUE. logical, public :: show_iteration = .TRUE. logical, public :: show_final = .TRUE. Type-Bound Procedures procedure, public :: init => init_logger procedure, public :: log_info procedure, public :: log_detail procedure, public :: log_warning procedure, public :: log_error procedure, public :: log_time procedure, public :: WRITE => write_output procedure, public :: CLOSE => close_logger Functions public  function center_with_fill (text, width, fill_char) result(centered_text) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text integer, intent(in) :: width character(len=1), intent(in), optional :: fill_char Return Value character(kind=ucs4, len=width)","tags":"","url":"module\\nafpack_logger_mod.html"},{"title":"NAFPack_Eigen.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_eigen.f90~~EfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_eigen.f90~~AfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for eigenvalue and eigenvector computations in NAFPack MODULE NAFPack_Eigen USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: Eigen CONTAINS !================== Eigen =============================================================== !> Computes the eigenvalues and eigenvectors of a matrix A !>  A * \\vec{v} = \\lambda * \\vec{v}  !> with **A** a square matrix, **λ** the eigenvalue, and **v** the eigenvector. !> This subroutine allows you to choose the method for computing eigenvalues and eigenvectors: !> !> - Power iteration !> - QR algorithm (with or without shift) !> The default method is Power iteration. SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( present ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = size ( A , 1 ) IF ( size ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( size ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( present ( vp ) . AND . ( size ( vp , 1 ) /= N . OR . size ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( present ( vp )) vp = vp_tmp ELSE IF ( index ( method , \"QR\" ) == 1 ) THEN IF ( present ( vp )) vp = 0 IF ( present ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = index ( trim ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == len_trim ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen !> QR algorithm for computing eigenvalues !> !> This subroutine implements the QR algorithm for computing the eigenvalues of a matrix. SUBROUTINE Eigen_QR ( A , lambda , method , N , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN =* ), INTENT ( IN ) :: method INTEGER , INTENT ( IN ) :: N , k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( size ( A , 1 )) :: lambda_old REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: A_tmp , Q , R REAL ( dp ) :: diff INTEGER :: i , j A_tmp = A DO i = 1 , k lambda_old = lambda CALL QR_decomposition ( A_tmp , method , Q , R ) A_tmp = matmul ( R , Q ) diff = abs ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR !> Shifted QR algorithm for computing eigenvalues !> !> This subroutine implements the shifted QR algorithm for computing the eigenvalues of a matrix. !> The shift is chosen as the last diagonal element of the matrix. SUBROUTINE Eigen_QR_Shifted ( A , lambda , method , N , k ) INTEGER , INTENT ( IN ) :: N , k CHARACTER ( LEN =* ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( N ), INTENT ( OUT ) :: lambda INTEGER :: i , j REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: A_tmp , Q , R , Id REAL ( dp ) :: shift , diff A_tmp = A Id = Identity_n ( N ) DO i = 1 , k !choice of shift: last diagonal element shift = A_tmp ( N , N ) ! Gap : A - µI A_tmp = A_tmp - shift * Id ! QR Decomposition : A - µI = Q * R CALL QR_decomposition ( A_tmp , method , Q , R ) ! A = RQ + µI A_tmp = matmul ( R , Q ) + shift * Id diff = abs ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR_Shifted !> Power iteration method for computing the dominant eigenvalue and eigenvector !> !> This subroutine implements the power iteration method for finding the dominant eigenvalue and eigenvector of a matrix. !> It iteratively computes the eigenvector and eigenvalue until convergence SUBROUTINE Power_iteration ( A , lambda , vp , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: vp REAL ( dp ), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( size ( A , 1 )) :: u , vp_tmp , r INTEGER :: i , N N = size ( A , 1 ) CALL random_number ( u ) u = normalise ( u ) vp_tmp = matmul ( A , u ) lambda = dot_product ( vp_tmp , u ) r = vp_tmp - lambda * u DO i = 1 , k u = normalise ( vp_tmp ) vp_tmp = matmul ( A , u ) lambda = dot_product ( vp_tmp , u ) IF ( norm2 ( r ) <= epsi ) EXIT r = vp_tmp - lambda * u IF ( i == k ) THEN PRINT * , \"WARNING :: non-convergence of the power iteration method\" END IF END DO vp = u END SUBROUTINE Power_iteration !> Deflation method for removing the influence of an eigenvalue and eigenvector !> !> This function performs deflation on a matrix A by removing the influence of an eigenvalue and its corresponding eigenvector. FUNCTION deflation ( A , lambda , vp , k ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: vp REAL ( dp ), INTENT ( IN ) :: lambda INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: RESULT REAL ( dp ), DIMENSION ( size ( A , 1 )) :: wp INTEGER :: i , j , N REAL ( dp ) :: lambda1 N = size ( A , 1 ) RESULT = A CALL Power_iteration ( transpose ( A ), lambda1 , wp , k ) DO i = 1 , N DO j = 1 , N RESULT ( i , j ) = RESULT ( i , j ) - ( lambda * vp ( i ) * wp ( j )) / dot_product ( vp , wp ) END DO END DO END FUNCTION deflation END MODULE NAFPack_Eigen","tags":"","url":"sourcefile\\nafpack_eigen.f90.html"},{"title":"NAFPack_config.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_config.f90~~EfferentGraph sourcefile~nafpack_config.f90 NAFPack_config.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_config.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for advanced configuration and tuning parameters MODULE NAFPack_config USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: config_type , get_default_config , validate_config !> Configuration type for NAFPack TYPE :: config_type ! Numerical tolerances REAL ( dp ) :: pivot_tolerance = 1.0e-14_dp REAL ( dp ) :: convergence_tolerance = 1.0e-12_dp REAL ( dp ) :: residual_tolerance = 1.0e-10_dp ! Performance settings INTEGER :: max_iterations = 10000 INTEGER :: block_size = 64 LOGICAL :: use_openmp = . TRUE . LOGICAL :: use_blas = . TRUE . ! Memory management LOGICAL :: preallocate_workspace = . TRUE . INTEGER :: workspace_size = 1000 ! Debugging and logging LOGICAL :: enable_debug = . FALSE . LOGICAL :: enable_timing = . FALSE . CHARACTER ( LEN = 100 ) :: log_file = \"nafpack.log\" ! Method selection CHARACTER ( LEN = 50 ) :: default_direct_method = \"A_LU\" CHARACTER ( LEN = 50 ) :: default_iterative_method = \"Gauss_Seidel\" CHARACTER ( LEN = 50 ) :: default_preconditioner = \"ILU\" END TYPE config_type CONTAINS !> Get default configuration FUNCTION get_default_config () RESULT ( config ) TYPE ( config_type ) :: config ! Default values are already set in the type definition ! No need to explicitly set them as they're defined in the type config = config_type ( pivot_tolerance = TOL_PIVOT , & convergence_tolerance = TOL_CONVERGENCE , & residual_tolerance = epsi , & max_iterations = kmax , & block_size = 64 , & use_openmp = . TRUE ., & use_blas = . TRUE ., & preallocate_workspace = . TRUE ., & workspace_size = 1000 , & enable_debug = . FALSE ., & enable_timing = . FALSE ., & log_file = \"nafpack.log\" , & default_direct_method = \"A_LU\" , & default_iterative_method = \"Gauss_Seidel\" , & default_preconditioner = \"ILU\" ) END FUNCTION get_default_config !> Validate configuration parameters SUBROUTINE validate_config ( config , is_valid , error_msg ) TYPE ( config_type ), INTENT ( IN ) :: config LOGICAL , INTENT ( OUT ) :: is_valid CHARACTER ( LEN =* ), INTENT ( OUT ) :: error_msg is_valid = . TRUE . error_msg = \"\" ! Check tolerances IF ( config % pivot_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Pivot tolerance must be positive\" RETURN END IF IF ( config % convergence_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Convergence tolerance must be positive\" RETURN END IF ! Check iteration limits IF ( config % max_iterations <= 0 ) THEN is_valid = . FALSE . error_msg = \"Maximum iterations must be positive\" RETURN END IF ! Check block size IF ( config % block_size <= 0 ) THEN is_valid = . FALSE . error_msg = \"Block size must be positive\" RETURN END IF END SUBROUTINE validate_config END MODULE NAFPack_config","tags":"","url":"sourcefile\\nafpack_config.f90.html"},{"title":"NAFPack_memory_monitor.F90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_memory_monitor.f90~~AfferentGraph sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.F90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_memory_monitor USE iso_c_binding IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: get_memory_kb #ifdef _WIN32 INTERFACE SUBROUTINE get_windows_memory ( mem_kb ) BIND ( C , name = \"get_windows_memory\" ) IMPORT c_int INTEGER ( c_int ), INTENT ( OUT ) :: mem_kb END SUBROUTINE END INTERFACE #else INTERFACE SUBROUTINE get_linux_memory ( mem_kb ) BIND ( C , NAME = \"get_linux_memory\" ) IMPORT c_int INTEGER ( c_int ), INTENT ( OUT ) :: mem_kb END SUBROUTINE END INTERFACE #endif CONTAINS FUNCTION get_memory_kb () RESULT ( memory_kb ) INTEGER :: memory_kb memory_kb = 0 #ifdef _WIN32 CALL get_windows_memory ( memory_kb ) #else CALL get_linux_memory ( memory_kb ) #endif END FUNCTION get_memory_kb END MODULE NAFPack_memory_monitor","tags":"","url":"sourcefile\\nafpack_memory_monitor.f90.html"},{"title":"NAFPack_Iterative_types.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_types.f90~~EfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_types.f90~~AfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Iterative_types USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: MethodTypeIterative PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: METHOD_CGNE , METHOD_CGNR PUBLIC :: METHOD_GMRES PUBLIC :: IterativeMethodRequirements PUBLIC :: Norm_used PUBLIC :: NORM_2 , NORM_1 , NORM_INF PUBLIC :: relaxation_factor_used PUBLIC :: RELAXATION_FACTOR_NONE , RELAXATION_FACTOR_OMEGA , RELAXATION_FACTOR_ALPHA INTEGER , PARAMETER :: CK = selected_char_kind ( 'ISO_10646' ) CHARACTER ( KIND = ucs4 , LEN = 4 ), PARAMETER :: NONE = \"None\" CHARACTER ( KIND = ucs4 , LEN = 1 ), PARAMETER :: omega = char ( int ( z '03C9' ), ucs4 ) CHARACTER ( KIND = ucs4 , LEN = 1 ), PARAMETER :: alpha = char ( int ( z '03B1' ), ucs4 ) TYPE :: MethodTypeIterative INTEGER :: id CHARACTER ( LEN = 64 ) :: name CHARACTER ( LEN = 64 ) :: name2 = \"\" END TYPE MethodTypeIterative TYPE :: IterativeMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_diag_dom = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_symetric = . FALSE . END TYPE IterativeMethodRequirements TYPE :: Norm_used INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE Norm_used TYPE :: relaxation_factor_used INTEGER :: id CHARACTER ( KIND = ucs4 , LEN = 64 ) :: name END TYPE relaxation_factor_used TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_ITERATIVE_NONE = MethodTypeIterative ( 0 , \"None\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_Jacobi = MethodTypeIterative ( 1 , \"Jacobi\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_GAUSS_SEIDEL = MethodTypeIterative ( 2 , \"Gauss-Seidel\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SOR = MethodTypeIterative ( 3 , \"Successive Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_JOR = MethodTypeIterative ( 4 , \"Jacobi Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative ( 5 , \"Strongly Implicit Procedure\" , \"ILU\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative ( 6 , \"Strongly Implicit Procedure\" , \"ICF\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SSOR = MethodTypeIterative ( 7 , \"Symmetric Successive Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative ( 8 , \"Richardson\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative ( 9 , \"Conjugate Gradient\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative ( 10 , \"Conjugate Residual\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CGNE = MethodTypeIterative ( 11 , \"Conjugate Gradient on Normal Equations\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CGNR = MethodTypeIterative ( 12 , \"Conjugate Gradient on Normal Residual\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_GMRES = MethodTypeIterative ( 13 , \"Generalized Minimal Residual\" ) TYPE ( Norm_used ), PARAMETER :: NORM_2 = Norm_used ( 1 , \"Norm L2 or Euclidean\" ) TYPE ( Norm_used ), PARAMETER :: NORM_1 = Norm_used ( 2 , \"Norm L1 or Manhattan\" ) TYPE ( Norm_used ), PARAMETER :: NORM_INF = Norm_used ( 3 , \"Norm LInfini or Maximum\" ) TYPE ( relaxation_factor_used ), PARAMETER :: RELAXATION_FACTOR_NONE = relaxation_factor_used ( 0 , NONE ) TYPE ( relaxation_factor_used ), PARAMETER :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used ( 1 , omega ) TYPE ( relaxation_factor_used ), PARAMETER :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used ( 2 , alpha ) END MODULE NAFPack_Iterative_types","tags":"","url":"sourcefile\\nafpack_iterative_types.f90.html"},{"title":"NAFPack_matrix_decomposition.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_decomposition.f90~~EfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_decomposition.f90~~AfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for matrix decomposition methods !> !> This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. MODULE NAFPack_matrix_decomposition USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: forward , backward PUBLIC :: LU_decomposition , LDU_decomposition , ILU_decomposition PUBLIC :: Cholesky_decomposition , LDL_Cholesky_decomposition , Incomplete_Cholesky_decomposition PUBLIC :: QR_decomposition PUBLIC :: QR_Householder_decomposition , QR_Givens_decomposition , & QR_Gram_Schmidt_Classical_decomposition , QR_Gram_Schmidt_Modified_decomposition PUBLIC :: pivot_partial , pivot_total CONTAINS !> forward algorithm, !> solves the system !>  L * y = b  !> where **L** is a lower triangular matrix and **b** is a vector FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( L , 1 )) :: y INTEGER :: i , N N = size ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - dot_product ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward !> backward algorithm, !> solves the system !>  U * x = y  !> where **U** is an upper triangular matrix and **y** is a vector FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( size ( U , 1 )) :: x INTEGER :: i , N N = size ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - dot_product ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward !> LU decomposition of a matrix A !>  A = LU  !> This subroutine performs LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = size ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition !> LDU decomposition of a matrix A !>  A = LDU  !> This subroutine performs LDU decomposition of a given matrix **A**, where **L** is a lower triangular matrix, **D** is a diagonal matrix, and **U** is an upper triangular matrix. SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = size ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [( D ( k , k ), k = 1 , i - 1 )])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition !> Incomplete LU decomposition of a matrix A !>  A \\approx LU  !> This subroutine performs incomplete LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE ILU_decomposition ( A , L , U , level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER , OPTIONAL , INTENT ( IN ) :: level INTEGER :: N , i , j INTEGER , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: fill_level LOGICAL , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: S N = size ( A , 1 ) L = 0.d0 U = 0.d0 IF ( present ( level )) THEN CALL compute_fill_pattern_ILU ( A , fill_level , level , N ) S = ( fill_level <= level ) ELSE S = A /= 0 END IF DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j IF ( S ( i , j )) U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO IF ( abs ( U ( j , j )) < 1.0e-12_dp ) THEN PRINT * , \"Warning: Near-zero pivot at row \" , j , \", value =\" , U ( j , j ) PRINT * , \"Replacing with small value, value =\" , sign ( 1.0e-12_dp , U ( j , j )) U ( j , j ) = sign ( 1.0e-12_dp , U ( j , j )) END IF DO i = j + 1 , N IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE ILU_decomposition !> Cholesky decomposition of a matrix A !>  A = LL&#94;T  !> This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix. SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = size ( A , 1 ) DO j = 1 , N L ( j , j ) = sqrt ( A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition !> Alternative Cholesky decomposition of a matrix A !>  A = LDL&#94;T  !> This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix and **D** is a diagonal matrix. SUBROUTINE LDL_Cholesky_decomposition ( A , L , D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L , D INTEGER :: i , j , N , k N = size ( A , 1 ) L = Identity_n ( N ) D = 0.d0 DO j = 1 , N D ( j , j ) = A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )])) / D ( j , j ) END DO END DO END SUBROUTINE LDL_Cholesky_decomposition !> Incomplete Cholesky decomposition of a matrix A !>  A \\approx LL&#94;T  !> This subroutine performs incomplete Cholesky decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE Incomplete_Cholesky_decomposition ( A , L , level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , OPTIONAL , INTENT ( IN ) :: level REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: L LOGICAL , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: S INTEGER :: N , i , j INTEGER , DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: fill_level N = size ( A , 1 ) L = 0.d0 IF ( present ( level )) THEN CALL compute_fill_pattern_IC ( A , fill_level , level , N ) S = ( fill_level <= level ) ELSE S = A /= 0 END IF DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO IF ( S ( i , i )) L ( i , i ) = sqrt ( A ( i , i ) - dot_product ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) END DO END SUBROUTINE Incomplete_Cholesky_decomposition !> QR decomposition of a matrix **A** using various methods !>  A = QR  !> This subroutine performs QR decomposition of a given matrix **A** using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt). !> The output matrices **Q** is an orthogonal matrix and **R** is an upper triangular matrix. SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) END IF END SUBROUTINE QR_decomposition !> QR decomposition using Householder method SUBROUTINE QR_Householder_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( size ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = size ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = norm2 ( R ( k : N , k )) signe = - sign ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = norm2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = matmul ( Q , H ) R ( k : N , k : N ) = matmul ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder_decomposition !> QR decomposition using Givens rotations SUBROUTINE QR_Givens_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: G INTEGER :: N , i , j N = size ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = matmul ( G , R ) Q = matmul ( Q , transpose ( G )) END DO END DO END SUBROUTINE QR_Givens_decomposition !> QR decomposition using Classical Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 )) :: u INTEGER :: N , i , j N = size ( A , 1 ) Q = 0.d0 R = 0.d0 DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = dot_product ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = norm2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical_decomposition !> QR decomposition using Modified Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: u INTEGER :: N , i , j N = size ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = norm2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = dot_product ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified_decomposition SUBROUTINE pivot_partial ( A , P ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: P INTEGER , DIMENSION ( 1 ) :: vlmax INTEGER :: N , lmax , k REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: P_tmp N = size ( A , 1 ) P = Identity_n ( N ) DO k = 1 , N - 1 ! Find the maximum absolute value in the column from row k to N vlmax = maxloc ( abs ( A ( k : N , k ))) lmax = vlmax ( 1 ) + k - 1 !calculate permutation matrix P P_tmp = Identity_n ( N ) IF ( k /= lmax ) THEN P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) END IF P = matmul ( P_tmp , P ) END DO END SUBROUTINE pivot_partial SUBROUTINE pivot_total ( A , P , Q ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), INTENT ( OUT ) :: P , Q REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: P_tmp , Q_tmp INTEGER , DIMENSION ( 2 ) :: vlmax INTEGER :: N , lmax , cmax , k N = size ( A , 1 ) P = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N - 1 ! Find max abs element in submatrix vlmax = maxloc ( abs ( A ( k : N , k : N ))) lmax = vlmax ( 1 ) + k - 1 cmax = vlmax ( 2 ) + k - 1 ! permute line if necessary P_tmp = Identity_n ( N ) IF ( k /= lmax ) THEN P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) END IF P = matmul ( P_tmp , P ) ! permute column if necessary Q_tmp = Identity_n ( N ) IF ( cmax /= k ) THEN Q_tmp (:, [ k , cmax ]) = Q_tmp (:, [ cmax , k ]) END IF Q = matmul ( Q_tmp , Q ) END DO END SUBROUTINE pivot_total SUBROUTINE compute_fill_pattern_ILU ( A , fill_level , max_level , N ) REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A INTEGER , DIMENSION ( N , N ), INTENT ( OUT ) :: fill_level INTEGER , INTENT ( IN ) :: max_level , N LOGICAL , DIMENSION ( N , N ) :: S INTEGER :: new_level INTEGER :: i , j , k ! Niveau initial basé sur A fill_level = int_inf S = A /= 0.d0 WHERE ( S ) fill_level = 0 ! Calcul symbolique des niveaux de remplissage DO k = 1 , N - 1 DO i = k + 1 , N IF ( fill_level ( i , k ) <= max_level ) THEN DO j = k + 1 , N IF ( fill_level ( k , j ) <= max_level ) THEN new_level = fill_level ( i , k ) + fill_level ( k , j ) + 1 IF ( new_level < max_level ) THEN fill_level ( i , j ) = new_level END IF END IF END DO END IF END DO END DO END SUBROUTINE compute_fill_pattern_ILU SUBROUTINE compute_fill_pattern_IC ( A , fill_level , max_level , N ) REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A INTEGER , DIMENSION ( N , N ), INTENT ( OUT ) :: fill_level INTEGER , INTENT ( IN ) :: max_level , N LOGICAL , DIMENSION ( N , N ) :: S INTEGER :: new_level INTEGER :: i , j , k ! Niveau initial basé sur A fill_level = int_inf S = A /= 0.d0 WHERE ( S ) fill_level = 0 ! Calcul symbolique des niveaux de remplissage DO k = 1 , N - 1 DO i = k + 1 , N IF ( fill_level ( i , k ) <= max_level ) THEN DO j = k + 1 , i IF ( fill_level ( k , j ) <= max_level ) THEN new_level = fill_level ( i , k ) + fill_level ( k , j ) + 1 IF ( new_level < max_level ) THEN fill_level ( i , j ) = new_level fill_level ( j , i ) = new_level END IF END IF END DO END IF END DO END DO END SUBROUTINE compute_fill_pattern_IC END MODULE NAFPack_matrix_decomposition","tags":"","url":"sourcefile\\nafpack_matrix_decomposition.f90.html"},{"title":"NAFPack_Preconditioners.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_preconditioners.f90~~EfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_preconditioners.f90~~AfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Preconditioners USE NAFPack_constant USE NAFPack_Iterative_types USE NAFPack_matricielle USE NAFPack_matrix_decomposition IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF PUBLIC :: FILL_LEVEL_USED PUBLIC :: FILL_LEVEL_NONE PUBLIC :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 PUBLIC :: FILL_LEVEL_N PUBLIC :: Calculate_Jacobi_preconditioner PUBLIC :: Calculate_Gauss_Seidel_preconditioner PUBLIC :: Calculate_SOR_preconditioner PUBLIC :: Calculate_JOR_preconditioner PUBLIC :: Calculate_ILU_preconditioner PUBLIC :: Calculate_ICF_preconditioner PUBLIC :: Calculate_SSOR_preconditioner TYPE :: MethodPreconditioner INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodPreconditioner TYPE :: Fill_level_used INTEGER :: id CHARACTER ( LEN = 64 ) :: name INTEGER :: VALUE END TYPE Fill_level_used TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_NONE = MethodPreconditioner ( 0 , \"None\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_JACOBI = MethodPreconditioner ( 1 , \"Jacobi\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner ( 2 , \"Gauss-Seidel\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner ( 3 , \"Successive Over-Relaxation\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_JOR = MethodPreconditioner ( 4 , \"Jacobi Over-Relaxation\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_ILU = MethodPreconditioner ( 5 , \"ILU\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_ICF = MethodPreconditioner ( 6 , \"ICF\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_SSOR = MethodPreconditioner ( 7 , \"SSOR\" ) TYPE ( Fill_level_used ), PARAMETER :: FILL_LEVEL_NONE = Fill_level_used ( - 1 , \"None\" , - huge ( 1 )) TYPE ( Fill_level_used ), PARAMETER :: FILL_LEVEL_0 = Fill_level_used ( 0 , \"Level 0\" , 0 ) TYPE ( Fill_level_used ), PARAMETER :: FILL_LEVEL_1 = Fill_level_used ( 1 , \"Level 1\" , 1 ) TYPE ( Fill_level_used ), PARAMETER :: FILL_LEVEL_2 = Fill_level_used ( 2 , \"Level 2\" , 2 ) TYPE ( Fill_level_used ), PARAMETER :: FILL_LEVEL_3 = Fill_level_used ( 3 , \"Level 3\" , 3 ) TYPE ( Fill_level_used ) :: FILL_LEVEL_N = Fill_level_used ( 3 , \"Level N\" , 0 ) CONTAINS FUNCTION Calculate_Jacobi_preconditioner ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: D INTEGER :: N , i N = size ( A , 1 ) D = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Jacobi preconditioner\" FORALL ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) END FUNCTION Calculate_Jacobi_preconditioner FUNCTION Calculate_Gauss_Seidel_preconditioner ( A ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER :: N , i , j N = size ( A , 1 ) L = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" FORALL ( i = 1 : size ( A , 1 ), j = 1 : size ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) END FUNCTION Calculate_Gauss_Seidel_preconditioner FUNCTION Calculate_SOR_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER :: N , i N = size ( A , 1 ) L = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in SOR preconditioner\" DO i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) END DO L = alpha * L END FUNCTION Calculate_SOR_preconditioner FUNCTION Calculate_JOR_preconditioner ( A , omega , alpha ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: D INTEGER :: N , i N = size ( A , 1 ) D = 0.d0 IF ( any ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in JOR preconditioner\" FORALL ( i = 1 : size ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha END FUNCTION Calculate_JOR_preconditioner SUBROUTINE Calculate_ILU_preconditioner ( A , L , U , omega , alpha , fill_level ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: L , U INTEGER , OPTIONAL , INTENT ( IN ) :: fill_level INTEGER :: N N = size ( A , 1 ) L = 0.d0 U = 0.d0 IF ( present ( fill_level )) THEN CALL ILU_decomposition ( A , L , U , fill_level ) ELSE CALL ILU_decomposition ( A , L , U ) END IF L = alpha / omega * L END SUBROUTINE Calculate_ILU_preconditioner FUNCTION Calculate_ICF_preconditioner ( A , omega , alpha , fill_level ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: L INTEGER , OPTIONAL , INTENT ( IN ) :: fill_level INTEGER :: N N = size ( A , 1 ) L = 0.d0 IF ( present ( fill_level )) THEN CALL Incomplete_Cholesky_decomposition ( A , L , fill_level ) ELSE CALL Incomplete_Cholesky_decomposition ( A , L ) END IF L = alpha / omega * L END FUNCTION Calculate_ICF_preconditioner SUBROUTINE Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )), INTENT ( OUT ) :: L , D INTEGER :: N , i N = size ( A , 1 ) L = 0.d0 D = 0.d0 DO i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) END DO L = ( alpha * omega ) / ( 2 - omega ) * L END SUBROUTINE Calculate_SSOR_preconditioner END MODULE NAFPack_Preconditioners","tags":"","url":"sourcefile\\nafpack_preconditioners.f90.html"},{"title":"NAFPack_Krylov_method.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_krylov_method.f90~~EfferentGraph sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Krylov_method USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE CONTAINS SUBROUTINE lanczos ( A , q1 , m , Q , T ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: q1 INTEGER , INTENT ( IN ) :: m REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: Q REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: T REAL ( dp ), DIMENSION ( size ( A , 1 )) :: y , z REAL ( dp ), DIMENSION ( m ) :: alpha REAL ( dp ), DIMENSION ( m - 1 ) :: beta INTEGER :: N , k N = size ( A , 1 ) alpha = 0.d0 beta = 0.d0 Q = 0.d0 Q (:, 1 ) = q1 / norm2 ( q1 ) DO k = 1 , m IF ( k == 1 ) THEN y = matmul ( A , Q (:, k )) ELSE y = matmul ( A , Q (:, k )) - beta ( k - 1 ) * Q (:, k - 1 ) END IF alpha ( k ) = dot_product ( Q (:, k ), y ) z = y - alpha ( k ) * Q (:, k ) IF ( k < m ) THEN beta ( k ) = norm2 ( z ) IF ( beta ( k ) < 1.0d-12 ) EXIT Q (:, k + 1 ) = z / beta ( k ) END IF END DO T = Make_Tridiagonal ( beta , alpha , beta ) END SUBROUTINE lanczos SUBROUTINE Arnoldi ( A , q1 , m , Q , H ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: q1 INTEGER , INTENT ( IN ) :: m REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: Q REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: H INTEGER :: k , j , N N = size ( A , 1 ) Q (:, 1 ) = q1 / norm2 ( q1 ) H = 0.0d0 DO k = 2 , m Q (:, k ) = matmul ( A , Q (:, k - 1 )) DO j = 1 , k - 1 H ( j , k - 1 ) = dot_product ( Q (:, j ), Q (:, k )) Q (:, k ) = Q (:, k ) - H ( j , k - 1 ) * Q (:, j ) END DO H ( k , k - 1 ) = norm2 ( Q (:, k )) Q (:, k ) = Q (:, k ) / H ( k , k - 1 ) END DO END SUBROUTINE Arnoldi SUBROUTINE Arnoldi_MGS ( A , q1 , m , Q , H ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: q1 INTEGER , INTENT ( IN ) :: m REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: Q ! (n, m+1) REAL ( dp ), DIMENSION (:, :), INTENT ( OUT ) :: H ! (m+1, m) INTEGER :: k , j , N REAL ( dp ), DIMENSION ( size ( A , 1 )) :: w N = size ( A , 1 ) Q (:, 1 ) = q1 / norm2 ( q1 ) H = 0.0d0 DO k = 1 , m ! w = A * q_k w = matmul ( A , Q (:, k )) ! Modified Gram-Schmidt orthonormalization DO j = 1 , k H ( j , k ) = dot_product ( Q (:, j ), w ) w = w - H ( j , k ) * Q (:, j ) END DO H ( k + 1 , k ) = norm2 ( w ) IF ( H ( k + 1 , k ) > 0.0d0 ) THEN Q (:, k + 1 ) = w / H ( k + 1 , k ) ELSE Q (:, k + 1 ) = 0.0d0 END IF END DO END SUBROUTINE Arnoldi_MGS END MODULE NAFPack_Krylov_method","tags":"","url":"sourcefile\\nafpack_krylov_method.f90.html"},{"title":"NAFPack_matrix_properties.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_properties.f90~~EfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_properties.f90~~AfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_matrix_properties USE NAFPack_constant USE NAFPack_matricielle USE NAFPack_Eigen IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: is_square_matrix , is_symmetric , is_orthogonal , is_SPD , is_tridiagonal , & is_diagonally_dominant , is_non_zero_diagonal CONTAINS FUNCTION is_square_matrix ( A ) RESULT ( is_square ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_square is_square = ( size ( A , 1 ) == size ( A , 2 )) END FUNCTION is_square_matrix FUNCTION is_symmetric ( A ) RESULT ( is_sym ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_sym is_sym = all ( A == transpose ( A )) END FUNCTION is_symmetric FUNCTION is_orthogonal ( A ) RESULT ( is_orth ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_orth is_orth = all ( abs ( matmul ( A , transpose ( A )) - Identity_n ( size ( A , 1 ))) < epsi_test ) END FUNCTION is_orthogonal FUNCTION is_SPD ( A , is_sym ) RESULT ( is_spd_matrix ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: is_sym REAL ( dp ), DIMENSION ( size ( A , 1 )) :: lambda LOGICAL :: is_spd_matrix IF ( present ( is_sym )) THEN IF (. NOT . is_sym ) THEN is_spd_matrix = . FALSE . RETURN END IF ELSE IF (. NOT . is_symmetric ( A )) THEN is_spd_matrix = . FALSE . RETURN END IF CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( minval ( lambda ) < 0 ) THEN is_spd_matrix = . FALSE . ELSE is_spd_matrix = . TRUE . END IF END FUNCTION is_SPD FUNCTION is_tridiagonal ( A ) RESULT ( is_tridiag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_tridiag INTEGER :: i , j , N N = size ( A , 1 ) is_tridiag = . TRUE . DO i = 1 , N DO j = 1 , N IF ( abs ( i - j ) > 1 ) THEN IF ( abs ( A ( i , j )) > epsi ) THEN is_tridiag = . FALSE . RETURN END IF END IF END DO END DO END FUNCTION is_tridiagonal FUNCTION is_diagonally_dominant ( A ) RESULT ( is_diag_dom ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_diag_dom INTEGER :: i , N REAL ( dp ) :: row_sum N = size ( A , 1 ) is_diag_dom = . TRUE . DO i = 1 , N row_sum = sum ( abs ( A ( i , :))) - abs ( A ( i , i )) IF ( abs ( A ( i , i )) < row_sum ) THEN is_diag_dom = . FALSE . RETURN END IF END DO END FUNCTION is_diagonally_dominant FUNCTION is_non_zero_diagonal ( A ) RESULT ( is_non_zero_diag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_non_zero_diag is_non_zero_diag = . TRUE . IF ( any ( abs ( Diag ( A )) < epsi )) is_non_zero_diag = . FALSE . END FUNCTION is_non_zero_diagonal END MODULE NAFPack_matrix_properties","tags":"","url":"sourcefile\\nafpack_matrix_properties.f90.html"},{"title":"NAFPack_linalg.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_linalg.f90~~EfferentGraph sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.F90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_linalg USE NAFPack_Direct_types USE NAFPack_Direct_method USE NAFPack_Iterative_types USE NAFPack_Iterative_methods IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: linalg , DirectMethod , IterativeMethod PUBLIC :: MethodTypeDirect , MethodQR PUBLIC :: METHOD_DIRECT_NONE PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR PUBLIC :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT PUBLIC :: QR_GRAM_SCHMIDT_Modified PUBLIC :: IterativeParams PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: METHOD_CGNE , METHOD_CGNR PUBLIC :: METHOD_GMRES PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF PUBLIC :: Norm_used PUBLIC :: NORM_2 , NORM_1 , NORM_INF PUBLIC :: FILL_LEVEL_USED PUBLIC :: FILL_LEVEL_NONE PUBLIC :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 PUBLIC :: FILL_LEVEL_N TYPE :: linalg TYPE ( DirectMethod ) :: direct TYPE ( IterativeMethod ) :: iterative END TYPE linalg CONTAINS END MODULE NAFPack_linalg","tags":"","url":"sourcefile\\nafpack_linalg.f90.html"},{"title":"NAFPack_matrix_market.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_market.f90~~EfferentGraph sourcefile~nafpack_matrix_market.f90 NAFPack_matrix_market.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_market.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_matrix_market USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) CONTAINS SUBROUTINE readMatrixMarket ( filename , A ) CHARACTER ( LEN =* ), INTENT ( IN ) :: filename REAL ( dp ), DIMENSION (:, :), ALLOCATABLE , INTENT ( OUT ) :: A INTEGER :: i , j , nrows , ncols , nnz , ios , k , row_idx , col_idx CHARACTER ( LEN = 256 ) :: line , header CHARACTER ( LEN = 50 ) :: object , format_type , field , symmetry INTEGER :: unit REAL ( dp ) :: val unit = 10 ! Open the file OPEN ( NEWUNIT = unit , FILE = filename , STATUS = 'old' , ACTION = 'read' , IOSTAT = ios ) IF ( ios /= 0 ) THEN PRINT * , 'Error: opening file: ' , filename STOP END IF ! read the header READ ( unit , '(A)' , IOSTAT = ios ) header IF ( ios /= 0 ) THEN PRINT * , 'Error: reading header Matrix Market' CLOSE ( unit ) STOP END IF ! Check Matrix Market format IF ( index ( header , '%%MatrixMarket' ) == 0 ) THEN PRINT * , 'Error: file is not in Matrix Market format' CLOSE ( unit ) RETURN END IF ! Parse the header to extract information READ ( header , * , iostat = ios ) object , object , format_type , field , symmetry IF ( ios /= 0 ) THEN PRINT * , 'Error reading Matrix Market header' CLOSE ( unit ) STOP END IF ! Skip comment lines and find the size line DO READ ( unit , '(A)' , IOSTAT = ios ) line IF ( ios /= 0 ) THEN PRINT * , 'Error: malformed file' CLOSE ( unit ) STOP END IF IF ( line ( 1 : 1 ) /= '%' ) THEN EXIT END IF END DO ! Read matrix dimensions READ ( line , * , iostat = ios ) nrows , ncols , nnz IF ( ios /= 0 ) THEN PRINT * , 'Error: unable to read dimensions' CLOSE ( unit ) RETURN END IF ALLOCATE ( A ( nrows , ncols )) A = 0.0_dp ! Read matrix entries IF ( trim ( format_type ) == 'coordinate' ) THEN ! Coordinate format (sparse) DO k = 1 , nnz READ ( unit , * , iostat = ios ) row_idx , col_idx , val IF ( ios /= 0 ) THEN PRINT * , 'Error: reading entry' , k EXIT END IF A ( row_idx , col_idx ) = val ! If the matrix is symmetric, also fill A(j,i) IF ( trim ( symmetry ) == 'symmetric' . AND . row_idx /= col_idx ) THEN A ( col_idx , row_idx ) = val END IF END DO ELSE IF ( trim ( format_type ) == 'array' ) THEN ! Dense format (array) DO j = 1 , ncols DO i = 1 , nrows READ ( unit , * , iostat = ios ) val IF ( ios /= 0 ) THEN PRINT * , 'Error: reading element (' , i , ',' , j , ')' CLOSE ( unit ) RETURN END IF A ( i , j ) = val END DO END DO ELSE PRINT * , 'Error: unsupported format: ' , trim ( format_type ) CLOSE ( unit ) RETURN END IF CLOSE ( unit ) END SUBROUTINE readMatrixMarket END MODULE NAFPack_matrix_market","tags":"","url":"sourcefile\\nafpack_matrix_market.f90.html"},{"title":"NAFPack_Direct_types.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_direct_types.f90~~AfferentGraph sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Direct_types IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: MethodTypeDirect , MethodQR PUBLIC :: METHOD_DIRECT_NONE PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR PUBLIC :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT PUBLIC :: QR_GRAM_SCHMIDT_Modified PUBLIC :: DirectMethodRequirements TYPE :: MethodTypeDirect INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeDirect TYPE :: MethodQR INTEGER :: id CHARACTER ( LEN = 64 ) :: name END TYPE MethodQR TYPE :: DirectMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_non_zero_diag = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_tridiagonal = . FALSE . LOGICAL :: needs_symmetric = . FALSE . END TYPE DirectMethodRequirements TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_DIRECT_NONE = MethodTypeDirect ( 0 , \"None\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_Gauss = MethodTypeDirect ( 1 , \"Gauss\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_Gauss_JORDAN = MethodTypeDirect ( 2 , \"Gauss-Jordan\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LU = MethodTypeDirect ( 3 , \"LU\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LDU = MethodTypeDirect ( 4 , \"LDU\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_CHOLESKY = MethodTypeDirect ( 5 , \"Cholesky\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LDL_Cholesky = MethodTypeDirect ( 6 , \"LDL-Cholesky\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_QR = MethodTypeDirect ( 7 , \"QR\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_TDMA = MethodTypeDirect ( 8 , \"TDMA\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect ( 9 , \"Faddeev-Leverrier\" ) TYPE ( MethodQR ), PARAMETER :: QR_HOUSEHOLDER = MethodQR ( 1 , \"Householder\" ) TYPE ( MethodQR ), PARAMETER :: QR_GIVENS = MethodQR ( 2 , \"Givens\" ) TYPE ( MethodQR ), PARAMETER :: QR_GRAM_SCHMIDT = MethodQR ( 3 , \"Gram-Schmidt\" ) TYPE ( MethodQR ), PARAMETER :: QR_GRAM_SCHMIDT_Modified = MethodQR ( 4 , \"Gram_Schmidt_Modified\" ) END MODULE NAFPack_Direct_types","tags":"","url":"sourcefile\\nafpack_direct_types.f90.html"},{"title":"NAFPack_matricielle.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matricielle.f90~~EfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matricielle.f90~~AfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Tensor operations in NAFPack MODULE NAFPack_matricielle USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: dot , cross PUBLIC :: norm_2_real , norm_2_complex PUBLIC :: normalise , normalise_complexe PUBLIC :: Diagonally_Dominant_Matrix PUBLIC :: Identity_n PUBLIC :: rotation_matrix PUBLIC :: Trace PUBLIC :: Diag , Make_Tridiagonal CONTAINS !> function that calculates the dot product of two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\cdot \\vec{b}  FUNCTION dot ( a , b ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: RESULT INTEGER :: i IF ( size ( a ) /= size ( b )) STOP \"Error: Vectors must be of the same size.\" RESULT = 0.0_dp DO i = 1 , size ( a ) RESULT = RESULT + a ( i ) * b ( i ) END DO END FUNCTION dot !> function that calculates the cross product between two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\times \\vec{b} [&#94;1] !> [&#94;1]: the wedge notation  \\vec{a} \\wedge \\vec{b}  can sometimes be used to denote the vector product. FUNCTION cross ( a , b ) RESULT ( RESULT ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: RESULT RESULT ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) RESULT ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) RESULT ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross !> function that calculates the Euclidean norm (L2 norm) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} a_i&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} a_i&#94;2 = \\vec{a} \\cdot \\vec{a}  !> where  n  is the dimension of the real vector  \\vec{a} . FUNCTION norm_2_real ( a ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: RESULT RESULT = sqrt ( dot_product ( a , a )) END FUNCTION norm_2_real !> Optimized norm calculation avoiding overflow/underflow PURE FUNCTION norm_2_safe ( a ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a REAL ( dp ) :: RESULT REAL ( dp ) :: scale , sum_of_squares scale = maxval ( abs ( a )) IF ( scale == 0.0_dp ) THEN RESULT = 0.0_dp ELSE sum_of_squares = sum (( a / scale ) ** 2 ) RESULT = scale * sqrt ( sum_of_squares ) END IF END FUNCTION norm_2_safe !> function that calculates the Euclidean norm (L2 norm or modulus) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} |a_i|&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} |a_i|&#94;2 = \\vec{a} \\cdot \\overline{\\vec{a}}  !> where  n  is the dimension of the complex vector  \\vec{a} . FUNCTION norm_2_complex ( a ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: RESULT RESULT = sqrt ( REAL ( dot_product ( a , conjg ( a )))) END FUNCTION norm_2_complex !> function that normalises a real vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise ( a ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( size ( a )) :: RESULT RESULT = a / norm_2_real ( a ) END FUNCTION normalise !> function that normalises a complex vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise_complexe ( a ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( size ( a )) :: RESULT RESULT = a / norm_2_complex ( a ) END FUNCTION normalise_complexe !> function that calculates the trace of a square matrix  A  !>  \\text{Tr}(A) = \\sum_{i=1}&#94;{n} A(i,i)  FUNCTION Trace ( A ) RESULT ( RESULT ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ) :: RESULT INTEGER :: i , N N = size ( A , 1 ) IF ( size ( A , 2 ) /= N ) STOP \"Error: Matrix must be square.\" RESULT = sum ([( A ( i , i ), i = 1 , N )]) END FUNCTION Trace !> function which checks if **A** is diagonally dominant !>  \\forall i, |A(i,i)| \\geq \\sum_{j \\neq i} |A(i,j)|  FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = size ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = sum ( abs ( A ( i , :) - A ( i , i ))) IF ( abs ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix !> function that returns the identity matrix for a given size N !>  I_N = \\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{pmatrix}  FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( present ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n !> function that extracts the diagonal of a matrix !>  D = \\begin{pmatrix} A(1,1) & 0 & \\cdots & 0 \\\\ 0 & A(2,2) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & A(n,n) \\end{pmatrix}  !> where  D  is a vector containing the diagonal elements of the matrix  A . FUNCTION Diag ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( size ( A , 1 )) :: D INTEGER :: i , N N = size ( A , 1 ) FORALL ( i = 1 : N ) D ( i ) = A ( i , i ) END FUNCTION Diag FUNCTION Make_Tridiagonal ( d_minus , d , d_plus ) RESULT ( T ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: d_minus , d , d_plus REAL ( dp ), DIMENSION ( size ( d , 1 ), size ( d , 1 )) :: T INTEGER :: i , N N = size ( d , 1 ) T = 0.d0 DO i = 1 , N T ( i , i ) = d ( i ) IF ( i > 1 ) T ( i , i - 1 ) = d_minus ( i ) IF ( i < N ) T ( i , i + 1 ) = d_plus ( i ) END DO END FUNCTION Make_Tridiagonal !> Function to create a rotation matrix !> !> This function generates a rotation matrix **G** based on the input matrix **A** and the specified rotation indices. FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( size ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = sqrt ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix END MODULE NAFPack_matricielle","tags":"","url":"sourcefile\\nafpack_matricielle.f90.html"},{"title":"NAFPack_fft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fft.f90~~EfferentGraph sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Fourier Transform !>  F(\\omega) = \\int_{-\\infty}&#94;{\\infty} f(t) e&#94;{-i \\omega t} dt  !> This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals. !> It supports both forward and inverse transforms. !> It allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. MODULE NAFPack_fft USE FFTW3 USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: FFT_1D , FFT_2D , FFT_3D PUBLIC :: IFFT_1D , IFFT_2D , IFFT_3D CONTAINS !> Perform a 1D Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_DFT\": Direct Discrete Fourier Transform !> - \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_1D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT IF ( method == \"NAFPack_DFT\" ) THEN RESULT = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN RESULT = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT IF ( method == \"NAFPack_IFFT_1D\" ) THEN RESULT = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_2D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT IF ( method == \"NAFPack_FFT_2D\" ) THEN RESULT = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT IF ( method == \"NAFPack_IFFT_2D\" ) THEN RESULT = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D !> Perform a 3D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_3D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . present ( threads )) THEN RESULT = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . present ( threads )) THEN RESULT = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . present ( threads )) THEN RESULT = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D !################### FFTW ########################################## !> Perform a 1D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_1D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( size ( signal ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_1D_threads !> Perform a 1D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_1D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( size ( signal ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_1D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( size ( signal ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / size ( signal ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_1D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( size ( signal ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / size ( signal ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_1D_threads !> Perform a 2D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_2D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_2D !> Perform a 2D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_2D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_2D_threads !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_2D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / ( size ( signal , 1 ) * size ( signal , 2 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_2D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / ( size ( signal , 1 ) * size ( signal , 2 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_2D_threads !> Perform a 3D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_3D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( size ( signal , 3 ), size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_3D !> Perform a 3D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_3D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( size ( signal , 3 ), size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_3D_threads !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_3D ( signal ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( size ( signal , 3 ), size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / ( size ( signal , 1 ) * size ( signal , 2 ) * size ( signal , 3 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_3D_threads ( signal , threads ) RESULT ( RESULT ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: RESULT INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( size ( signal , 3 ), size ( signal , 2 ), size ( signal , 1 ), signal , RESULT , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , RESULT ) RESULT = RESULT / ( size ( signal , 1 ) * size ( signal , 2 ) * size ( signal , 3 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_3D_threads !################### NAFPack ########################################## !> Perform a 1D Discrete Fourier Transform on a signal FUNCTION NAFPack_DFT_1D ( signal ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT COMPLEX ( dp ) :: S INTEGER :: N , i , k , j N = size ( signal ) IF ( N == 1 ) THEN RESULT = signal ELSE DO i = 1 , N k = i - 1 S = ( 0.d0 , 0.d0 ) DO j = 1 , N S = S + signal ( j ) * exp (( - 2 * pi * im * k * ( j - 1 )) / N ) END DO RESULT ( i ) = S END DO END IF END FUNCTION NAFPack_DFT_1D !> Compute the complex exponential factors for the FFT FUNCTION fun_omega ( N ) RESULT ( RESULT ) INTEGER , INTENT ( IN ) :: N COMPLEX ( dp ), DIMENSION ( N / 2 ) :: RESULT INTEGER :: i DO i = 1 , N / 2 RESULT ( i ) = exp ( - 2 * Im * pi * ( i - 1 ) / N ) END DO END FUNCTION fun_omega !> Perform a 1D Fast Fourier Transform (Cooley-Tukey) on a signal RECURSIVE FUNCTION NAFPack_FFT_1D ( signal ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( size ( signal )) :: RESULT COMPLEX ( dp ), DIMENSION ( size ( signal ) / 2 ) :: f_pair , f_impair , omega INTEGER :: N N = size ( signal ) IF ( mod ( N , 2 ) == 0 ) THEN f_pair = NAFPack_FFT_1D ( signal ( 1 :: 2 )) f_impair = NAFPack_FFT_1D ( signal ( 2 :: 2 )) omega = fun_omega ( N ) RESULT ( 1 : N / 2 ) = f_pair + f_impair * omega RESULT ( N / 2 + 1 :) = f_pair - f_impair * omega ELSE RESULT = NAFPack_DFT_1D ( signal ) END IF END FUNCTION NAFPack_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_1D ( f_signal ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( size ( f_signal )) :: RESULT COMPLEX ( dp ), DIMENSION ( size ( f_signal )) :: f_conjugate INTEGER :: N N = size ( f_signal ) f_conjugate = conjg ( f_signal ) RESULT = NAFPack_FFT_1D ( f_conjugate ) RESULT = conjg ( RESULT ) RESULT = RESULT / N END FUNCTION NAFPack_IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal FUNCTION NAFPack_FFT_2D ( signal ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( size ( signal , 1 ), size ( signal , 2 )) :: RESULT INTEGER :: Nx , Ny , i Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) DO i = 1 , Nx RESULT ( i , :) = NAFPack_FFT_1D ( signal ( i , :)) END DO DO i = 1 , Ny RESULT (:, i ) = NAFPack_FFT_1D ( RESULT (:, i )) END DO END FUNCTION NAFPack_FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_2D ( f_signal ) RESULT ( RESULT ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( size ( f_signal , 1 ), size ( f_signal , 2 )) :: RESULT INTEGER :: Nx , Ny , i Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) DO i = 1 , Nx RESULT ( i , :) = NAFPack_IFFT_1D ( f_signal ( i , :)) END DO DO i = 1 , Ny RESULT (:, i ) = NAFPack_IFFT_1D ( RESULT (:, i )) END DO END FUNCTION NAFPack_IFFT_2D END MODULE NAFPack_fft","tags":"","url":"sourcefile\\nafpack_fft.f90.html"},{"title":"NAFPack_Iterative_methods.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_methods.f90~~EfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.F90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_methods.f90~~AfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !========================================================== ! NAFPack_Iterative_methods.f90 ! Module for iterative methods in NAFPack !========================================================== !> Module for iterative methods in NAFPack MODULE NAFPack_Iterative_methods USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle USE NAFPack_Iterative_types USE NAFPack_Logger_mod USE NAFPack_Preconditioners USE NAFPack_Iterative_Params USE NAFPack_matrix_properties USE NAFPack_memory_monitor IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: IterativeMethod PUBLIC :: IterativeParams PUBLIC :: MethodTypeIterative PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: METHOD_CGNR , METHOD_CGNE PUBLIC :: METHOD_GMRES PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF PUBLIC :: Norm_used PUBLIC :: NORM_2 , NORM_1 , NORM_INF PUBLIC :: FILL_LEVEL_USED PUBLIC :: FILL_LEVEL_NONE PUBLIC :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 PUBLIC :: FILL_LEVEL_N !====================== ! Type definitions !====================== TYPE :: IterativeMethod PRIVATE TYPE ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE TYPE ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE TYPE ( IterativeMethodRequirements ) :: requirements TYPE ( relaxation_factor_used ) :: relaxation_factor = RELAXATION_FACTOR_NONE TYPE ( relaxation_factor_used ) :: relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE PROCEDURE ( solve_interface_Iterative ), PASS ( this ), POINTER :: solve_method => null () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: solve => IterativeMethod_solve PROCEDURE :: Init_IterativeParams => Init_IterativeParams PROCEDURE :: Dealocate_IterativeParams => Dealocate_IterativeParams PROCEDURE :: test_matrix => test_matrix END TYPE IterativeMethod !====================== ! Interface !====================== ABSTRACT INTERFACE FUNCTION solve_interface_Iterative ( this , A , b , x0 , params ) RESULT ( x ) IMPORT :: dp IMPORT :: IterativeParams IMPORT :: IterativeMethod CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x END FUNCTION solve_interface_Iterative END INTERFACE CONTAINS !====================== ! Management of iterative methods !====================== SUBROUTINE set_method ( this , method ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this TYPE ( MethodTypeIterative ), INTENT ( IN ) :: method this % requirements = IterativeMethodRequirements () SELECT CASE ( method % id ) CASE ( METHOD_Jacobi % id ) this % solve_method => solve_Jacobi this % method_type = METHOD_Jacobi this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_GAUSS_SEIDEL % id ) this % solve_method => solve_Gauss_Seidel this % method_type = METHOD_GAUSS_SEIDEL this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_SOR % id ) this % solve_method => solve_SOR this % method_type = METHOD_SOR this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_OMEGA CASE ( METHOD_JOR % id ) this % solve_method => solve_JOR this % method_type = METHOD_JOR this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_OMEGA CASE ( METHOD_SIP_ILU % id ) this % solve_method => solve_SIP_ILU this % method_type = METHOD_SIP_ILU this % requirements % needs_square = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_OMEGA CASE ( METHOD_SIP_ICF % id ) this % solve_method => solve_SIP_ICF this % method_type = METHOD_SIP_ICF this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_OMEGA CASE ( METHOD_SSOR % id ) this % solve_method => solve_SSOR this % method_type = METHOD_SSOR this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_OMEGA CASE ( METHOD_RICHARDSON % id ) this % solve_method => solve_Richardson this % method_type = METHOD_RICHARDSON this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor = RELAXATION_FACTOR_ALPHA CASE ( METHOD_CONJUGATE_GRADIENT % id ) this % solve_method => solve_ConjugateGradient this % method_type = METHOD_CONJUGATE_GRADIENT this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_CONJUGATE_RESIDUAL % id ) this % solve_method => solve_ConjugateResidual this % method_type = METHOD_CONJUGATE_RESIDUAL this % requirements % needs_square = . TRUE . this % requirements % needs_symetric = . TRUE . CASE ( METHOD_CGNR % id ) this % solve_method => solve_CGNR this % method_type = METHOD_CGNR CASE ( METHOD_CGNE % id ) this % solve_method => solve_CGNE this % method_type = METHOD_CGNE CASE ( METHOD_GMRES % id ) this % solve_method => solve_GMRES this % method_type = METHOD_GMRES this % requirements % needs_square = . TRUE . CASE DEFAULT STOP \"ERROR :: Unknown method iterative\" END SELECT END SUBROUTINE set_method FUNCTION Init_IterativeParams ( this , N , A , x0 , max_iter_choice , epsi_tol , omega , Norm_choice , fill_level , & method_preconditioner , alpha , is_stationary , is_strict_mode ) RESULT ( params ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this INTEGER , INTENT ( IN ) :: N REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: x0 INTEGER , OPTIONAL , INTENT ( IN ) :: max_iter_choice REAL ( dp ), OPTIONAL , INTENT ( IN ) :: epsi_tol REAL ( dp ), OPTIONAL , INTENT ( IN ) :: omega REAL ( dp ), OPTIONAL , INTENT ( IN ) :: alpha TYPE ( Norm_used ), OPTIONAL , INTENT ( IN ) :: Norm_choice TYPE ( MethodPreconditioner ), OPTIONAL , INTENT ( IN ) :: method_preconditioner LOGICAL , OPTIONAL , INTENT ( IN ) :: is_stationary LOGICAL , OPTIONAL , INTENT ( IN ) :: is_strict_mode TYPE ( FILL_LEVEL_USED ), OPTIONAL , INTENT ( IN ) :: fill_level TYPE ( IterativeParams ) :: params INTEGER :: allocate_status ALLOCATE ( params % x_init ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate x_init\" IF ( present ( x0 )) THEN params % x_init = x0 ELSE params % x_init = 0.0_dp END IF IF ( present ( max_iter_choice )) params % max_iter = 1000 IF ( present ( epsi_tol )) params % tol = 1.0e-6_dp IF ( present ( omega )) params % omega = omega IF ( present ( alpha )) params % alpha = alpha IF ( present ( Norm_choice )) params % norm = Norm_choice IF ( present ( fill_level )) params % fill_level = fill_level ALLOCATE ( params % residual ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate residual\" SELECT CASE ( this % method_type % id ) CASE ( METHOD_SIP_ILU % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % U ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate U\" CALL ILU_decomposition ( A , params % L , params % U ) CASE ( METHOD_SIP_ICF % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" CALL Incomplete_Cholesky_decomposition ( A , params % L ) CASE ( METHOD_CONJUGATE_GRADIENT % id ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" CASE ( METHOD_CONJUGATE_RESIDUAL % id ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" CASE ( METHOD_CGNR % id ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" CASE ( METHOD_CGNE % id ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" END SELECT IF ( present ( method_preconditioner )) THEN params % precond => ApplyPreconditioner SELECT CASE ( method_preconditioner % id ) CASE ( METHOD_PRECOND_JACOBI % id ) ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" params % D = Calculate_Jacobi_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_JACOBI this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_GS % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" params % L = Calculate_Gauss_Seidel_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_GS this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_SOR % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" params % L = Calculate_SOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SOR this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA CASE ( METHOD_PRECOND_JOR % id ) ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" params % D = Calculate_JOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_JOR this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA CASE ( METHOD_PRECOND_ILU % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % U ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate U\" IF ( params % fill_level % id /= FILL_LEVEL_NONE % id ) THEN CALL Calculate_ILU_preconditioner ( A , params % L , params % U , params % omega , params % alpha , params % fill_level % id ) ELSE CALL Calculate_ILU_preconditioner ( A , params % L , params % U , params % omega , params % alpha ) END IF this % preconditioner_type = METHOD_PRECOND_ILU this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA CASE ( METHOD_PRECOND_ICF % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" IF ( params % fill_level % id /= FILL_LEVEL_NONE % id ) THEN params % L = Calculate_ICF_preconditioner ( A , params % omega , params % alpha , params % fill_level % id ) ELSE params % L = Calculate_ICF_preconditioner ( A , params % omega , params % alpha ) END IF this % preconditioner_type = METHOD_PRECOND_ICF this % requirements % needs_SPD = . TRUE . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA CASE ( METHOD_PRECOND_SSOR % id ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" CALL Calculate_SSOR_preconditioner ( A , params % L , params % D , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SSOR this % requirements % needs_SPD = . TRUE . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA CASE DEFAULT STOP \"ERROR :: Unknown method \" END SELECT END IF IF ( present ( is_stationary )) THEN IF ( is_stationary ) THEN params % is_stationary = . TRUE . this % requirements % needs_SPD = . FALSE . ELSE params % is_stationary = . FALSE . END IF END IF IF ( present ( is_strict_mode )) THEN IF ( is_strict_mode ) THEN params % strict_mode = . TRUE . ELSE params % strict_mode = . FALSE . END IF END IF END FUNCTION Init_IterativeParams SUBROUTINE test_matrix ( this , A , params , verbose ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A TYPE ( IterativeParams ), INTENT ( IN ) :: params TYPE ( Logger ), OPTIONAL , INTENT ( INOUT ) :: verbose CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg LOGICAL :: show_matrix_test show_matrix_test = . FALSE . IF ( present ( verbose )) THEN IF ( verbose % show_matrix_test ) show_matrix_test = . TRUE . END IF IF ( show_matrix_test ) THEN CALL verbose % WRITE ( center_with_fill ( \"Testing matrix properties for method:\" // trim ( this % method_type % name ), & 100 , fill_char = \"=\" ), box_style = \"top\" ) CALL verbose % WRITE ( ucs4_ \"\" , box_style = \"middle\" ) END IF IF ( this % requirements % needs_square ) THEN IF ( show_matrix_test ) CALL verbose % log_info ( ucs4_ \"Checking if the matrix is square...\" ) IF (. NOT . is_square_matrix ( A )) THEN WRITE ( msg , '(2A)' ) trim ( this % method_type % name ), \" requires a square matrix\" IF ( params % strict_mode ) THEN IF ( show_matrix_test ) CALL verbose % log_error ( msg ) STOP ELSE IF ( show_matrix_test ) CALL verbose % log_warning ( msg ) END IF END IF END IF IF ( this % requirements % needs_SPD ) THEN IF ( show_matrix_test ) CALL verbose % log_info ( ucs4_ \"Checking if the matrix is symmetric positive definite (SPD)...\" ) IF (. NOT . is_SPD ( A )) THEN WRITE ( msg , '(2A)' ) trim ( this % method_type % name ), \" method requires a symmetric positive definite matrix.\" IF ( params % strict_mode ) THEN IF ( show_matrix_test ) CALL verbose % log_error ( msg ) STOP ELSE IF ( show_matrix_test ) CALL verbose % log_warning ( msg ) END IF END IF END IF IF ( this % requirements % needs_diag_dom ) THEN IF ( show_matrix_test ) CALL verbose % log_info ( ucs4_ \"Checking if the matrix is diagonally dominant...\" ) IF (. NOT . is_diagonally_dominant ( A )) THEN WRITE ( msg , '(2A)' ) trim ( this % method_type % name ), \" method requires a diagonally dominant matrix.\" IF ( params % strict_mode ) THEN IF ( show_matrix_test ) CALL verbose % log_error ( msg ) STOP ELSE IF ( show_matrix_test ) CALL verbose % log_warning ( msg ) END IF END IF END IF IF ( this % requirements % needs_symetric ) THEN IF ( show_matrix_test ) CALL verbose % log_info ( ucs4_ \"Checking if the matrix is symmetric...\" ) IF (. NOT . is_symmetric ( A )) THEN WRITE ( msg , '(2A)' ) trim ( this % method_type % name ), \" method requires a symmetric matrix.\" IF ( params % strict_mode ) THEN IF ( show_matrix_test ) CALL verbose % log_error ( msg ) STOP ELSE IF ( show_matrix_test ) CALL verbose % log_warning ( msg ) END IF END IF END IF IF ( show_matrix_test ) THEN CALL verbose % WRITE ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) CALL verbose % WRITE ( ucs4_ \"\" ) END IF END SUBROUTINE test_matrix SUBROUTINE Dealocate_IterativeParams ( this , params , success ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this TYPE ( IterativeParams ), INTENT ( INOUT ) :: params LOGICAL , OPTIONAL , INTENT ( OUT ) :: success INTEGER :: deallocate_status IF ( present ( success )) success = . TRUE . IF ( allocated ( params % x_init )) DEALLOCATE ( params % x_init , STAT = deallocate_status ) IF ( allocated ( params % L )) DEALLOCATE ( params % L , STAT = deallocate_status ) IF ( allocated ( params % U )) DEALLOCATE ( params % U , STAT = deallocate_status ) IF ( allocated ( params % D )) DEALLOCATE ( params % D , STAT = deallocate_status ) IF ( allocated ( params % residual )) DEALLOCATE ( params % residual , STAT = deallocate_status ) IF ( allocated ( params % p )) DEALLOCATE ( params % p , STAT = deallocate_status ) params % norm = NORM_2 params % fill_level = FILL_LEVEL_NONE IF ( deallocate_status /= 0 . AND . present ( success )) success = . FALSE . this % preconditioner_type = METHOD_PRECOND_NONE this % method_type = METHOD_ITERATIVE_NONE this % relaxation_factor = RELAXATION_FACTOR_NONE this % relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE this % requirements = IterativeMethodRequirements () END SUBROUTINE Dealocate_IterativeParams !====================== ! Solve the system !====================== FUNCTION IterativeMethod_solve ( this , A , b , params , verbose ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b TYPE ( IterativeParams ), INTENT ( INOUT ) :: params TYPE ( Logger ), OPTIONAL , INTENT ( INOUT ) :: verbose REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x0 , x_new INTEGER :: k , N , frequency INTEGER :: start_system_clock , end_system_clock , rate REAL ( dp ) :: elapsed_time LOGICAL :: show_info_solver LOGICAL :: show_iteration LOGICAL :: show_final N = size ( A , 1 ) x0 = params % x_init params % residual = b - matmul ( A , x0 ) params % norm_initial_residual = params % norm_function ( params % residual ) show_info_solver = . FALSE . show_iteration = . FALSE . show_final = . FALSE . frequency = 1 IF ( present ( verbose )) THEN IF ( verbose % show_info_solver ) show_info_solver = . TRUE . IF ( verbose % show_iteration ) show_iteration = . TRUE . IF ( verbose % show_final ) show_final = . TRUE . frequency = verbose % frequency END IF IF ( show_info_solver ) CALL log_solver_info ( this , params , verbose , N ) IF ( show_iteration ) CALL log_iteration_header ( verbose ) CALL system_clock ( start_system_clock , count_rate = rate ) DO k = 1 , params % max_iter params % k = k IF ( k == params % max_iter ) THEN EXIT END IF x_new = this % solve_method ( A , b , x0 , params ) params % residual = b - matmul ( A , x_new ) params % norm_residual = params % norm_function ( params % residual ) IF ( show_iteration . AND . mod ( k , frequency ) == 0 ) THEN CALL system_clock ( end_system_clock ) elapsed_time = REAL ( end_system_clock - start_system_clock , dp ) / REAL ( rate , dp ) CALL log_iteration_step ( verbose , k , params , elapsed_time ) END IF IF ( params % norm_residual < params % tol ) EXIT x0 = x_new END DO IF ( show_iteration ) CALL verbose % WRITE ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) IF ( show_final ) THEN CALL system_clock ( end_system_clock ) elapsed_time = REAL ( end_system_clock - start_system_clock , dp ) / REAL ( rate , dp ) CALL log_final_result ( verbose , k , params , x_new , elapsed_time , N ) END IF x = x_new END FUNCTION IterativeMethod_solve !====================== ! Log solver information !====================== SUBROUTINE log_solver_info ( solver , params , verbose , N ) TYPE ( IterativeMethod ), INTENT ( IN ) :: solver TYPE ( IterativeParams ), INTENT ( IN ) :: params TYPE ( Logger ), INTENT ( INOUT ) :: verbose INTEGER , INTENT ( IN ) :: N CHARACTER ( 10 ) :: date , time CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg CALL verbose % WRITE ( ucs4_ \"\" ) CALL verbose % WRITE ( center_with_fill ( \"Starting system solver\" , width = 100 , fill_char = \"=\" ), box_style = \"top\" ) CALL verbose % WRITE ( ucs4_ \"\" , box_style = \"middle\" ) ! call date_and_time(date,time,zone,values) CALL date_and_time ( DATE = date , TIME = time ) WRITE ( date , '(A)' ) date (: 4 ) // \"-\" // date ( 5 : 6 ) // \"-\" // date ( 7 : 8 ) WRITE ( time , '(A)' ) time (: 2 ) // \":\" // time ( 3 : 4 ) // \":\" // time ( 5 : 6 ) CALL log_field ( verbose , \"Date and time\" , trim ( date ) // \" \" // trim ( time )) IF ( solver % relaxation_factor % id == RELAXATION_FACTOR_OMEGA % id ) THEN CALL log_field ( verbose , \"Method used\" , trim ( solver % method_type % name ) // \" \" // trim ( solver % method_type % name2 )) WRITE ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , \": \" , trim ( solver % relaxation_factor % name ), & \" = \" , params % omega CALL verbose % log_info ( msg ) ELSE IF ( solver % relaxation_factor % id == RELAXATION_FACTOR_ALPHA % id ) THEN CALL log_field ( verbose , \"Method used\" , trim ( solver % method_type % name )) WRITE ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , \": \" , trim ( solver % relaxation_factor % name ), & \" = \" , params % alpha CALL verbose % log_info ( msg ) ELSE CALL log_field ( verbose , \"Method used\" , trim ( solver % method_type % name )) END IF IF ( solver % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN IF ( solver % relaxation_factor_preconditioner % id == RELAXATION_FACTOR_OMEGA % id ) THEN CALL log_field ( verbose , \"Preconditioner used\" , trim ( solver % preconditioner_type % name )) WRITE ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , \": \" , & trim ( solver % relaxation_factor_preconditioner % name ), \" = \" , params % omega CALL verbose % log_info ( msg ) ELSE CALL log_field ( verbose , \"Preconditioner used\" , trim ( solver % preconditioner_type % name )) END IF END IF IF ( solver % preconditioner_type % id == METHOD_PRECOND_ILU % id . OR . & solver % preconditioner_type % id == METHOD_PRECOND_ICF % id ) THEN IF ( params % fill_level % id /= FILL_LEVEL_NONE % id ) THEN CALL log_field ( verbose , \"Fill level used\" , trim ( params % fill_level % name )) ELSE CALL log_field ( verbose , \"Fill level used\" , \"basic \" // trim ( solver % preconditioner_type % name )) END IF ELSE IF ( solver % method_type % id == METHOD_SIP_ILU % id . OR . & solver % method_type % id == METHOD_SIP_ICF % id ) THEN IF ( params % fill_level % id /= FILL_LEVEL_NONE % id ) THEN CALL log_field ( verbose , \"Fill level used\" , trim ( params % fill_level % name )) ELSE CALL log_field ( verbose , \"Fill level used\" , \"basic \" // trim ( solver % method_type % name2 )) END IF END IF WRITE ( msg , '(A,T40,A,I0,A,I0)' ) \"System size\" , \": \" , N , \" x \" , N CALL verbose % log_info ( msg ) WRITE ( msg , '(A,T40,A,I0,A)' ) \"Memory used\" , \": \" , get_memory_kb (), \" KB\" CALL verbose % log_info ( msg ) CALL log_field ( verbose , \"Norme used\" , trim ( params % norm % name )) WRITE ( msg , '(A,T40,A, ES0.2)' ) \"Convergence criterion (Tolerance)\" , \": ||r|| < \" , params % tol CALL verbose % log_info ( msg ) CALL log_field ( verbose , \"Max iterations\" , params % max_iter ) WRITE ( msg , '(A,T36,A,ES0.7)' ) \"Initial residual norm\" , \": ||r0|| = \" , params % norm_initial_residual CALL verbose % log_detail ( msg ) CALL verbose % WRITE ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) CALL verbose % WRITE ( ucs4_ \"\" ) END SUBROUTINE log_solver_info SUBROUTINE log_iteration_header ( verbose ) CLASS ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg CALL verbose % WRITE ( center_with_fill ( \"Iterations\" , width = 100 , fill_char = \"=\" ), box_style = \"top\" ) CALL verbose % WRITE ( ucs4_ \"\" , box_style = \"middle\" ) WRITE ( msg , '(A,5X,A,5X,A,5X,A)' ) \"Iter\" , & \"Residual norm (||r||)\" , & \"Relative residual norm (||r||/||r0||)\" , & \"Time (s)\" CALL verbose % log_info ( msg ) CALL verbose % WRITE ( repeat ( ucs4_ \"-\" , 100 ), box_style = \"middle\" ) END SUBROUTINE log_iteration_header SUBROUTINE log_iteration_step ( verbose , k , params , elapsed_time ) CLASS ( Logger ), INTENT ( INOUT ) :: verbose INTEGER , INTENT ( IN ) :: k REAL ( dp ), INTENT ( IN ) :: elapsed_time TYPE ( IterativeParams ), INTENT ( IN ) :: params CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg INTEGER :: end_system_clock CALL system_clock ( end_system_clock ) WRITE ( msg , '(T2,I0,T15,ES0.7,T48,ES0.7,T79,ES0.7)' ) k , & params % norm_residual , & params % norm_residual / params % norm_initial_residual , & elapsed_time CALL verbose % log_time ( msg ) END SUBROUTINE log_iteration_step SUBROUTINE log_final_result ( verbose , k , params , x_new , elapsed_time , N ) CLASS ( Logger ), INTENT ( INOUT ) :: verbose INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: k REAL ( dp ), INTENT ( IN ) :: elapsed_time TYPE ( IterativeParams ), INTENT ( IN ) :: params REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_new CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg INTEGER :: end_system_clock INTEGER :: i CALL verbose % WRITE ( ucs4_ \"\" ) CALL verbose % WRITE ( center_with_fill ( \"Results\" , width = 100 , fill_char = \"=\" ), box_style = \"top\" ) CALL verbose % WRITE ( ucs4_ \" \" , box_style = \"middle\" ) IF ( k < params % max_iter ) THEN CALL log_field ( verbose , \"Status\" , \"CONVERGED\" ) WRITE ( msg , '(A,T40,A,ES0.7,A,ES0.1,A)' ) \"Final residual\" , \": ||r|| = \" , params % norm_residual , & \" < \" , params % tol , \" (convergence achieved)\" CALL verbose % log_info ( msg ) WRITE ( msg , '(A,T36,A,ES0.7)' ) \"Relative residual norm\" , \": ||r||/||r0|| = \" , & params % norm_residual / params % norm_initial_residual CALL verbose % log_detail ( msg ) CALL log_field ( verbose , \"Total iterations\" , k ) WRITE ( msg , '(A,T40,A,ES0.7)' ) \"Solution\" , \": x = [\" IF ( N < 6 ) THEN DO i = 1 , size ( x_new ) WRITE ( msg , '(2A,ES0.7)' ) trim ( msg ), \" \" , x_new ( i ) END DO ELSE WRITE ( msg , '(2A,ES0.7,3X,ES0.7,3X,ES0.7,3X,A,ES0.7,3X,ES0.7,3X,ES0.7,A)' ) trim ( msg ), \" \" , & x_new ( 1 ), x_new ( 2 ), x_new ( 3 ), x_new ( N - 3 ), x_new ( N - 2 ), x_new ( N - 1 ) END IF WRITE ( msg , '(2A,ES0.7)' ) trim ( msg ), \"]\" CALL verbose % log_info ( msg ) CALL system_clock ( end_system_clock ) WRITE ( msg , '(A,T40,A,ES0.7,A,I0)' ) \"Solver completed in \" , \": \" , & elapsed_time , \" seconds\" CALL verbose % log_info ( msg ) WRITE ( msg , '(A,T40,A,I0,A)' ) \"Memory used\" , \": \" , get_memory_kb (), \" KB\" CALL verbose % log_info ( msg ) ELSE CALL log_field ( verbose , \"Status\" , \"NOT CONVERGED\" ) WRITE ( msg , '(A,T40,A,ES0.7,A,ES0.1,A)' ) \"Final residual\" , \": ||r|| = \" , params % norm_residual , & \" >= \" , params % tol , \" (convergence not achieved)\" CALL verbose % log_info ( msg ) END IF CALL verbose % WRITE ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) END SUBROUTINE !====================== ! Solve methods !====================== !> Jacobi iterative method !> !> This subroutine implements the Jacobi method for solving linear systems. FUNCTION solve_Jacobi ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x INTEGER :: i , N N = size ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END FUNCTION solve_Jacobi !> Gauss-Seidel iterative method !> !> This subroutine implements the Gauss-Seidel method for solving linear systems. FUNCTION solve_Gauss_Seidel ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x INTEGER :: i , N N = size ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END FUNCTION solve_Gauss_Seidel !> Successive Over-Relaxation (SOR) iterative method !> !> This subroutine implements the SOR method for solving linear systems. FUNCTION solve_SOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x INTEGER :: i , N N = size ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO END FUNCTION solve_SOR !> Jacobi over-relaxation (JOR) iterative method !> !> This subroutine implements the Jacobi over-relaxation method for solving linear systems. FUNCTION solve_JOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x INTEGER :: i , N N = size ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO END FUNCTION solve_JOR !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete LU decomposition of the matrix A. FUNCTION solve_SIP_ILU ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: y , z IF (. NOT . allocated ( params % L ) . OR . . NOT . allocated ( params % U )) STOP \"ERROR :: Incomplete LU decomposition not initialized\" y = forward ( params % L , params % residual ) z = backward ( params % U , y ) x = x0 + params % omega * z END FUNCTION solve_SIP_ILU !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete Cholesky decomposition of the matrix A. FUNCTION solve_SIP_ICF ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: y , z IF (. NOT . allocated ( params % L )) STOP \"ERROR :: Incomplete LU decomposition not initialized\" y = forward ( params % L , params % residual ) z = backward ( transpose ( params % L ), y ) x = x0 + params % omega * z END FUNCTION solve_SIP_ICF !> Symmetric successive Over-Relaxation (SSOR) iterative method !> !> This subroutine implements the SSOR method for solving linear systems. FUNCTION solve_SSOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x_tmp INTEGER :: i , N N = size ( A , 1 ) ! forward DO i = 1 , N x_tmp ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x_tmp ( i ) = params % omega * ( x_tmp ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO ! backward DO i = N , 1 , - 1 x ( i ) = b ( i ) - dot_product ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - dot_product ( A ( i , i + 1 : N ), x ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x_tmp ( i )) + x_tmp ( i ) END DO END FUNCTION solve_SSOR !> Richardson iterative method !> !> This subroutine implements the Richardson method for solving linear systems. FUNCTION solve_Richardson ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: z_prec IF ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) THEN IF (. NOT . params % is_stationary ) THEN params % alpha = dot_product ( params % residual , params % residual ) / & dot_product ( params % residual , matmul ( A , params % residual )) END IF x = x0 + params % alpha * params % residual ELSE IF ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) IF (. NOT . params % is_stationary ) THEN params % alpha = dot_product ( params % residual , z_prec ) / & dot_product ( z_prec , matmul ( A , z_prec )) END IF x = x0 + params % alpha * z_prec END IF END FUNCTION solve_Richardson !> Conjugate Gradient iterative method !> !> This subroutine implements the Conjugate Gradient method for solving linear systems. FUNCTION solve_ConjugateGradient ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: z_prec IF ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) THEN IF ( params % k == 1 ) THEN params % p = params % residual ELSE IF ( params % k /= 1 ) THEN params % beta = dot_product ( params % residual , params % residual ) / params % old_dot_product params % p = params % residual + params % beta * params % p END IF params % alpha = dot_product ( params % residual , params % residual ) / dot_product ( params % p , matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , params % residual ) ELSE IF ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN IF ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . OR . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) params % p = z_prec ELSE IF ( params % k /= 1 ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , params % residual ) / params % old_dot_product params % p = z_prec + params % beta * params % p END IF params % alpha = dot_product ( z_prec , params % residual ) / dot_product ( params % p , matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , params % residual ) END IF END FUNCTION solve_ConjugateGradient !> Conjugate Residual iterative method !> !> This subroutine implements the Conjugate Residual method for solving linear systems. FUNCTION solve_ConjugateResidual ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: z_prec IF ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) THEN IF ( params % k == 1 ) THEN params % p = params % residual ELSE IF ( params % k /= 1 ) THEN params % beta = dot_product ( params % residual , matmul ( A , params % residual )) / params % old_dot_product params % p = params % residual + params % beta * params % p END IF params % alpha = dot_product ( params % residual , matmul ( A , params % residual )) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , matmul ( A , params % residual )) ELSE IF ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN IF ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . OR . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN params % p = params % precond ( this % preconditioner_type , params % residual ) z_prec = params % p ELSE IF ( params % k /= 1 ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , matmul ( A , params % residual )) / params % old_dot_product params % p = z_prec + params % beta * params % p END IF params % alpha = dot_product ( z_prec , matmul ( A , params % residual )) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , matmul ( A , params % residual )) END IF END FUNCTION solve_ConjugateResidual !> Conjugate Gradient on Normal Equations iterative method !> !> This subroutine implements the Conjugate Gradient on Normal Equations method (or Craig’s Method) for solving linear systems. FUNCTION solve_CGNR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: z_prec REAL ( dp ), DIMENSION ( size ( A , 1 )) :: AT_r IF ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) THEN IF ( params % k == 1 ) THEN AT_r = matmul ( transpose ( A ), params % residual ) params % p = AT_r ELSE IF ( params % k /= 1 ) THEN AT_r = matmul ( transpose ( A ), params % residual ) params % beta = dot_product ( AT_r , AT_r ) / params % old_dot_product params % p = AT_r + params % beta * params % p END IF params % alpha = dot_product ( AT_r , AT_r ) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( AT_r , AT_r ) ELSE IF ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN IF ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . OR . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN AT_r = matmul ( transpose ( A ), params % residual ) z_prec = params % precond ( this % preconditioner_type , AT_r ) params % p = z_prec ELSE IF ( params % k /= 1 ) THEN AT_r = matmul ( transpose ( A ), params % residual ) z_prec = params % precond ( this % preconditioner_type , AT_r ) params % beta = dot_product ( z_prec , AT_r ) / params % old_dot_product params % p = z_prec + params % beta * params % p END IF params % alpha = dot_product ( z_prec , AT_r ) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , AT_r ) END IF END FUNCTION solve_CGNR !> Conjugate Gradient on Normal Residual iterative method !> !> This subroutine implements the Conjugate Gradient on Normal Residual method for solving linear systems. FUNCTION solve_CGNE ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: z_prec IF ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) THEN IF ( params % k == 1 ) THEN params % p = matmul ( transpose ( A ), params % residual ) ELSE IF ( params % k /= 1 ) THEN params % beta = dot_product ( params % residual , params % residual ) / params % old_dot_product params % p = matmul ( transpose ( A ), params % residual ) + params % beta * params % p END IF params % alpha = dot_product ( params % residual , params % residual ) / & dot_product ( params % p , params % p ) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , params % residual ) ELSE IF ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) THEN IF ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . OR . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) params % p = matmul ( transpose ( A ), z_prec ) ELSE IF ( params % k /= 1 ) THEN z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , params % residual ) / params % old_dot_product params % p = matmul ( transpose ( A ), z_prec ) + params % beta * params % p END IF params % alpha = dot_product ( z_prec , params % residual ) / & dot_product ( params % p , params % p ) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , params % residual ) END IF END FUNCTION solve_CGNE FUNCTION solve_GMRES ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x ! in progress END FUNCTION solve_GMRES END MODULE NAFPack_Iterative_methods","tags":"","url":"sourcefile\\nafpack_iterative_methods.f90.html"},{"title":"NAFPack_Iterative_Params.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_params.f90~~EfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_params.f90~~AfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Iterative_Params USE NAFPack_constant USE NAFPack_Iterative_types USE NAFPack_Preconditioners USE NAFPack_matrix_decomposition IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: IterativeParams PUBLIC :: ApplyPreconditioner TYPE :: IterativeParams ! Solution and initial guess REAL ( dp ), DIMENSION (:), ALLOCATABLE :: x_init ! Preconditioner matrices REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: L , U , D ! Algorithm vectors REAL ( dp ), DIMENSION (:), ALLOCATABLE :: p REAL ( dp ), DIMENSION (:), ALLOCATABLE :: residual ! Norms and tolerances REAL ( dp ) :: norm_residual REAL ( dp ) :: norm_initial_residual = 1.d0 REAL ( dp ) :: tol = 1.0d-12 ! Iteration control INTEGER :: k = 0 INTEGER :: max_iter = 1000 ! Method parameters REAL ( dp ) :: omega = 1.d0 REAL ( dp ) :: alpha = 1.d0 REAL ( dp ) :: beta = 1.d0 ! ILU/IC fill level TYPE ( FILL_LEVEL_USED ) :: fill_level = FILL_LEVEL_NONE ! Flags LOGICAL :: is_stationary = . TRUE . LOGICAL :: strict_mode = . FALSE . ! Miscellaneous REAL ( dp ) :: old_dot_product = 0.d0 TYPE ( Norm_used ) :: norm = NORM_2 ! Preconditioner procedure pointer PROCEDURE ( ApplyPreconditioner ), PASS ( params ), POINTER :: precond CONTAINS PROCEDURE :: norm_function END TYPE IterativeParams CONTAINS FUNCTION ApplyPreconditioner ( params , method , x ) RESULT ( y ) CLASS ( IterativeParams ), INTENT ( IN ) :: params CLASS ( MethodPreconditioner ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x REAL ( dp ), DIMENSION ( size ( params % x_init )) :: y SELECT CASE ( method % id ) CASE ( METHOD_PRECOND_JACOBI % id ) IF (. NOT . allocated ( params % D )) STOP \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) CASE ( METHOD_PRECOND_GS % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) CASE ( METHOD_PRECOND_SOR % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) CASE ( METHOD_PRECOND_JOR % id ) IF (. NOT . allocated ( params % D )) STOP \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) CASE ( METHOD_PRECOND_ILU % id ) IF (. NOT . allocated ( params % L ) . OR . & . NOT . allocated ( params % U )) STOP \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , x ) y = backward ( params % U , y ) CASE ( METHOD_PRECOND_ICF % id ) IF (. NOT . allocated ( params % L )) STOP \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) y = backward ( transpose ( params % L ), y ) CASE ( METHOD_PRECOND_SSOR % id ) IF (. NOT . allocated ( params % L ) . OR . & . NOT . allocated ( params % D )) STOP \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , x ) y = matmul ( params % D , y ) y = backward ( transpose ( params % L ), y ) CASE DEFAULT STOP \"ERROR :: Unknown preconditioner method\" END SELECT END FUNCTION ApplyPreconditioner FUNCTION norm_function ( this , vector ) RESULT ( RESULT ) CLASS ( IterativeParams ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: vector REAL ( dp ) :: RESULT SELECT CASE ( this % norm % id ) CASE ( NORM_1 % id ) RESULT = sum ( abs ( vector )) CASE ( NORM_2 % id ) RESULT = norm2 ( vector ) CASE ( NORM_INF % id ) RESULT = maxval ( abs ( vector )) CASE DEFAULT STOP \"ERROR :: Unknown norm type\" END SELECT END FUNCTION norm_function END MODULE NAFPack_Iterative_Params","tags":"","url":"sourcefile\\nafpack_iterative_params.f90.html"},{"title":"NAFPack_meshgrid.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid.f90~~EfferentGraph sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for creating a meshgrid from two vectors !> !> This module provides a subroutine to create a meshgrid. MODULE NAFPack_meshgrid USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: meshgrid CONTAINS !> Make N-dimensional meshgrid from two vectors **x_vector** and **y_vector** SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( size ( y_vector ), size ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid END MODULE NAFPack_meshgrid","tags":"","url":"sourcefile\\nafpack_meshgrid.f90.html"},{"title":"NAFPack_Direct_methode.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_direct_methode.f90~~EfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_direct_methode.f90~~AfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for direct methods in NAFPack MODULE NAFPack_Direct_method USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matrix_properties USE NAFPack_Direct_types USE NAFPack_matrix_tools IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: DirectMethod PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky PUBLIC :: METHOD_QR PUBLIC :: METHOD_TDMA PUBLIC :: METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT , QR_GRAM_SCHMIDT_Modified TYPE :: DirectMethod PRIVATE TYPE ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE TYPE ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT LOGICAL :: use_partial_pivot = . FALSE . LOGICAL :: use_total_pivot = . FALSE . TYPE ( DirectMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Direct ), PASS ( this ), POINTER :: solve_method => null () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: set_qr_method => set_qr_method PROCEDURE :: solve => DirectMethod_solve PROCEDURE :: test_matrix => test_matrix END TYPE DirectMethod ABSTRACT INTERFACE FUNCTION solve_interface_Direct ( this , A , b ) RESULT ( x ) IMPORT :: dp IMPORT :: DirectMethod CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x END FUNCTION solve_interface_Direct END INTERFACE CONTAINS SUBROUTINE set_method ( this , method , set_pivot_partial , set_pivot_total ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this TYPE ( MethodTypeDirect ), INTENT ( IN ) :: method LOGICAL , OPTIONAL :: set_pivot_partial , set_pivot_total this % use_total_pivot = . FALSE . this % use_partial_pivot = . FALSE . this % requirements = DirectMethodRequirements () SELECT CASE ( method % id ) CASE ( METHOD_Gauss % id ) this % solve_method => solve_Gauss this % method_type = METHOD_Gauss this % requirements % needs_square = . TRUE . CASE ( METHOD_Gauss_JORDAN % id ) this % solve_method => solve_GaussJordan this % method_type = METHOD_Gauss_JORDAN this % requirements % needs_square = . TRUE . CASE ( METHOD_LU % id ) this % solve_method => solve_LU this % method_type = METHOD_LU this % requirements % needs_square = . TRUE . CASE ( METHOD_LDU % id ) this % solve_method => solve_LDU this % method_type = METHOD_LDU this % requirements % needs_square = . TRUE . this % requirements % needs_non_zero_diag = . TRUE . CASE ( METHOD_CHOLESKY % id ) this % solve_method => solve_Cholesky this % method_type = METHOD_CHOLESKY this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_LDL_Cholesky % id ) this % solve_method => solve_LDL_Cholesky this % method_type = METHOD_LDL_Cholesky this % requirements % needs_square = . TRUE . this % requirements % needs_symmetric = . TRUE . CASE ( METHOD_QR % id ) this % solve_method => solve_QR this % method_type = METHOD_QR this % requirements % needs_square = . TRUE . CASE ( METHOD_TDMA % id ) this % solve_method => solve_TDMA this % method_type = METHOD_TDMA this % requirements % needs_square = . TRUE . this % requirements % needs_tridiagonal = . TRUE . this % requirements % needs_non_zero_diag = . TRUE . CASE ( METHOD_FADDEEV_LEVERRIER % id ) this % solve_method => solve_Faddeev_Leverrier this % method_type = METHOD_FADDEEV_LEVERRIER this % requirements % needs_square = . TRUE . CASE DEFAULT STOP \"ERROR :: Unknown method direct\" END SELECT IF ( present ( set_pivot_partial )) THEN IF ( set_pivot_partial ) this % use_partial_pivot = . TRUE . ELSE IF ( present ( set_pivot_total )) THEN IF ( set_pivot_total ) this % use_total_pivot = . TRUE . END IF END SUBROUTINE set_method SUBROUTINE set_qr_method ( this , qr_method ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this TYPE ( MethodQR ), INTENT ( IN ) :: qr_method this % qr_method = qr_method END SUBROUTINE set_qr_method SUBROUTINE test_matrix ( this , A , strict_mode ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: strict_mode LOGICAL :: strict strict = . FALSE . IF ( present ( strict_mode )) strict = strict_mode IF ( this % requirements % needs_square ) THEN PRINT * , \"Checking if the matrix is square...\" IF (. NOT . is_square_matrix ( A )) THEN IF ( strict ) THEN PRINT * , \"ERROR :: \" // this % method_type % name // \" method requires a square matrix.\" STOP ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a square matrix.\" END IF END IF END IF IF ( this % requirements % needs_SPD ) THEN PRINT * , \"Checking if the matrix is symmetric positive definite (SPD)...\" IF (. NOT . is_SPD ( A )) THEN IF ( strict ) THEN PRINT * , \"ERROR :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" STOP ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" END IF END IF END IF IF ( this % requirements % needs_non_zero_diag ) THEN PRINT * , \"Checking if the matrix has a non-zero diagonal...\" IF (. NOT . is_non_zero_diagonal ( A )) THEN IF ( strict ) THEN PRINT * , \"ERROR :: \" // this % method_type % name // \" method requires a non-zero diagonal matrix.\" STOP ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a non-zero diagonal matrix.\" END IF END IF END IF IF ( this % requirements % needs_tridiagonal ) THEN PRINT * , \"Checking if the matrix is tridiagonal...\" IF (. NOT . is_tridiagonal ( A )) THEN IF ( strict ) THEN PRINT * , \"ERROR :: \" // this % method_type % name // \" method requires a tridiagonal matrix.\" STOP ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a tridiagonal matrix.\" END IF END IF END IF IF ( this % requirements % needs_symmetric ) THEN PRINT * , \"Checking if the matrix is symmetric...\" IF (. NOT . is_symmetric ( A )) THEN IF ( strict ) THEN PRINT * , \"ERROR :: \" // this % method_type % name // \" method requires a symmetric matrix.\" STOP ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric matrix.\" END IF END IF END IF END SUBROUTINE test_matrix FUNCTION DirectMethod_solve ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x IF (. NOT . associated ( this % solve_method )) THEN STOP \"ERROR :: No solution method has been set. Call set_method first.\" END IF x = this % solve_method ( A , b ) END FUNCTION DirectMethod_solve FUNCTION solve_Gauss ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: P REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: Q REAL ( dp ), DIMENSION ( size ( b )) :: b_tmp INTEGER :: i , k , N , M , allocate_status REAL ( dp ) :: pivot , multiplier N = size ( A , 1 ) M = size ( A , 2 ) IF ( this % use_partial_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" CALL pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) ELSE IF ( this % use_total_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) ALLOCATE ( Q ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) CALL pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) ELSE A_tmp = A b_tmp = b END IF DO k = 1 , N - 1 pivot = A_tmp ( k , k ) IF ( abs ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" DO i = k + 1 , N multiplier = A_tmp ( i , k ) / pivot A_tmp ( i , k ) = 0 ! Vectorized operation A_tmp ( i , k + 1 : N ) = A_tmp ( i , k + 1 : N ) - multiplier * A_tmp ( k , k + 1 : N ) b_tmp ( i ) = b_tmp ( i ) - multiplier * b_tmp ( k ) END DO END DO x = backward ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) x = matmul ( Q , x ) END FUNCTION solve_Gauss FUNCTION solve_GaussJordan ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: P REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: Q REAL ( dp ), DIMENSION ( size ( b )) :: b_tmp INTEGER :: i , k , N , M , allocate_status REAL ( dp ) :: pivot , factor N = size ( A_tmp , 1 ) M = size ( A_tmp , 2 ) IF ( this % use_partial_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" CALL pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) ELSE IF ( this % use_total_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) ALLOCATE ( Q ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) CALL pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) ELSE A_tmp = A b_tmp = b END IF DO k = 1 , N pivot = A_tmp ( k , k ) IF ( abs ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" ! Normalisation du pivot A_tmp ( k , :) = A_tmp ( k , :) / pivot b_tmp ( k ) = b_tmp ( k ) / pivot ! Élimination dans toutes les autres lignes DO i = 1 , N IF ( i /= k ) THEN factor = A_tmp ( i , k ) A_tmp ( i , :) = A_tmp ( i , :) - factor * A_tmp ( k , :) b_tmp ( i ) = b_tmp ( i ) - factor * b_tmp ( k ) END IF END DO END DO x = b_tmp IF ( this % use_total_pivot ) x = matmul ( Q , x ) END FUNCTION solve_GaussJordan FUNCTION solve_LU ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: L , U REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: P REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: Q REAL ( dp ), DIMENSION ( size ( b )) :: b_tmp INTEGER :: N , M , allocate_status N = size ( A , 1 ) M = size ( A_tmp , 2 ) IF ( this % use_partial_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" CALL pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) ELSE IF ( this % use_total_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) ALLOCATE ( Q ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) CALL pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) ELSE A_tmp = A b_tmp = b END IF CALL LU_decomposition ( A_tmp , L , U ) x = forward ( L , b_tmp ) x = backward ( U , x ) IF ( this % use_total_pivot ) x = matmul ( Q , x ) END FUNCTION solve_LU FUNCTION solve_LDU ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: L , D , U REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: P REAL ( dp ), DIMENSION (:, :), ALLOCATABLE :: Q REAL ( dp ), DIMENSION ( size ( b )) :: b_tmp INTEGER :: N , M , allocate_status N = size ( A , 1 ) M = size ( A , 2 ) IF ( this % use_partial_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" CALL pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) ELSE IF ( this % use_total_pivot ) THEN ALLOCATE ( P ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) ALLOCATE ( Q ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) CALL pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) ELSE A_tmp = A b_tmp = b END IF CALL LDU_decomposition ( A_tmp , L , D , U ) x = forward ( L , b_tmp ) x = forward ( D , x ) x = backward ( U , x ) IF ( this % use_total_pivot ) x = matmul ( Q , x ) END FUNCTION solve_LDU FUNCTION solve_Cholesky ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: L CALL Cholesky_decomposition ( A , L ) x = forward ( L , b ) x = backward ( transpose ( L ), x ) END FUNCTION solve_Cholesky FUNCTION solve_LDL_Cholesky ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: L , D CALL LDL_Cholesky_decomposition ( A , L , D ) x = forward ( L , b ) x = forward ( D , x ) x = backward ( transpose ( L ), x ) END FUNCTION solve_LDL_Cholesky FUNCTION solve_QR ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: Q , R SELECT CASE ( this % qr_method % id ) CASE ( QR_HOUSEHOLDER % id ) CALL QR_Householder_decomposition ( A , Q , R ) CASE ( QR_GIVENS % id ) CALL QR_Givens_decomposition ( A , Q , R ) CASE ( QR_GRAM_SCHMIDT % id ) CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) CASE ( QR_GRAM_SCHMIDT_Modified % id ) CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) CASE DEFAULT STOP \"ERROR :: Unknown QR method\" END SELECT x = backward ( R , matmul ( transpose ( Q ), b )) END FUNCTION solve_QR FUNCTION solve_TDMA ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 )) :: alpha , beta REAL ( dp ) :: denom INTEGER :: n , i N = size ( A , 1 ) alpha = 0.0_dp beta = 0.0_dp alpha ( 1 ) = A ( 1 , 2 ) / A ( 1 , 1 ) beta ( 1 ) = b ( 1 ) / A ( 1 , 1 ) DO i = 2 , N denom = A ( i , i ) - A ( i , i - 1 ) * alpha ( i - 1 ) IF ( i < N ) alpha ( i ) = A ( i , i + 1 ) / denom beta ( i ) = ( b ( i ) - A ( i , i - 1 ) * beta ( i - 1 )) / denom END DO x ( n ) = beta ( n ) DO i = n - 1 , 1 , - 1 x ( i ) = beta ( i ) - alpha ( i ) * x ( i + 1 ) END DO END FUNCTION solve_TDMA FUNCTION solve_Faddeev_Leverrier ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( size ( A , 1 )) :: x REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 2 )) :: Ainv REAL ( dp ), DIMENSION ( size ( A , 1 ) + 1 ) :: c LOGICAL :: success CALL Faddeev_Leverrier ( A , c , Ainv = Ainv , success = success , check = . FALSE .) IF (. NOT . success ) THEN PRINT * , \"WARNING :: Faddeev-Leverrier method failed, using LU decomposition instead\" x = solve_LU ( this , A , b ) ELSE x = matmul ( Ainv , b ) END IF END FUNCTION solve_Faddeev_Leverrier END MODULE NAFPack_Direct_method","tags":"","url":"sourcefile\\nafpack_direct_methode.f90.html"},{"title":"NAFPack_constant.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_constant.f90~~AfferentGraph sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_config.f90 NAFPack_config.f90 sourcefile~nafpack_config.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_market.f90 NAFPack_matrix_market.f90 sourcefile~nafpack_matrix_market.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for defining constants used in NAFPack !> !> This module includes mathematical constants, colors for terminal output, !> and other parameters that are used throughout the NAFPack library. MODULE NAFPack_constant USE , INTRINSIC :: iso_fortran_env , ONLY : sp => real32 , dp => real64 , & isp => int32 , idp => int64 , & output_unit IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: pi , im , epsi , kmax , sp , dp , epsi_test , idp , isp , int_inf , output_unit PUBLIC :: status_len PUBLIC :: red_color , green_color , yellow_color , blue_color , white_color , cyan_color , purple_color , reset_color PUBLIC :: red_color_ucs4 , green_color_ucs4 , yellow_color_ucs4 , blue_color_ucs4 , & white_color_ucs4 , cyan_color_ucs4 , purple_color_ucs4 , reset_color_ucs4 PUBLIC :: ascii , ucs4 PUBLIC :: NAF_SUCCESS , NAF_ERROR_DIMENSION , NAF_ERROR_SINGULAR , NAF_ERROR_CONVERGENCE , NAF_ERROR_MEMORY , & NAF_ERROR_INVALID_METHOD PUBLIC :: TOL_PIVOT , TOL_CONVERGENCE !>  \\pi  constant REAL ( dp ), PARAMETER :: pi = acos ( - 1.d0 ) !> Imaginary unit  i&#94;2 = -1  COMPLEX ( dp ), PARAMETER :: im = ( 0.d0 , 1.d0 ) !> Small  \\epsilon  value REAL ( dp ), PARAMETER :: epsi = 1.d-12 , epsi_test = 1.d-6 !> INTEGER , PARAMETER :: int_inf = huge ( 1 ) !> Maximum number of iterations for iterative methods INTEGER , PARAMETER :: kmax = 10000 !> len of status messages CHARACTER ( LEN =* ), PARAMETER :: status_len = repeat ( \" \" , 15 ) INTEGER , PARAMETER :: ascii = selected_char_kind ( 'ascii' ) INTEGER , PARAMETER :: ucs4 = selected_char_kind ( 'ISO_10646' ) !> red colors for terminal output CHARACTER ( len = 10 ) :: red_color = char ( 27 ) // \"[31m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: red_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[31m\" !> green colors for terminal output CHARACTER ( len = 10 ) :: green_color = char ( 27 ) // \"[32m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: green_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[32m\" !> yellow colors for terminal output CHARACTER ( len = 10 ) :: yellow_color = char ( 27 ) // \"[33m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: yellow_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[33m\" !> blue colors for terminal output CHARACTER ( len = 10 ) :: blue_color = char ( 27 ) // \"[34m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: blue_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[34m\" !> purple colors for terminal output CHARACTER ( len = 10 ) :: purple_color = char ( 27 ) // \"[35m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: purple_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[35m\" !> cyan colors for terminal output CHARACTER ( len = 10 ) :: cyan_color = char ( 27 ) // \"[36m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: cyan_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[36m\" !> white colors for terminal output CHARACTER ( len = 10 ) :: white_color = char ( 27 ) // \"[37m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: white_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[37m\" !> reset colors for terminal output CHARACTER ( len = 10 ) :: reset_color = char ( 27 ) // \"[0m\" CHARACTER ( KIND = ucs4 , LEN = 10 ), PARAMETER :: reset_color_ucs4 = char ( 27 , KIND = ucs4 ) // ucs4_ \"[0m\" !> Error codes for better error handling INTEGER , PARAMETER :: NAF_SUCCESS = 0 INTEGER , PARAMETER :: NAF_ERROR_DIMENSION = 1 INTEGER , PARAMETER :: NAF_ERROR_SINGULAR = 2 INTEGER , PARAMETER :: NAF_ERROR_CONVERGENCE = 3 INTEGER , PARAMETER :: NAF_ERROR_MEMORY = 4 INTEGER , PARAMETER :: NAF_ERROR_INVALID_METHOD = 5 !> Improved tolerance parameters REAL ( dp ), PARAMETER :: TOL_PIVOT = 1.0e-14_dp REAL ( dp ), PARAMETER :: TOL_CONVERGENCE = 1.0e-12_dp END MODULE NAFPack_constant","tags":"","url":"sourcefile\\nafpack_constant.f90.html"},{"title":"NAFPack_matrix_tools.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_tools.f90~~EfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_tools.f90~~AfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_matrix_tools USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE ( TYPE , EXTERNAL ) CONTAINS SUBROUTINE Faddeev_Leverrier ( A , c , Ainv , success , check ) INTEGER , PARAMETER :: dp = kind ( 1.0d0 ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: c REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )), OPTIONAL , INTENT ( OUT ) :: Ainv LOGICAL , OPTIONAL , INTENT ( OUT ) :: success REAL ( dp ), DIMENSION ( size ( A , 1 ), size ( A , 1 )) :: Bk , I , B_Nm1 , AB LOGICAL :: do_check = . TRUE . INTEGER :: N , k N = size ( A , 1 ) IF ( present ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is square and size of c is correct\" IF ( size ( A , 2 ) /= N . OR . size ( c ) < N + 1 ) THEN PRINT * , \"Error : Matrix A must be square and size of c must be at least N+1\" STOP END IF END IF ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I DO k = 2 , N AB = matmul ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / REAL ( k , dp ) Bk = AB + c ( k + 1 ) * I IF ( k == N - 1 . AND . present ( Ainv )) B_Nm1 = - Bk END DO IF ( present ( Ainv ) . AND . present ( success )) THEN IF ( abs ( c ( N + 1 )) < 1.0e-12_dp ) THEN success = . FALSE . Ainv = 0.0_dp ELSE success = . TRUE . Ainv = B_Nm1 / c ( N + 1 ) END IF ELSE IF ( present ( Ainv )) THEN IF ( abs ( c ( N + 1 )) < 1.0e-12_dp ) THEN Ainv = 0.0_dp ELSE Ainv = B_Nm1 / c ( N + 1 ) END IF END IF END SUBROUTINE Faddeev_Leverrier END MODULE NAFPack_matrix_tools","tags":"","url":"sourcefile\\nafpack_matrix_tools.f90.html"},{"title":"NAFPack_Logger_mod.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_logger_mod.f90~~EfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_logger_mod.f90~~AfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> MODULE NAFPack_Logger_mod USE NAFPack_constant IMPLICIT NONE ( TYPE , EXTERNAL ) PRIVATE PUBLIC :: Logger PUBLIC :: Format_file PUBLIC :: FORMAT_FILE_BIN , FORMAT_FILE_TXT , FORMAT_FILE_CSV , FORMAT_FILE_LOG , FORMAT_FILE_TSV PUBLIC :: FORMAT_FILE_JSON , FORMAT_FILE_XML , FORMAT_FILE_YAML PUBLIC :: log_field PUBLIC :: center_with_fill TYPE :: Format_file INTEGER :: id = 1 CHARACTER ( LEN = 10 ) :: format_name = \"txt\" CHARACTER ( LEN = 100 ) :: format_description = \"Text file format\" END TYPE Format_file TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_BIN = Format_file ( 0 , \"binary\" , \"Binary file format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_TXT = Format_file ( 1 , \"txt\" , \"Text file format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_CSV = Format_file ( 2 , \"csv\" , \"Comma-separated values format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_LOG = Format_file ( 3 , \"log\" , \"Log file format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_TSV = Format_file ( 4 , \"tsv\" , \"Tab-separated values format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_JSON = Format_file ( 5 , \"json\" , \"JSON file format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_XML = Format_file ( 6 , \"xml\" , \"XML file format\" ) TYPE ( Format_file ), PARAMETER :: FORMAT_FILE_YAML = Format_file ( 7 , \"yaml\" , \"YAML file format\" ) TYPE :: Logger INTEGER :: verbosity_level = 1 LOGICAL :: to_terminal = . TRUE . LOGICAL :: to_file = . FALSE . INTEGER :: frequency = 10 CHARACTER ( LEN = 100 ) :: filename = \"Log\" TYPE ( Format_file ) :: file_format = FORMAT_FILE_LOG INTEGER :: file_unit = 99 CHARACTER ( LEN = 100 ) :: message = \"Default log message\" LOGICAL :: show_Logger_initialization = . TRUE . LOGICAL :: show_matrix_test = . TRUE . LOGICAL :: show_info_solver = . TRUE . LOGICAL :: show_iteration = . TRUE . LOGICAL :: show_final = . TRUE . CONTAINS PROCEDURE :: init => init_logger PROCEDURE :: log_info PROCEDURE :: log_detail PROCEDURE :: log_warning PROCEDURE :: log_error PROCEDURE :: log_time PROCEDURE :: WRITE => write_output PROCEDURE :: CLOSE => close_logger END TYPE Logger INTERFACE log_field MODULE PROCEDURE log_field_str , & log_field_real , & log_field_int , & log_field_ucs4 , & log_field_logical END INTERFACE log_field CONTAINS !========================================================================== SUBROUTINE init_logger ( this ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg IF ( this % to_file ) THEN OPEN ( UNIT = this % file_unit , FILE = trim ( this % filename ) // \".\" // this % file_format % format_name , STATUS = 'REPLACE' , & ACTION = 'WRITE' , ENCODING = 'UTF-8' ) END IF IF ( this % to_terminal ) THEN OPEN ( output_unit , encoding = 'UTF-8' ) END IF IF ( this % show_Logger_initialization ) THEN CALL this % WRITE ( center_with_fill ( \"NAFPack Logger initialized\" , width = 100 , fill_char = \"=\" ), box_style = \"top\" ) CALL this % WRITE ( ucs4_ \"\" , box_style = \"middle\" ) CALL log_field ( this , \"Verbosity level\" , this % verbosity_level ) CALL log_field ( this , \"Output to terminal\" , this % to_terminal ) CALL log_field ( this , \"Output to file\" , this % to_file ) IF ( this % to_file ) THEN CALL log_field ( this , \"File unit\" , this % file_unit ) CALL log_field ( this , \"File format\" , this % file_format % format_name ) CALL log_field ( this , \"File name\" , trim ( this % filename ) // \".\" // trim ( this % file_format % format_name )) END IF CALL this % WRITE ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) CALL this % WRITE ( ucs4_ \"\" ) END IF END SUBROUTINE init_logger !========================================================================== SUBROUTINE log_info ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg IF ( this % verbosity_level >= 2 ) CALL this % WRITE ( msg , ucs4_ \"INFO\" , blue_color_ucs4 ) END SUBROUTINE log_info SUBROUTINE log_detail ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg IF ( this % verbosity_level >= 3 ) CALL this % WRITE ( ucs4_ \"    \" // msg , ucs4_ \"DETAIL\" , green_color_ucs4 ) END SUBROUTINE log_detail SUBROUTINE log_warning ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg IF ( this % verbosity_level >= 1 ) CALL this % WRITE ( msg , ucs4_ \"WARNING\" , yellow_color_ucs4 ) END SUBROUTINE log_warning SUBROUTINE log_error ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg IF ( this % verbosity_level >= 1 ) CALL this % WRITE ( msg , ucs4_ \"ERROR\" , red_color_ucs4 ) END SUBROUTINE log_error SUBROUTINE log_time ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg CHARACTER ( LEN = 10 ) :: time CHARACTER ( KIND = ucs4 , LEN = 10 ) :: time_ucs4 CALL date_and_time ( TIME = time ) WRITE ( time_ucs4 , '(A)' ) time (: 2 ) // \":\" // time ( 3 : 4 ) // \":\" // time ( 5 : 6 ) IF ( this % verbosity_level >= 2 ) CALL this % WRITE ( msg , time_ucs4 , purple_color_ucs4 ) END SUBROUTINE log_time !========================================================================== SUBROUTINE write_output ( this , msg , name_level , color_level , box_style ) CLASS ( Logger ), INTENT ( IN ) :: this CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: msg CHARACTER ( KIND = ucs4 , LEN =* ), OPTIONAL , INTENT ( IN ) :: name_level CHARACTER ( KIND = ucs4 , LEN =* ), OPTIONAL , INTENT ( IN ) :: color_level CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: box_style CHARACTER ( KIND = ucs4 , LEN = 100 ) :: info_char CHARACTER ( LEN = 4 ) :: box_char = \" \" IF ( present ( box_style )) THEN SELECT CASE ( trim ( adjustl ( box_style ))) CASE ( \"top\" ) box_char = \"╔\" CASE ( \"bottom\" ) box_char = \"╚\" CASE ( \"middle\" ) box_char = \"║ \" CASE ( \"None\" ) box_char = \" \" CASE DEFAULT box_char = \" \" END SELECT END IF info_char = \"\" IF ( this % to_file ) THEN IF ( present ( name_level )) THEN info_char = ucs4_ \"[\" // trim ( name_level ) // ucs4_ \"] \" WRITE ( this % file_unit , '(A, T15, \"║ \", A)' ) trim ( info_char ), trim ( msg ) ELSE IF ( present ( box_style )) THEN WRITE ( this % file_unit , '(T15, A, A)' ) trim ( box_char ), trim ( msg ) ELSE WRITE ( this % file_unit , '(A)' ) trim ( msg ) END IF END IF END IF IF ( this % to_terminal ) THEN IF ( present ( name_level )) THEN IF ( present ( color_level )) THEN info_char = ucs4_ \"[\" // trim ( color_level ) // trim ( name_level ) // trim ( reset_color_ucs4 ) // ucs4_ \"] \" ELSE info_char = ucs4_ \"[\" // trim ( name_level ) // ucs4_ \"] \" END IF WRITE ( output_unit , '(A, T24, \"║ \", A)' ) trim ( info_char ), trim ( msg ) ELSE IF ( present ( box_style )) THEN WRITE ( output_unit , '(T15, A, A)' ) trim ( box_char ), trim ( msg ) ELSE WRITE ( output_unit , '(A)' ) trim ( msg ) END IF END IF END IF END SUBROUTINE write_output !========================================================================== SUBROUTINE close_logger ( this ) CLASS ( Logger ), INTENT ( INOUT ) :: this IF ( this % to_file ) CLOSE ( this % file_unit ) END SUBROUTINE close_logger !========================================================================== SUBROUTINE log_field_str ( verbose , label , VALUE ) TYPE ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( * ), INTENT ( IN ) :: label , VALUE CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg WRITE ( msg , '(A, T40, 2A)' ) trim ( label ), \": \" , trim ( VALUE ) CALL verbose % log_info ( msg ) END SUBROUTINE log_field_str SUBROUTINE log_field_ucs4 ( verbose , label , VALUE ) TYPE ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( * ), INTENT ( IN ) :: label CHARACTER ( KIND = ucs4 , LEN =* ), INTENT ( IN ) :: VALUE CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg WRITE ( msg , '(A, T40, 2A)' ) trim ( label ), \": \" , trim ( VALUE ) CALL verbose % log_info ( msg ) END SUBROUTINE log_field_ucs4 SUBROUTINE log_field_int ( verbose , label , VALUE ) TYPE ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( * ), INTENT ( IN ) :: label INTEGER , INTENT ( IN ) :: VALUE CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg WRITE ( msg , '(A, T40, A, I0)' ) trim ( label ), \": \" , VALUE CALL verbose % log_info ( msg ) END SUBROUTINE log_field_int SUBROUTINE log_field_real ( verbose , label , VALUE ) TYPE ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( * ), INTENT ( IN ) :: label REAL ( dp ), INTENT ( IN ) :: VALUE CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg WRITE ( msg , '(A, T40, A, ES0.7)' ) trim ( label ), \": \" , VALUE CALL verbose % log_info ( msg ) END SUBROUTINE log_field_real SUBROUTINE log_field_logical ( verbose , label , VALUE ) TYPE ( Logger ), INTENT ( INOUT ) :: verbose CHARACTER ( * ), INTENT ( IN ) :: label LOGICAL , INTENT ( IN ) :: VALUE CHARACTER ( KIND = ucs4 , LEN = 100 ) :: msg WRITE ( msg , '(A, T40, A, L)' ) trim ( label ), \": \" , VALUE CALL verbose % log_info ( msg ) END SUBROUTINE log_field_logical FUNCTION center_with_fill ( text , width , fill_char ) RESULT ( centered_text ) CHARACTER ( LEN =* ), INTENT ( IN ) :: text INTEGER , INTENT ( IN ) :: width CHARACTER ( LEN = 1 ), OPTIONAL , INTENT ( IN ) :: fill_char CHARACTER ( LEN = 1 ) :: fill CHARACTER ( KIND = ucs4 , LEN = width ) :: centered_text INTEGER :: text_len , padding , left_padding , right_padding , i IF ( present ( fill_char )) THEN fill = fill_char ELSE fill = \" \" END IF text_len = len_trim ( text ) IF ( text_len >= width ) THEN centered_text = text ( 1 : width ) RETURN END IF ! Calculate the total padding required padding = width - text_len IF ( trim ( text ) == \"\" ) THEN left_padding = padding / 2 right_padding = padding - left_padding - mod ( padding , 2 ) ELSE text_len = text_len + 1 left_padding = padding / 2 - 1 right_padding = padding - left_padding - mod ( padding , 2 ) END IF ! Initialize the result centered_text = repeat ( ' ' , width ) ! Fill with fill on the left DO i = 1 , left_padding centered_text ( i : i ) = fill END DO ! Place the text in the center IF ( trim ( text ) == \"\" ) THEN centered_text ( left_padding + 1 : left_padding + text_len ) = trim ( text ) ELSE centered_text ( left_padding + 1 : left_padding + text_len ) = \" \" // trim ( text ) // \" \" END IF ! Fill with fill on the right DO i = right_padding + text_len , width centered_text ( i : i ) = fill END DO END FUNCTION center_with_fill END MODULE NAFPack_Logger_mod","tags":"","url":"sourcefile\\nafpack_logger_mod.f90.html"}]}