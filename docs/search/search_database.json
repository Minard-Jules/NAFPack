var tipuesearch = {"pages":[{"title":" NAFPack ","text":"NAFPack NAFPack Features Author License About This Documentation Warning This documentation is a work in progress NAFPack A modern, modular, and open-source Fortran package for numerical analysis, designed to provide robust and efficient tools for scientific computing. Features Fast Fourier Transform (FFT) Linear system solvers Eigenvalue and eigenvector computations And more... Author Minard-Jules License This project is licensed under the MIT License . About This Documentation This documentation provides an overview of the NAFPack project, including installation instructions, usage examples. Please note that this documentation is a work in progress and may be updated frequently. Developer Info Minard Jules","tags":"home","url":"index.html"},{"title":"LU_decomposition – NAFPack","text":"public  subroutine LU_decomposition(A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U Called by proc~~lu_decomposition~~CalledByGraph proc~lu_decomposition LU_decomposition proc~direct_methode Direct_methode proc~direct_methode->proc~lu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition","tags":"","url":"proc\\lu_decomposition.html"},{"title":"LDU_decomposition – NAFPack","text":"public  subroutine LDU_decomposition(A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U Called by proc~~ldu_decomposition~~CalledByGraph proc~ldu_decomposition LDU_decomposition proc~direct_methode Direct_methode proc~direct_methode->proc~ldu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [ ( D ( k , k ), k = 1 , i - 1 ) ])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition","tags":"","url":"proc\\ldu_decomposition.html"},{"title":"Cholesky_decomposition – NAFPack","text":"public  subroutine Cholesky_decomposition(A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L Called by proc~~cholesky_decomposition~~CalledByGraph proc~cholesky_decomposition Cholesky_decomposition proc~direct_methode Direct_methode proc~direct_methode->proc~cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = SIZE ( A , 1 ) DO j = 1 , N L ( j , j ) = SQRT ( A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition","tags":"","url":"proc\\cholesky_decomposition.html"},{"title":"QR_decomposition – NAFPack","text":"public  subroutine QR_decomposition(A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Calls proc~~qr_decomposition~~CallsGraph proc~qr_decomposition QR_decomposition proc~identity_n Identity_n proc~qr_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_decomposition~~CalledByGraph proc~qr_decomposition QR_decomposition proc~direct_methode Direct_methode proc~direct_methode->proc~qr_decomposition proc~eigen Eigen proc~direct_methode->proc~eigen proc~eigen->proc~qr_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified ( A , Q , R ) END IF END SUBROUTINE QR_decomposition","tags":"","url":"proc\\qr_decomposition.html"},{"title":"meshgrid – NAFPack","text":"public  subroutine meshgrid(x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: Y Source Code SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( SIZE ( y_vector ), SIZE ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid","tags":"","url":"proc\\meshgrid.html"},{"title":"FFT_1D – NAFPack","text":"public  function FFT_1D(signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_DFT\": Direct Discrete Fourier Transform \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) Calls proc~~fft_1d~~CallsGraph proc~fft_1d FFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~fft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~fft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_DFT\" ) THEN result = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN result = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D","tags":"","url":"proc\\fft_1d.html"},{"title":"IFFT_1D – NAFPack","text":"public  function IFFT_1D(signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) Calls proc~~ifft_1d~~CallsGraph proc~ifft_1d IFFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~ifft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_IFFT_1D\" ) THEN result = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D","tags":"","url":"proc\\ifft_1d.html"},{"title":"FFT_2D – NAFPack","text":"public  function FFT_2D(signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2)) Calls proc~~fft_2d~~CallsGraph proc~fft_2d FFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~fft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~fft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_FFT_2D\" ) THEN result = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D","tags":"","url":"proc\\fft_2d.html"},{"title":"IFFT_2D – NAFPack","text":"public  function IFFT_2D(signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2)) Calls proc~~ifft_2d~~CallsGraph proc~ifft_2d IFFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~ifft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_IFFT_2D\" ) THEN result = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D","tags":"","url":"proc\\ifft_2d.html"},{"title":"FFT_3D – NAFPack","text":"public  function FFT_3D(signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3)) Calls proc~~fft_3d~~CallsGraph proc~fft_3d FFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~fft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~fft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D","tags":"","url":"proc\\fft_3d.html"},{"title":"IFFT_3D – NAFPack","text":"public  function IFFT_3D(signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3)) Calls proc~~ifft_3d~~CallsGraph proc~ifft_3d IFFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~ifft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D","tags":"","url":"proc\\ifft_3d.html"},{"title":"dot – NAFPack","text":"public  function dot(a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) Source Code FUNCTION dot ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: result INTEGER :: i IF ( SIZE ( a ) /= SIZE ( b )) STOP \"Error: Vectors must be of the same size.\" result = 0.0_dp DO i = 1 , SIZE ( a ) result = result + a ( i ) * b ( i ) END DO END FUNCTION dot","tags":"","url":"proc\\dot.html"},{"title":"cross – NAFPack","text":"public  function cross(a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 the wedge notation can sometimes be used to denote the vector product. ↩ Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) Source Code FUNCTION cross ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross","tags":"","url":"proc\\cross.html"},{"title":"norm_2 – NAFPack","text":"public  function norm_2(a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2~~CalledByGraph proc~norm_2 norm_2 proc~normalise normalise proc~normalise->proc~norm_2 proc~eigen Eigen proc~eigen->proc~normalise proc~direct_methode Direct_methode proc~direct_methode->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2 ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( DOT_PRODUCT ( a , a )) END FUNCTION norm_2","tags":"","url":"proc\\norm_2.html"},{"title":"norm_2_complex – NAFPack","text":"public  function norm_2_complex(a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_complex~~CalledByGraph proc~norm_2_complex norm_2_complex proc~normalise_complexe normalise_complexe proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2_complex ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( REAL ( DOT_PRODUCT ( a , CONJG ( a )))) END FUNCTION norm_2_complex","tags":"","url":"proc\\norm_2_complex.html"},{"title":"normalise – NAFPack","text":"public  function normalise(a) result(result) function that normalises a real vector a to make it a unit vector, \nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a)) Calls proc~~normalise~~CallsGraph proc~normalise normalise proc~norm_2 norm_2 proc~normalise->proc~norm_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~normalise~~CalledByGraph proc~normalise normalise proc~eigen Eigen proc~eigen->proc~normalise proc~direct_methode Direct_methode proc~direct_methode->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2 ( a ) END FUNCTION normalise","tags":"","url":"proc\\normalise.html"},{"title":"normalise_complexe – NAFPack","text":"public  function normalise_complexe(a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a)) Calls proc~~normalise_complexe~~CallsGraph proc~normalise_complexe normalise_complexe proc~norm_2_complex norm_2_complex proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise_complexe ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2_complex ( a ) END FUNCTION normalise_complexe","tags":"","url":"proc\\normalise_complexe.html"},{"title":"Diagonally_Dominant_Matrix – NAFPack","text":"public  function Diagonally_Dominant_Matrix(A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = SIZE ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = SUM ( ABS ( A ( i , :) - A ( i , i ))) if ( ABS ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix","tags":"","url":"proc\\diagonally_dominant_matrix.html"},{"title":"Identity_n – NAFPack","text":"public  function Identity_n(N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) Called by proc~~identity_n~~CalledByGraph proc~identity_n Identity_n proc~direct_methode Direct_methode proc~direct_methode->proc~identity_n proc~eigen Eigen proc~direct_methode->proc~eigen proc~qr_decomposition QR_decomposition proc~direct_methode->proc~qr_decomposition proc~rotation_matrix rotation_matrix proc~direct_methode->proc~rotation_matrix proc~eigen->proc~identity_n proc~eigen->proc~qr_decomposition proc~qr_decomposition->proc~identity_n proc~qr_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( PRESENT ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n","tags":"","url":"proc\\identity_n.html"},{"title":"rotation_matrix – NAFPack","text":"public  function rotation_matrix(A, rotation) result(G) Function to create a rotation matrix This function generates a rotation matrix G based on the input matrix A and the specified rotation indices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(SIZE(A, 1),SIZE(A, 2)) Calls proc~~rotation_matrix~~CallsGraph proc~rotation_matrix rotation_matrix proc~identity_n Identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation_matrix~~CalledByGraph proc~rotation_matrix rotation_matrix proc~direct_methode Direct_methode proc~direct_methode->proc~rotation_matrix proc~qr_decomposition QR_decomposition proc~direct_methode->proc~qr_decomposition proc~eigen Eigen proc~direct_methode->proc~eigen proc~qr_decomposition->proc~rotation_matrix proc~eigen->proc~qr_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( SIZE ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = SQRT ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix","tags":"","url":"proc\\rotation_matrix.html"},{"title":"forward – NAFPack","text":"public  function forward(L, b) result(y) forward algorithm, \nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(SIZE(L, 1)) Called by proc~~forward~~CalledByGraph proc~forward forward proc~direct_methode Direct_methode proc~direct_methode->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( L , 1 )) :: y INTEGER :: i , N N = SIZE ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward","tags":"","url":"proc\\forward.html"},{"title":"backward – NAFPack","text":"public  function backward(U, y) result(x) backward algorithm, \nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(SIZE(U, 1)) Called by proc~~backward~~CalledByGraph proc~backward backward proc~direct_methode Direct_methode proc~direct_methode->proc~backward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( SIZE ( U , 1 )) :: x INTEGER :: i , N N = SIZE ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - DOT_PRODUCT ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward","tags":"","url":"proc\\backward.html"},{"title":"Direct_methode – NAFPack","text":"public  function Direct_methode(A, b, method, pivot_method, check) result(x) Direct method for solving linear systems This function allows you to choose the direct method for solving the linear system.\nIt supports various methods: Gaussian elimination LU decomposition LDU decomposition Cholesky decomposition QR decomposition (Householder, Givens, Classical Gram-Schmidt, Modified Gram-Schmidt) TDMA (Thomas algorithm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: pivot_method logical, intent(in), optional :: check Return Value real(kind=dp), DIMENSION(SIZE(A,1)) Calls proc~~direct_methode~~CallsGraph proc~direct_methode Direct_methode proc~backward backward proc~direct_methode->proc~backward proc~cholesky_decomposition Cholesky_decomposition proc~direct_methode->proc~cholesky_decomposition proc~eigen Eigen proc~direct_methode->proc~eigen proc~forward forward proc~direct_methode->proc~forward proc~identity_n Identity_n proc~direct_methode->proc~identity_n proc~ldu_decomposition LDU_decomposition proc~direct_methode->proc~ldu_decomposition proc~lu_decomposition LU_decomposition proc~direct_methode->proc~lu_decomposition proc~qr_decomposition QR_decomposition proc~direct_methode->proc~qr_decomposition proc~rotation_matrix rotation_matrix proc~direct_methode->proc~rotation_matrix proc~eigen->proc~identity_n proc~eigen->proc~qr_decomposition proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition->proc~identity_n proc~qr_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n proc~norm_2 norm_2 proc~normalise->proc~norm_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Direct_methode ( A , b , method , pivot_method , check ) RESULT ( x ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: pivot_method REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: N LOGICAL :: do_check = . TRUE . IF ( PRESENT ( check )) do_check = check N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( b , 1 ) /= N ) STOP \"ERROR :: Dimension mismatch in linear system\" IF (. NOT . PRESENT ( method )) THEN PRINT * , \"WARNING :: No method specified for linear system, using LU decomposition\" x = A_LU ( A , b ) END IF IF ( method == \"Gauss\" ) THEN x = Gauss ( A , b , pivot_method = pivot_method ) ELSE IF ( method == \"A_LU\" ) THEN x = A_LU ( A , b ) ELSE IF ( method == \"A_LDU\" ) THEN x = A_LDU ( A , b ) ELSE IF ( method == \"Cholesky\" ) THEN x = Cholesky ( A , b , check = do_check ) ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN x = A_QR ( A , b , method = method ) ELSE IF ( method == \"TDMA\" ) THEN x = TDMA ( A , b , check = do_check ) ELSE STOP \"ERROR : Wrong method for linear system (direct_methode)\" END IF END FUNCTION Direct_methode","tags":"","url":"proc\\direct_methode.html"},{"title":"Iterative_methods – NAFPack","text":"public  function Iterative_methods(A, b, method, x_init, max_iter, omega) result(x) Iterative method for solving linear systems This function allows you to choose the iterative method for solving the linear system.\nIt supports various methods: Jacobi Gauss-Seidel Successive Over-Relaxation (SOR) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method real(kind=dp), intent(in), optional, DIMENSION(:) :: x_init integer, intent(in), optional :: max_iter real(kind=dp), intent(in), optional :: omega Return Value real(kind=dp), DIMENSION(SIZE(A, 1)) Source Code FUNCTION Iterative_methods ( A , b , method , x_init , max_iter , omega ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: x_init CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: max_iter REAL ( dp ), OPTIONAL , INTENT ( IN ) :: omega REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x0 , x_new , residu INTEGER :: k , max_iter_choice , N N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( PRESENT ( max_iter )) THEN max_iter_choice = max_iter ELSE max_iter_choice = kmax END IF IF ( PRESENT ( x_init )) THEN IF ( SIZE ( x_init , 1 ) /= SIZE ( A , 1 )) STOP \"ERROR : Dimension of x_init different from A\" x0 = x_init ELSE x0 = 0.d0 END IF DO k = 1 , max_iter_choice IF ( k == kmax ) THEN PRINT * , \"WARNING :: non-convergence of the iterative method \" // method END IF IF ( method == \"Jacobi\" ) THEN CALL Jacobi ( A , b , x0 , x_new ) ELSE IF ( method == \"Gauss_Seidel\" ) THEN CALL Gauss_Seidel ( A , b , x0 , x_new ) ELSE IF ( method == \"SOR\" ) THEN IF ( PRESENT ( omega )) THEN CALL SOR ( A , b , x0 , x_new , omega ) ELSE CALL SOR ( A , b , x0 , x_new , 1.d0 ) END IF ELSE STOP \"ERROR : Wrong method for linear system (Iterative_methods)\" END IF residu = b - MATMUL ( A , x_new ) IF ( NORM2 ( residu ) < epsi ) EXIT x0 = x_new END DO x = x_new END FUNCTION Iterative_methods","tags":"","url":"proc\\iterative_methods.html"},{"title":"Eigen – NAFPack","text":"public  subroutine Eigen(A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Power iteration QR algorithm (with or without shift)\nThe default method is Power iteration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k Calls proc~~eigen~~CallsGraph proc~eigen Eigen proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2 norm_2 proc~normalise->proc~norm_2 proc~qr_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~eigen~~CalledByGraph proc~eigen Eigen proc~direct_methode Direct_methode proc~direct_methode->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( PRESENT ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( PRESENT ( vp ) . AND . ( SIZE ( vp , 1 ) /= N . OR . SIZE ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( PRESENT ( vp )) vp = vp_tmp ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN IF ( PRESENT ( vp )) vp = 0 IF ( PRESENT ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = INDEX ( TRIM ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == LEN_TRIM ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen","tags":"","url":"proc\\eigen.html"},{"title":"NAFPack_matrix_decomposition – NAFPack","text":"Module for matrix decomposition methods This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. Uses NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_decomposition~~UsesGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_decomposition~~UsedByGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_linear_algebra NAFPack_linear_algebra module~nafpack_linear_algebra->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine LU_decomposition (A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine LDU_decomposition (A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine Cholesky_decomposition (A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L public  subroutine QR_decomposition (A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R","tags":"","url":"module\\nafpack_matrix_decomposition.html"},{"title":"NAFPack_meshgrid – NAFPack","text":"Module for creating a meshgrid from two vectors This module provides a subroutine to create a meshgrid. Uses NAFPack_constant module~~nafpack_meshgrid~~UsesGraph module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_constant NAFPack_constant module~nafpack_meshgrid->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine meshgrid (x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: Y","tags":"","url":"module\\nafpack_meshgrid.html"},{"title":"NAFPack_constant – NAFPack","text":"Module for defining constants used in NAFPack This module includes mathematical constants, colors for terminal output,\nand other parameters that are used throughout the NAFPack library. Uses iso_fortran_env module~~nafpack_constant~~UsesGraph module~nafpack_constant NAFPack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_constant~~UsedByGraph module~nafpack_constant NAFPack_constant module~nafpack_fft NAFPack_fft module~nafpack_fft->module~nafpack_constant module~nafpack_linear_algebra NAFPack_linear_algebra module~nafpack_linear_algebra->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_linear_algebra->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_linear_algebra->module~nafpack_matrix_decomposition module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = ACOS(-1.d0) constant complex(kind=dp), public, parameter :: im = (0.d0, 1.d0) Imaginary unit real(kind=dp), public, parameter :: epsi = 1.d-12 Small value real(kind=dp), public, parameter :: epsi_test = 1.d-6 Small value integer, public, parameter :: kmax = 10000 Maximum number of iterations for iterative methods character(len=*), public, parameter :: status_len = REPEAT(\" \", 15) len of status messages character(len=10), public :: red_color = CHAR(27)//\"[31m\" red colors for terminal output character(len=10), public :: green_color = CHAR(27)//\"[32m\" green colors for terminal output character(len=10), public :: yellow_color = CHAR(27)//\"[33m\" yellow colors for terminal output character(len=10), public :: blue_color = CHAR(27)//\"[34m\" blue colors for terminal output character(len=10), public :: purple_color = CHAR(27)//\"[35m\" purple colors for terminal output character(len=10), public :: cyan_color = CHAR(27)//\"[36m\" cyan colors for terminal output character(len=10), public :: white_color = CHAR(27)//\"[37m\" white colors for terminal output character(len=10), public :: reset_color = CHAR(27)//\"[0m\" reset colors for terminal output","tags":"","url":"module\\nafpack_constant.html"},{"title":"NAFPack_fft – NAFPack","text":"Module for Fourier Transform This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals.\nIt supports both forward and inverse transforms.\nIt allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. Uses NAFPack_constant FFTW3 module~~nafpack_fft~~UsesGraph module~nafpack_fft NAFPack_fft FFTW3 FFTW3 module~nafpack_fft->FFTW3 module~nafpack_constant NAFPack_constant module~nafpack_fft->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function FFT_1D (signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function IFFT_1D (signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function FFT_2D (signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2)) public  function IFFT_2D (signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2)) public  function FFT_3D (signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3)) public  function IFFT_3D (signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3))","tags":"","url":"module\\nafpack_fft.html"},{"title":"NAFPack_matricielle – NAFPack","text":"Module for Tensor operations in NAFPack Uses NAFPack_constant module~~nafpack_matricielle~~UsesGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_constant NAFPack_constant module~nafpack_matricielle->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matricielle~~UsedByGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_linear_algebra NAFPack_linear_algebra module~nafpack_linear_algebra->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_linear_algebra->module~nafpack_matrix_decomposition module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function dot (a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) public  function cross (a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) public  function norm_2 (a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function norm_2_complex (a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function normalise (a) result(result) function that normalises a real vector a to make it a unit vector, \nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a)) public  function normalise_complexe (a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a)) public  function Diagonally_Dominant_Matrix (A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function Identity_n (N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) public  function rotation_matrix (A, rotation) result(G) Function to create a rotation matrix Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(SIZE(A, 1),SIZE(A, 2))","tags":"","url":"module\\nafpack_matricielle.html"},{"title":"NAFPack_linear_algebra – NAFPack","text":"Module for linear algebra operations This module provides functions and subroutines for solving linear systems,\nand computing eigenvalues and eigenvectors. Uses NAFPack_matrix_decomposition NAFPack_constant NAFPack_matricielle module~~nafpack_linear_algebra~~UsesGraph module~nafpack_linear_algebra NAFPack_linear_algebra module~nafpack_constant NAFPack_constant module~nafpack_linear_algebra->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_linear_algebra->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_linear_algebra->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function forward (L, b) result(y) forward algorithm, \nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(SIZE(L, 1)) public  function backward (U, y) result(x) backward algorithm, \nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(SIZE(U, 1)) public  function Direct_methode (A, b, method, pivot_method, check) result(x) Direct method for solving linear systems This function allows you to choose the direct method for solving the linear system.\nIt supports various methods: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: pivot_method logical, intent(in), optional :: check Return Value real(kind=dp), DIMENSION(SIZE(A,1)) public  function Iterative_methods (A, b, method, x_init, max_iter, omega) result(x) Iterative method for solving linear systems This function allows you to choose the iterative method for solving the linear system.\nIt supports various methods: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method real(kind=dp), intent(in), optional, DIMENSION(:) :: x_init integer, intent(in), optional :: max_iter real(kind=dp), intent(in), optional :: omega Return Value real(kind=dp), DIMENSION(SIZE(A, 1)) Subroutines public  subroutine Eigen (A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"module\\nafpack_linear_algebra.html"},{"title":"NAFPack_matrix_decomposition.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_decomposition.f90~~EfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_decomposition.f90~~AfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_linear_algebra.f90 NAFPack_linear_algebra.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for matrix decomposition methods !> !> This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. MODULE NAFPack_matrix_decomposition USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: LU_decomposition , LDU_decomposition , Cholesky_decomposition , QR_decomposition CONTAINS !> LU decomposition of a matrix A !>  A = LU  !> This subroutine performs LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition !> LDU decomposition of a matrix A !>  A = LDU  !> This subroutine performs LDU decomposition of a given matrix **A**, where **L** is a lower triangular matrix, **D** is a diagonal matrix, and **U** is an upper triangular matrix. SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [ ( D ( k , k ), k = 1 , i - 1 ) ])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition !> Cholesky decomposition of a matrix A !>  A = LL&#94;T  !> This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix. SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = SIZE ( A , 1 ) DO j = 1 , N L ( j , j ) = SQRT ( A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition !> QR decomposition of a matrix **A** using various methods !>  A = QR  !> This subroutine performs QR decomposition of a given matrix **A** using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt). !> The output matrices **Q** is an orthogonal matrix and **R** is an upper triangular matrix. SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified ( A , Q , R ) END IF END SUBROUTINE QR_decomposition !> QR decomposition using Householder method SUBROUTINE QR_Householder ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = SIZE ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = NORM2 ( R ( k : N , k )) signe = - SIGN ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = NORM2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = MATMUL ( Q , H ) R ( k : N , k : N ) = MATMUL ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder !> QR decomposition using Givens rotations SUBROUTINE QR_Givens ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: G INTEGER :: N , i , j N = SIZE ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = MATMUL ( G , R ) Q = MATMUL ( Q , TRANSPOSE ( G )) END DO END DO END SUBROUTINE QR_Givens !> QR decomposition using Classical Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Classical ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) Q = Identity_n ( N ) DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = DOT_PRODUCT ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = NORM2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical !> QR decomposition using Modified Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Modified ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = NORM2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = DOT_PRODUCT ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified END MODULE NAFPack_matrix_decomposition","tags":"","url":"sourcefile\\nafpack_matrix_decomposition.f90.html"},{"title":"NAFPack_meshgrid.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid.f90~~EfferentGraph sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for creating a meshgrid from two vectors !> !> This module provides a subroutine to create a meshgrid. MODULE NAFPack_meshgrid USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: meshgrid CONTAINS !> Make N-dimensional meshgrid from two vectors **x_vector** and **y_vector** SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( SIZE ( y_vector ), SIZE ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid END MODULE NAFPack_meshgrid","tags":"","url":"sourcefile\\nafpack_meshgrid.f90.html"},{"title":"NAFPack_constant.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_constant.f90~~AfferentGraph sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_linear_algebra.f90 NAFPack_linear_algebra.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for defining constants used in NAFPack !> !> This module includes mathematical constants, colors for terminal output, !> and other parameters that are used throughout the NAFPack library. MODULE NAFPack_constant USE , INTRINSIC :: iso_fortran_env , ONLY : sp => real32 , dp => real64 , isp => int32 , idp => int64 IMPLICIT NONE PRIVATE PUBLIC :: pi , im , epsi , kmax , sp , dp , epsi_test , idp , isp PUBLIC :: status_len PUBLIC :: red_color , green_color , yellow_color , blue_color , white_color , cyan_color , purple_color , reset_color !>  \\pi  constant REAL ( dp ), PARAMETER :: pi = ACOS ( - 1.d0 ) !> Imaginary unit  i = \\sqrt{-1}  COMPLEX ( dp ), PARAMETER :: im = ( 0.d0 , 1.d0 ) !> Small  \\epsilon  value REAL ( dp ), PARAMETER :: epsi = 1.d-12 , epsi_test = 1.d-6 !> Maximum number of iterations for iterative methods INTEGER , PARAMETER :: kmax = 10000 !> len of status messages CHARACTER ( LEN = * ), PARAMETER :: status_len = REPEAT ( \" \" , 15 ) !> red colors for terminal output CHARACTER ( len = 10 ) :: red_color = CHAR ( 27 ) // \"[31m\" !> green colors for terminal output CHARACTER ( len = 10 ) :: green_color = CHAR ( 27 ) // \"[32m\" !> yellow colors for terminal output CHARACTER ( len = 10 ) :: yellow_color = CHAR ( 27 ) // \"[33m\" !> blue colors for terminal output CHARACTER ( len = 10 ) :: blue_color = CHAR ( 27 ) // \"[34m\" !> purple colors for terminal output CHARACTER ( len = 10 ) :: purple_color = CHAR ( 27 ) // \"[35m\" !> cyan colors for terminal output CHARACTER ( len = 10 ) :: cyan_color = CHAR ( 27 ) // \"[36m\" !> white colors for terminal output CHARACTER ( len = 10 ) :: white_color = CHAR ( 27 ) // \"[37m\" !> reset colors for terminal output CHARACTER ( len = 10 ) :: reset_color = CHAR ( 27 ) // \"[0m\" END MODULE NAFPack_constant","tags":"","url":"sourcefile\\nafpack_constant.f90.html"},{"title":"NAFPack_fft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fft.f90~~EfferentGraph sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Fourier Transform !>  F(\\omega) = \\int_{-\\infty}&#94;{\\infty} f(t) e&#94;{-i \\omega t} dt  !> This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals. !> It supports both forward and inverse transforms. !> It allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. MODULE NAFPack_fft USE FFTW3 USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: FFT_1D , FFT_2D , FFT_3D PUBLIC :: IFFT_1D , IFFT_2D , IFFT_3D CONTAINS !> Perform a 1D Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_DFT\": Direct Discrete Fourier Transform !> - \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_DFT\" ) THEN result = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN result = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_IFFT_1D\" ) THEN result = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_FFT_2D\" ) THEN result = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_IFFT_2D\" ) THEN result = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D !> Perform a 3D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D !################### FFTW ########################################## !> Perform a 1D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_1D_threads !> Perform a 1D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_1D_threads !> Perform a 2D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_2D !> Perform a 2D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_2D_threads !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_2D_threads !> Perform a 3D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_3D !> Perform a 3D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_3D_threads !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_3D_threads !################### NAFPack ########################################## !> Perform a 1D Discrete Fourier Transform on a signal FUNCTION NAFPack_DFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ) :: S INTEGER :: N , i , k , j N = SIZE ( signal ) IF ( N == 1 ) THEN result = signal ELSE DO i = 1 , N k = i - 1 S = ( 0.d0 , 0.d0 ) DO j = 1 , N S = S + signal ( j ) * EXP (( - 2 * pi * im * k * ( j - 1 )) / N ) END DO result ( i ) = S END DO END IF END FUNCTION NAFPack_DFT_1D !> Compute the complex exponential factors for the FFT FUNCTION fun_omega ( N ) RESULT ( result ) INTEGER , INTENT ( IN ) :: N COMPLEX ( dp ), DIMENSION ( N / 2 ) :: result INTEGER :: i DO i = 1 , N / 2 result ( i ) = EXP ( - 2 * Im * pi * ( i - 1 ) / N ) END DO END FUNCTION fun_omega !> Perform a 1D Fast Fourier Transform (Cooley-Tukey) on a signal RECURSIVE FUNCTION NAFPack_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( signal ) / 2 ) :: f_pair , f_impair , omega INTEGER :: N N = SIZE ( signal ) IF ( MOD ( N , 2 ) == 0 ) THEN f_pair = NAFPack_FFT_1D ( signal ( 1 :: 2 )) f_impair = NAFPack_FFT_1D ( signal ( 2 :: 2 )) omega = fun_omega ( N ) result ( 1 : N / 2 ) = f_pair + f_impair * omega result ( N / 2 + 1 :) = f_pair - f_impair * omega ELSE result = NAFPack_DFT_1D ( signal ) END IF END FUNCTION NAFPack_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_1D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: f_conjugate INTEGER :: N N = SIZE ( f_signal ) f_conjugate = CONJG ( f_signal ) result = NAFPack_FFT_1D ( f_conjugate ) result = CONJG ( result ) result = result / N END FUNCTION NAFPack_IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal FUNCTION NAFPack_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( signal , 1 ) Ny = SIZE ( signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_FFT_1D ( signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_FFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_2D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal , 1 ), SIZE ( f_signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( f_signal , 1 ) Ny = SIZE ( f_signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_IFFT_1D ( f_signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_IFFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_IFFT_2D END MODULE NAFPack_fft","tags":"","url":"sourcefile\\nafpack_fft.f90.html"},{"title":"NAFPack_matricielle.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matricielle.f90~~EfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matricielle.f90~~AfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_linear_algebra.f90 NAFPack_linear_algebra.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Tensor operations in NAFPack MODULE NAFPack_matricielle USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: dot , cross PUBLIC :: norm_2 , norm_2_complex PUBLIC :: normalise , normalise_complexe PUBLIC :: Diagonally_Dominant_Matrix PUBLIC :: Identity_n PUBLIC :: rotation_matrix CONTAINS !> function that calculates the dot product of two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\cdot \\vec{b}  FUNCTION dot ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: result INTEGER :: i IF ( SIZE ( a ) /= SIZE ( b )) STOP \"Error: Vectors must be of the same size.\" result = 0.0_dp DO i = 1 , SIZE ( a ) result = result + a ( i ) * b ( i ) END DO END FUNCTION dot !> function that calculates the cross product between two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\times \\vec{b} [&#94;1] !> [&#94;1]: the wedge notation  \\vec{a} \\wedge \\vec{b}  can sometimes be used to denote the vector product. FUNCTION cross ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross !> function that calculates the Euclidean norm (L2 norm) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} a_i&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} a_i&#94;2 = \\vec{a} \\cdot \\vec{a}  !> where  n  is the dimension of the real vector  \\vec{a} . FUNCTION norm_2 ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( DOT_PRODUCT ( a , a )) END FUNCTION norm_2 !> function that calculates the Euclidean norm (L2 norm or modulus) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} |a_i|&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} |a_i|&#94;2 = \\vec{a} \\cdot \\overline{\\vec{a}}  !> where  n  is the dimension of the complex vector  \\vec{a} . FUNCTION norm_2_complex ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( REAL ( DOT_PRODUCT ( a , CONJG ( a )))) END FUNCTION norm_2_complex !> function that normalises a real vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2 ( a ) END FUNCTION normalise !> function that normalises a complex vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise_complexe ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2_complex ( a ) END FUNCTION normalise_complexe !> function which checks if **A** is diagonally dominant !>  \\forall i, |A(i,i)| \\geq \\sum_{j \\neq i} |A(i,j)|  FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = SIZE ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = SUM ( ABS ( A ( i , :) - A ( i , i ))) if ( ABS ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix !> function that returns the identity matrix for a given size N !>  I_N = \\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{pmatrix}  FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( PRESENT ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n !> Function to create a rotation matrix !> !> This function generates a rotation matrix **G** based on the input matrix **A** and the specified rotation indices. FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( SIZE ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = SQRT ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix END MODULE NAFPack_matricielle","tags":"","url":"sourcefile\\nafpack_matricielle.f90.html"},{"title":"NAFPack_linear_algebra.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_linear_algebra.f90~~EfferentGraph sourcefile~nafpack_linear_algebra.f90 NAFPack_linear_algebra.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_linear_algebra.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for linear algebra operations !> !> This module provides functions and subroutines for solving linear systems, !> and computing eigenvalues and eigenvectors. MODULE NAFPack_linear_algebra USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: forward , backward PUBLIC :: Direct_methode , Iterative_methods PUBLIC :: Eigen CONTAINS !================== Linear System ======================================================= !> forward algorithm, !> solves the system !>  L * y = b  !> where **L** is a lower triangular matrix and **b** is a vector FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( L , 1 )) :: y INTEGER :: i , N N = SIZE ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward !> backward algorithm, !> solves the system !>  U * x = y  !> where **U** is an upper triangular matrix and **y** is a vector FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( SIZE ( U , 1 )) :: x INTEGER :: i , N N = SIZE ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - DOT_PRODUCT ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward !################## direct methode ###################################################### !> Direct method for solving linear systems !>  A * x = b  !> This function allows you to choose the direct method for solving the linear system. !> It supports various methods: !> !> - Gaussian elimination !> - LU decomposition !> - LDU decomposition !> - Cholesky decomposition !> - QR decomposition (Householder, Givens, Classical Gram-Schmidt, Modified Gram-Schmidt) !> - TDMA (Thomas algorithm) FUNCTION Direct_methode ( A , b , method , pivot_method , check ) RESULT ( x ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: pivot_method REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: N LOGICAL :: do_check = . TRUE . IF ( PRESENT ( check )) do_check = check N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( b , 1 ) /= N ) STOP \"ERROR :: Dimension mismatch in linear system\" IF (. NOT . PRESENT ( method )) THEN PRINT * , \"WARNING :: No method specified for linear system, using LU decomposition\" x = A_LU ( A , b ) END IF IF ( method == \"Gauss\" ) THEN x = Gauss ( A , b , pivot_method = pivot_method ) ELSE IF ( method == \"A_LU\" ) THEN x = A_LU ( A , b ) ELSE IF ( method == \"A_LDU\" ) THEN x = A_LDU ( A , b ) ELSE IF ( method == \"Cholesky\" ) THEN x = Cholesky ( A , b , check = do_check ) ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN x = A_QR ( A , b , method = method ) ELSE IF ( method == \"TDMA\" ) THEN x = TDMA ( A , b , check = do_check ) ELSE STOP \"ERROR : Wrong method for linear system (direct_methode)\" END IF END FUNCTION Direct_methode !> Gaussian elimination method !> !> This function implements the Gaussian elimination method for solving linear systems. !> It performs partial or total pivoting based on the user's choice. FUNCTION Gauss ( A , b , pivot_method ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: pivot_method REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp , P , Q , Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER , DIMENSION ( 1 ) :: vlmax_partial INTEGER , DIMENSION ( 2 ) :: vlmax_total REAL ( dp ) :: m , pivot INTEGER :: k , i , N , lmax , cmax A_tmp = A b_tmp = b N = SIZE ( A_tmp , 1 ) Q_final = Identity_n ( N ) DO k = 1 , N - 1 IF (. NOT . PRESENT ( pivot_method )) THEN PRINT * , \"WARNING :: No pivot method specified, using normal pivot\" END IF IF ( pivot_method == \"partial\" ) THEN ! Find the maximum absolute value in the column from row k to N vlmax_partial = MAXLOC ( ABS ( A_tmp ( k : N , k ))) lmax = vlmax_partial ( 1 ) + k - 1 !calculate permutation matrix P P = Identity_n ( N ) IF ( k /= lmax ) THEN P = rotation_matrix ( P , [ k , lmax ]) END IF A_tmp = MATMUL ( P , A_tmp ) b_tmp = MATMUL ( P , b_tmp ) ELSE IF ( pivot_method == \"total\" ) THEN ! Find max abs element in submatrix vlmax_total = MAXLOC ( ABS ( A_tmp ( k : N , k : N ))) lmax = vlmax_total ( 1 ) + k - 1 cmax = vlmax_total ( 2 ) + k - 1 ! permute line if necessary P = Identity_n ( N ) IF ( lmax /= k ) THEN P = rotation_matrix ( P , [ k , lmax ]) END IF ! permute column if necessary Q = Identity_n ( N ) IF ( cmax /= k ) THEN Q = rotation_matrix ( Q , [ k , cmax ]) END IF Q_final = MATMUL ( Q , Q_final ) ! Apply permutations A_tmp = MATMUL ( P , A_tmp ) A_tmp = MATMUL ( A_tmp , Q ) b_tmp = MATMUL ( P , b_tmp ) END IF pivot = A_tmp ( k , k ) IF ( ABS ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" DO i = k + 1 , N m = A_tmp ( i , k ) / pivot A_tmp ( i , k ) = 0 ! Vectorized operation A_tmp ( i , k + 1 : N ) = A_tmp ( i , k + 1 : N ) - m * A_tmp ( k , k + 1 : N ) b_tmp ( i ) = b_tmp ( i ) - m * b_tmp ( k ) END DO END DO x = backward ( A_tmp , b_tmp ) IF ( pivot_method == \"total\" ) x = MATMUL ( Q_final , x ) END FUNCTION Gauss !> LU decomposition method !> !> This function implements the LU decomposition method for solving linear systems. FUNCTION A_LU ( A , b ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , U REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y CALL LU_decomposition ( A , L , U ) y = forward ( L , b ) x = backward ( U , y ) END FUNCTION A_LU !> LDU decomposition method !> !> This function implements the LDU decomposition method for solving linear systems. FUNCTION A_LDU ( A , b ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , U , D REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , z CALL LDU_decomposition ( A , L , D , U ) z = forward ( L , b ) y = forward ( D , z ) x = backward ( U , y ) END FUNCTION A_LDU !> Cholesky method !> !> This function implements the Cholesky decomposition method for solving linear systems. FUNCTION Cholesky ( A , b , check ) RESULT ( x ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , lambda LOGICAL :: do_check = . TRUE . IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is positive definite and symmetric\" CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( MINVAL ( lambda ) < epsi ) STOP \"ERROR :: A is not a definite matrix (Cholesky)\" IF ( MAXVAL ( ABS ( A - TRANSPOSE ( A ))) > epsi ) STOP \"ERROR :: A is not symmetric (Cholesky)\" END IF CALL Cholesky_decomposition ( A , L ) y = forward ( L , b ) x = backward ( TRANSPOSE ( L ), y ) END FUNCTION Cholesky !> QR decomposition method !> !> This function implements the QR decomposition method for solving linear systems. !> It allows the user to choose the method for QR decomposition (e.g., Householder). FUNCTION A_QR ( A , b , method ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Q , R CALL QR_decomposition ( A , method , Q , R ) x = backward ( R , MATMUL ( TRANSPOSE ( Q ), b )) END FUNCTION A_QR !> TDMA method (or Thomas algorithm) !> !> This function implements the Thomas algorithm for solving tridiagonal systems. FUNCTION TDMA ( A , b , check ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: alpha , beta REAL ( dp ) :: denom INTEGER :: n , i , j LOGICAL :: do_check = . TRUE . N = SIZE ( A , 1 ) IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is tridiagonal\" DO i = 1 , N DO j = 1 , N IF ( ABS ( i - j ) > 1 ) THEN IF ( ABS ( A ( i , j )) > epsi ) STOP \"ERROR :: Matrix is not tridiagonal\" END IF END DO END DO END IF alpha = 0.0_dp beta = 0.0_dp alpha ( 1 ) = A ( 1 , 2 ) / A ( 1 , 1 ) beta ( 1 ) = b ( 1 ) / A ( 1 , 1 ) DO i = 2 , N denom = A ( i , i ) - A ( i , i - 1 ) * alpha ( i - 1 ) IF ( i < N ) alpha ( i ) = A ( i , i + 1 ) / denom beta ( i ) = ( b ( i ) - A ( i , i - 1 ) * beta ( i - 1 )) / denom END DO x ( n ) = beta ( n ) DO i = n - 1 , 1 , - 1 x ( i ) = beta ( i ) - alpha ( i ) * x ( i + 1 ) END DO END FUNCTION TDMA !################## Iterative methods ################################################### !> Iterative method for solving linear systems !>  A * x = b  !> This function allows you to choose the iterative method for solving the linear system. !> It supports various methods: !> !> - Jacobi !> - Gauss-Seidel !> - Successive Over-Relaxation (SOR) FUNCTION Iterative_methods ( A , b , method , x_init , max_iter , omega ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: x_init CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: max_iter REAL ( dp ), OPTIONAL , INTENT ( IN ) :: omega REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x0 , x_new , residu INTEGER :: k , max_iter_choice , N N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( PRESENT ( max_iter )) THEN max_iter_choice = max_iter ELSE max_iter_choice = kmax END IF IF ( PRESENT ( x_init )) THEN IF ( SIZE ( x_init , 1 ) /= SIZE ( A , 1 )) STOP \"ERROR : Dimension of x_init different from A\" x0 = x_init ELSE x0 = 0.d0 END IF DO k = 1 , max_iter_choice IF ( k == kmax ) THEN PRINT * , \"WARNING :: non-convergence of the iterative method \" // method END IF IF ( method == \"Jacobi\" ) THEN CALL Jacobi ( A , b , x0 , x_new ) ELSE IF ( method == \"Gauss_Seidel\" ) THEN CALL Gauss_Seidel ( A , b , x0 , x_new ) ELSE IF ( method == \"SOR\" ) THEN IF ( PRESENT ( omega )) THEN CALL SOR ( A , b , x0 , x_new , omega ) ELSE CALL SOR ( A , b , x0 , x_new , 1.d0 ) END IF ELSE STOP \"ERROR : Wrong method for linear system (Iterative_methods)\" END IF residu = b - MATMUL ( A , x_new ) IF ( NORM2 ( residu ) < epsi ) EXIT x0 = x_new END DO x = x_new END FUNCTION Iterative_methods !> Jacobi iterative method !> !> This subroutine implements the Jacobi method for solving linear systems. SUBROUTINE Jacobi ( A , b , x0 , x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END SUBROUTINE Jacobi !> Gauss-Seidel iterative method !> !> This subroutine implements the Gauss-Seidel method for solving linear systems. SUBROUTINE Gauss_Seidel ( A , b , x0 , x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END SUBROUTINE Gauss_Seidel !> Successive Over-Relaxation (SOR) iterative method !> !> This subroutine implements the SOR method for solving linear systems. SUBROUTINE SOR ( A , b , x0 , x , omega ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), INTENT ( IN ) :: omega REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = omega * ( x ( i ) / A ( i , i ) - x0 ( i )) x ( i ) = x ( i ) + x0 ( i ) END DO END SUBROUTINE SOR !================== Eigen =============================================================== !> Computes the eigenvalues and eigenvectors of a matrix A !>  A * \\vec{v} = \\lambda * \\vec{v}  !> with **A** a square matrix, **λ** the eigenvalue, and **v** the eigenvector. !> This subroutine allows you to choose the method for computing eigenvalues and eigenvectors: !> !> - Power iteration !> - QR algorithm (with or without shift) !> The default method is Power iteration. SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( PRESENT ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( PRESENT ( vp ) . AND . ( SIZE ( vp , 1 ) /= N . OR . SIZE ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( PRESENT ( vp )) vp = vp_tmp ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN IF ( PRESENT ( vp )) vp = 0 IF ( PRESENT ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = INDEX ( TRIM ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == LEN_TRIM ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen !> QR algorithm for computing eigenvalues !> !> This subroutine implements the QR algorithm for computing the eigenvalues of a matrix. SUBROUTINE Eigen_QR ( A , lambda , method , N , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), INTENT ( IN ) :: method INTEGER , INTENT ( IN ) :: N , k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: lambda_old REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R REAL ( dp ) :: diff INTEGER :: i , j A_tmp = A DO i = 1 , k lambda_old = lambda CALL QR_decomposition ( A_tmp , method , Q , R ) A_tmp = MATMUL ( R , Q ) diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR !> Shifted QR algorithm for computing eigenvalues !> !> This subroutine implements the shifted QR algorithm for computing the eigenvalues of a matrix. !> The shift is chosen as the last diagonal element of the matrix. SUBROUTINE Eigen_QR_Shifted ( A , lambda , method , N , k ) INTEGER , INTENT ( IN ) :: N , k CHARACTER ( LEN = * ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( N ), INTENT ( OUT ) :: lambda INTEGER :: i , j REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R , Id REAL ( dp ) :: shift , diff A_tmp = A Id = Identity_n ( N ) DO i = 1 , k !choice of shift: last diagonal element shift = A_tmp ( N , N ) ! Gap : A - µI A_tmp = A_tmp - shift * Id ! QR Decomposition : A - µI = Q * R CALL QR_decomposition ( A_tmp , method , Q , R ) ! A = RQ + µI A_tmp = MATMUL ( R , Q ) + shift * Id diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR_Shifted !> Power iteration method for computing the dominant eigenvalue and eigenvector !> !> This subroutine implements the power iteration method for finding the dominant eigenvalue and eigenvector of a matrix. !> It iteratively computes the eigenvector and eigenvalue until convergence SUBROUTINE Power_iteration ( A , lambda , vp , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: vp REAL ( dp ), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u , vp_tmp , r INTEGER :: i , N N = SIZE ( A , 1 ) CALL RANDOM_NUMBER ( u ) u = normalise ( u ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) r = vp_tmp - lambda * u DO i = 1 , k u = normalise ( vp_tmp ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) IF ( NORM2 ( r ) <= epsi ) EXIT r = vp_tmp - lambda * u IF ( i == k ) THEN PRINT * , \"WARNING :: non-convergence of the power iteration method\" END IF END DO vp = u END SUBROUTINE Power_iteration !> Deflation method for removing the influence of an eigenvalue and eigenvector !> !> This function performs deflation on a matrix A by removing the influence of an eigenvalue and its corresponding eigenvector. FUNCTION deflation ( A , lambda , vp , k ) RESULT ( result ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: vp REAL ( dp ), INTENT ( IN ) :: lambda INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: result REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: wp INTEGER :: i , j , N REAL ( dp ) :: lambda1 N = SIZE ( A , 1 ) result = A CALL Power_iteration ( transpose ( A ), lambda1 , wp , k ) DO i = 1 , N DO j = 1 , N result ( i , j ) = result ( i , j ) - ( lambda * vp ( i ) * wp ( j )) / DOT_PRODUCT ( vp , wp ) END DO END DO END FUNCTION deflation END MODULE NAFPack_linear_algebra","tags":"","url":"sourcefile\\nafpack_linear_algebra.f90.html"}]}