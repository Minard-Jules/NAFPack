var tipuesearch = {"pages":[{"title":" NAFPack ","text":"NAFPack NAFPack Features Author License About This Documentation Warning This documentation is a work in progress NAFPack A modern, modular, and open-source Fortran package for numerical analysis, designed to provide robust and efficient tools for scientific computing. Features Fast Fourier Transform (FFT) Linear system solvers Eigenvalue and eigenvector computations And more... Author Minard-Jules License This project is licensed under the MIT License . About This Documentation This documentation provides an overview of the NAFPack project, including installation instructions, usage examples. Please note that this documentation is a work in progress and may be updated frequently. Developer Info Minard Jules","tags":"home","url":"index.html"},{"title":"IterativeMethod – NAFPack ","text":"type, public :: IterativeMethod Inherits type~~iterativemethod~~InheritsGraph type~iterativemethod IterativeMethod type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~iterativemethod~~InheritedByGraph type~iterativemethod IterativeMethod type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( MethodTypeIterative ), intent(in) :: method procedure, public :: solve => IterativeMethod_solve private  function IterativeMethod_solve(this, A, b, params, verbose) result(x) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(in) :: this real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b type( IterativeParams ), intent(inout) :: params type( Logger ), optional :: verbose Return Value real(kind=dp), DIMENSION(SIZE(A, 1)) procedure, public :: Init_IterativeParams private  function Init_IterativeParams(this, N, A, x0, max_iter_choice, epsi_tol, omega, method_preconditioner, alpha, is_stationary, is_strict_mode) result(params) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this integer, intent(in) :: N real(kind=dp), intent(in), optional, DIMENSION(:, :) :: A real(kind=dp), intent(in), optional, DIMENSION(:) :: x0 integer, intent(in), optional :: max_iter_choice real(kind=dp), intent(in), optional :: epsi_tol real(kind=dp), intent(in), optional :: omega type( MethodPreconditioner ), intent(in), optional :: method_preconditioner real(kind=dp), intent(in), optional :: alpha logical, intent(in), optional :: is_stationary logical, intent(in), optional :: is_strict_mode Return Value type( IterativeParams ) procedure, public :: Dealocate_IterativeParams private  subroutine Dealocate_IterativeParams(this, params, success) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( IterativeParams ), intent(inout) :: params logical, intent(out), optional :: success procedure, public :: test_matrix private  subroutine test_matrix(this, A, params) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this real(kind=dp), intent(in), DIMENSION(:,:) :: A type( IterativeParams ), intent(in) :: params Source Code TYPE :: IterativeMethod PRIVATE TYPE ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE TYPE ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE TYPE ( IterativeMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Iterative ), PASS ( this ), POINTER :: solve_method => NULL () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: solve => IterativeMethod_solve PROCEDURE :: Init_IterativeParams => Init_IterativeParams PROCEDURE :: Dealocate_IterativeParams => Dealocate_IterativeParams PROCEDURE :: test_matrix => test_matrix END TYPE IterativeMethod","tags":"","url":"type\\iterativemethod.html"},{"title":"config_type – NAFPack ","text":"type, public :: config_type Configuration type for NAFPack Components Type Visibility Attributes Name Initial real(kind=dp), public :: pivot_tolerance = 1.0e-14_dp real(kind=dp), public :: convergence_tolerance = 1.0e-12_dp real(kind=dp), public :: residual_tolerance = 1.0e-10_dp integer, public :: max_iterations = 10000 integer, public :: block_size = 64 logical, public :: use_openmp = .TRUE. logical, public :: use_blas = .TRUE. logical, public :: preallocate_workspace = .TRUE. integer, public :: workspace_size = 1000 logical, public :: enable_debug = .FALSE. logical, public :: enable_timing = .FALSE. character(len=100), public :: log_file = \"nafpack.log\" character(len=50), public :: default_direct_method = \"A_LU\" character(len=50), public :: default_iterative_method = \"Gauss_Seidel\" character(len=50), public :: default_preconditioner = \"ILU\" Source Code TYPE :: config_type ! Numerical tolerances REAL ( dp ) :: pivot_tolerance = 1.0e-14_dp REAL ( dp ) :: convergence_tolerance = 1.0e-12_dp REAL ( dp ) :: residual_tolerance = 1.0e-10_dp ! Performance settings INTEGER :: max_iterations = 10000 INTEGER :: block_size = 64 LOGICAL :: use_openmp = . TRUE . LOGICAL :: use_blas = . TRUE . ! Memory management LOGICAL :: preallocate_workspace = . TRUE . INTEGER :: workspace_size = 1000 ! Debugging and logging LOGICAL :: enable_debug = . FALSE . LOGICAL :: enable_timing = . FALSE . CHARACTER ( LEN = 100 ) :: log_file = \"nafpack.log\" ! Method selection CHARACTER ( LEN = 50 ) :: default_direct_method = \"A_LU\" CHARACTER ( LEN = 50 ) :: default_iterative_method = \"Gauss_Seidel\" CHARACTER ( LEN = 50 ) :: default_preconditioner = \"ILU\" END TYPE config_type","tags":"","url":"type\\config_type.html"},{"title":"MethodPreconditioner – NAFPack ","text":"type, public :: MethodPreconditioner Inherited by type~~methodpreconditioner~~InheritedByGraph type~methodpreconditioner MethodPreconditioner type~iterativemethod IterativeMethod type~iterativemethod->type~methodpreconditioner preconditioner_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name Source Code TYPE :: MethodPreconditioner INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodPreconditioner","tags":"","url":"type\\methodpreconditioner.html"},{"title":"linalg – NAFPack ","text":"type, public :: linalg Inherits type~~linalg~~InheritsGraph type~linalg linalg type~directmethod DirectMethod type~linalg->type~directmethod direct type~iterativemethod IterativeMethod type~linalg->type~iterativemethod iterative type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative Source Code TYPE :: linalg TYPE ( DirectMethod ) :: direct TYPE ( IterativeMethod ) :: iterative END TYPE linalg","tags":"","url":"type\\linalg.html"},{"title":"MethodTypeDirect – NAFPack ","text":"type, public :: MethodTypeDirect Inherited by type~~methodtypedirect~~InheritedByGraph type~methodtypedirect MethodTypeDirect type~directmethod DirectMethod type~directmethod->type~methodtypedirect method_type type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name Source Code TYPE :: MethodTypeDirect INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeDirect","tags":"","url":"type\\methodtypedirect.html"},{"title":"MethodQR – NAFPack ","text":"type, public :: MethodQR Inherited by type~~methodqr~~InheritedByGraph type~methodqr MethodQR type~directmethod DirectMethod type~directmethod->type~methodqr qr_method type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name Source Code TYPE :: MethodQR INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodQR","tags":"","url":"type\\methodqr.html"},{"title":"DirectMethodRequirements – NAFPack ","text":"type, public :: DirectMethodRequirements Inherited by type~~directmethodrequirements~~InheritedByGraph type~directmethodrequirements DirectMethodRequirements type~directmethod DirectMethod type~directmethod->type~directmethodrequirements requirements type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_non_zero_diag = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_tridiagonal = .FALSE. logical, public :: needs_symmetric = .FALSE. Source Code TYPE :: DirectMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_non_zero_diag = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_tridiagonal = . FALSE . LOGICAL :: needs_symmetric = . FALSE . END TYPE DirectMethodRequirements","tags":"","url":"type\\directmethodrequirements.html"},{"title":"IterativeParams – NAFPack ","text":"type, public :: IterativeParams Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: x_init real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: L real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: U real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: D real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: residual real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: p real(kind=dp), public :: omega = 1.d0 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: tol = 1.0d-12 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 logical, public :: is_stationary = .TRUE. real(kind=dp), public :: old_dot_product = 0.d0 logical, public :: strict_mode = .FALSE. procedure( ApplyPreconditioner ), public, PASS(params), POINTER :: precond Source Code TYPE :: IterativeParams REAL ( dp ), DIMENSION (:), ALLOCATABLE :: x_init REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: L , U , D REAL ( dp ), DIMENSION (:), ALLOCATABLE :: residual REAL ( dp ), DIMENSION (:), ALLOCATABLE :: p REAL ( dp ) :: omega = 1.d0 INTEGER :: k = 0 INTEGER :: max_iter = 1000 REAL ( dp ) :: tol = 1.0d-12 REAL ( dp ) :: alpha = 1.d0 REAL ( dp ) :: beta = 1.d0 LOGICAL :: is_stationary = . TRUE . REAL ( dp ) :: old_dot_product = 0.d0 LOGICAL :: strict_mode = . FALSE . PROCEDURE ( ApplyPreconditioner ), PASS ( params ), POINTER :: precond END TYPE IterativeParams","tags":"","url":"type\\iterativeparams.html"},{"title":"Logger – NAFPack ","text":"type, public :: Logger Components Type Visibility Attributes Name Initial logical, public :: to_terminal = .TRUE. logical, public :: to_file = .FALSE. integer, public :: frequency = 10 character(len=100), public :: filename = \"log.txt\" integer, public :: file_unit = 99 integer, public :: step = 0 logical, public :: show_iteration = .TRUE. logical, public :: show_final = .TRUE. Type-Bound Procedures procedure, public :: log => log_message private  subroutine log_message(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(len=*), intent(in) :: msg procedure, public :: init => init_logger private  subroutine init_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this procedure, public :: close => close_logger private  subroutine close_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this Source Code TYPE :: Logger LOGICAL :: to_terminal = . TRUE . LOGICAL :: to_file = . FALSE . INTEGER :: frequency = 10 CHARACTER ( LEN = 100 ) :: filename = \"log.txt\" INTEGER :: file_unit = 99 INTEGER :: step = 0 LOGICAL :: show_iteration = . TRUE . LOGICAL :: show_final = . TRUE . CONTAINS PROCEDURE :: log => log_message PROCEDURE :: init => init_logger PROCEDURE :: close => close_logger END TYPE Logger","tags":"","url":"type\\logger.html"},{"title":"DirectMethod – NAFPack ","text":"type, public :: DirectMethod Inherits type~~directmethod~~InheritsGraph type~directmethod DirectMethod type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~directmethod~~InheritedByGraph type~directmethod DirectMethod type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method, set_pivot_partial, set_pivot_total) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodTypeDirect ), intent(in) :: method logical, optional :: set_pivot_partial logical, optional :: set_pivot_total procedure, public :: set_qr_method private  subroutine set_qr_method(this, qr_method) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodQR ), intent(in) :: qr_method procedure, public :: solve => DirectMethod_solve private  function DirectMethod_solve(this, A, b) result(x) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(in) :: this real(kind=dp), intent(in), DIMENSION(:,:) :: A real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(SIZE(A, 1)) procedure, public :: test_matrix private  subroutine test_matrix(this, A, strict_mode) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this real(kind=dp), intent(in), DIMENSION(:,:) :: A logical, intent(in), optional :: strict_mode Source Code TYPE :: DirectMethod PRIVATE TYPE ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE TYPE ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT LOGICAL :: use_partial_pivot = . FALSE . LOGICAL :: use_total_pivot = . FALSE . TYPE ( DirectMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Direct ), PASS ( this ), POINTER :: solve_method => NULL () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: set_qr_method => set_qr_method PROCEDURE :: solve => DirectMethod_solve PROCEDURE :: test_matrix => test_matrix END TYPE DirectMethod","tags":"","url":"type\\directmethod.html"},{"title":"MethodTypeIterative – NAFPack ","text":"type, public :: MethodTypeIterative Inherited by type~~methodtypeiterative~~InheritedByGraph type~methodtypeiterative MethodTypeIterative type~iterativemethod IterativeMethod type~iterativemethod->type~methodtypeiterative method_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name Source Code TYPE :: MethodTypeIterative INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeIterative","tags":"","url":"type\\methodtypeiterative.html"},{"title":"IterativeMethodRequirements – NAFPack ","text":"type, public :: IterativeMethodRequirements Inherited by type~~iterativemethodrequirements~~InheritedByGraph type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod IterativeMethod type~iterativemethod->type~iterativemethodrequirements requirements type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_diag_dom = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_symetric = .FALSE. Source Code TYPE :: IterativeMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_diag_dom = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_symetric = . FALSE . END TYPE IterativeMethodRequirements","tags":"","url":"type\\iterativemethodrequirements.html"},{"title":"FFT_1D – NAFPack","text":"public  function FFT_1D(signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_DFT\": Direct Discrete Fourier Transform \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) Calls proc~~fft_1d~~CallsGraph proc~fft_1d FFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~fft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~fft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_DFT\" ) THEN result = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN result = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D","tags":"","url":"proc\\fft_1d.html"},{"title":"IFFT_1D – NAFPack","text":"public  function IFFT_1D(signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) Calls proc~~ifft_1d~~CallsGraph proc~ifft_1d IFFT_1D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~ifft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_IFFT_1D\" ) THEN result = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D","tags":"","url":"proc\\ifft_1d.html"},{"title":"FFT_2D – NAFPack","text":"public  function FFT_2D(signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2)) Calls proc~~fft_2d~~CallsGraph proc~fft_2d FFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~fft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~fft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_FFT_2D\" ) THEN result = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D","tags":"","url":"proc\\fft_2d.html"},{"title":"IFFT_2D – NAFPack","text":"public  function IFFT_2D(signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2)) Calls proc~~ifft_2d~~CallsGraph proc~ifft_2d IFFT_2D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~ifft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_IFFT_2D\" ) THEN result = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D","tags":"","url":"proc\\ifft_2d.html"},{"title":"FFT_3D – NAFPack","text":"public  function FFT_3D(signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3)) Calls proc~~fft_3d~~CallsGraph proc~fft_3d FFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~fft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~fft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION FFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D","tags":"","url":"proc\\fft_3d.html"},{"title":"IFFT_3D – NAFPack","text":"public  function IFFT_3D(signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3)) Calls proc~~ifft_3d~~CallsGraph proc~ifft_3d IFFT_3D fftw_cleanup_threads fftw_cleanup_threads proc~ifft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~ifft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D","tags":"","url":"proc\\ifft_3d.html"},{"title":"Eigen – NAFPack","text":"public  subroutine Eigen(A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Power iteration QR algorithm (with or without shift)\nThe default method is Power iteration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k Calls proc~~eigen~~CallsGraph proc~eigen Eigen proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2 norm_2 proc~normalise->proc~norm_2 proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~eigen~~CalledByGraph proc~eigen Eigen proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( PRESENT ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( PRESENT ( vp ) . AND . ( SIZE ( vp , 1 ) /= N . OR . SIZE ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( PRESENT ( vp )) vp = vp_tmp ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN IF ( PRESENT ( vp )) vp = 0 IF ( PRESENT ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = INDEX ( TRIM ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == LEN_TRIM ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen","tags":"","url":"proc\\eigen.html"},{"title":"get_default_config – NAFPack","text":"public  function get_default_config() result(config) Get default configuration Arguments None Return Value type( config_type ) Source Code FUNCTION get_default_config () RESULT ( config ) TYPE ( config_type ) :: config ! Default values are already set in the type definition ! No need to explicitly set them as they're defined in the type config = config_type ( pivot_tolerance = TOL_PIVOT , & convergence_tolerance = TOL_CONVERGENCE , & residual_tolerance = epsi , & max_iterations = kmax , & block_size = 64 , & use_openmp = . TRUE ., & use_blas = . TRUE ., & preallocate_workspace = . TRUE ., & workspace_size = 1000 , & enable_debug = . FALSE ., & enable_timing = . FALSE ., & log_file = \"nafpack.log\" , & default_direct_method = \"A_LU\" , & default_iterative_method = \"Gauss_Seidel\" , & default_preconditioner = \"ILU\" ) END FUNCTION get_default_config","tags":"","url":"proc\\get_default_config.html"},{"title":"validate_config – NAFPack","text":"public  subroutine validate_config(config, is_valid, error_msg) Validate configuration parameters Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: config logical, intent(out) :: is_valid character(len=*), intent(out) :: error_msg Source Code SUBROUTINE validate_config ( config , is_valid , error_msg ) TYPE ( config_type ), INTENT ( IN ) :: config LOGICAL , INTENT ( OUT ) :: is_valid CHARACTER ( LEN =* ), INTENT ( OUT ) :: error_msg is_valid = . TRUE . error_msg = \"\" ! Check tolerances IF ( config % pivot_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Pivot tolerance must be positive\" RETURN END IF IF ( config % convergence_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Convergence tolerance must be positive\" RETURN END IF ! Check iteration limits IF ( config % max_iterations <= 0 ) THEN is_valid = . FALSE . error_msg = \"Maximum iterations must be positive\" RETURN END IF ! Check block size IF ( config % block_size <= 0 ) THEN is_valid = . FALSE . error_msg = \"Block size must be positive\" RETURN END IF END SUBROUTINE validate_config","tags":"","url":"proc\\validate_config.html"},{"title":"Calculate_Jacobi_preconditioner – NAFPack","text":"public  function Calculate_Jacobi_preconditioner(A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Calls proc~~calculate_jacobi_preconditioner~~CallsGraph proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~diag Diag proc~calculate_jacobi_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_Jacobi_preconditioner ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: D INTEGER :: N , i N = SIZE ( A , 1 ) D = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Jacobi preconditioner\" FORALL ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) END FUNCTION Calculate_Jacobi_preconditioner","tags":"","url":"proc\\calculate_jacobi_preconditioner.html"},{"title":"Calculate_Gauss_Seidel_preconditioner – NAFPack","text":"public  function Calculate_Gauss_Seidel_preconditioner(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Calls proc~~calculate_gauss_seidel_preconditioner~~CallsGraph proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~diag Diag proc~calculate_gauss_seidel_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_Gauss_Seidel_preconditioner ( A ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N , i , j N = SIZE ( A , 1 ) L = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" FORALL ( i = 1 : SIZE ( A , 1 ), j = 1 : SIZE ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) END FUNCTION Calculate_Gauss_Seidel_preconditioner","tags":"","url":"proc\\calculate_gauss_seidel_preconditioner.html"},{"title":"Calculate_SOR_preconditioner – NAFPack","text":"public  function Calculate_SOR_preconditioner(A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Calls proc~~calculate_sor_preconditioner~~CallsGraph proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~diag Diag proc~calculate_sor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_SOR_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N , i N = SIZE ( A , 1 ) L = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in SOR preconditioner\" DO i = 1 , SIZE ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) END DO L = alpha * L END FUNCTION Calculate_SOR_preconditioner","tags":"","url":"proc\\calculate_sor_preconditioner.html"},{"title":"Calculate_JOR_preconditioner – NAFPack","text":"public  function Calculate_JOR_preconditioner(A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Calls proc~~calculate_jor_preconditioner~~CallsGraph proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~diag Diag proc~calculate_jor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_JOR_preconditioner ( A , omega , alpha ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: D INTEGER :: N , i N = SIZE ( A , 1 ) D = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in JOR preconditioner\" FORALL ( i = 1 : SIZE ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha END FUNCTION Calculate_JOR_preconditioner","tags":"","url":"proc\\calculate_jor_preconditioner.html"},{"title":"Calculate_ICF_preconditioner – NAFPack","text":"public  function Calculate_ICF_preconditioner(A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Calls proc~~calculate_icf_preconditioner~~CallsGraph proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition proc~identity_n Identity_n proc~incomplete_cholesky_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Calculate_ICF_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N N = SIZE ( A , 1 ) L = 0.d0 CALL Incomplete_Cholesky_decomposition ( A , L ) L = alpha / omega * L END FUNCTION Calculate_ICF_preconditioner","tags":"","url":"proc\\calculate_icf_preconditioner.html"},{"title":"Calculate_ILU_preconditioner – NAFPack","text":"public  subroutine Calculate_ILU_preconditioner(A, L, U, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Calls proc~~calculate_ilu_preconditioner~~CallsGraph proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner->proc~ilu_decomposition proc~identity_n Identity_n proc~ilu_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Calculate_ILU_preconditioner ( A , L , U , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )), INTENT ( OUT ) :: L , U INTEGER :: N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 CALL ILU_decomposition ( A , L , U ) L = alpha / omega * L END SUBROUTINE Calculate_ILU_preconditioner","tags":"","url":"proc\\calculate_ilu_preconditioner.html"},{"title":"Calculate_SSOR_preconditioner – NAFPack","text":"public  subroutine Calculate_SSOR_preconditioner(A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Source Code SUBROUTINE Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )), INTENT ( OUT ) :: L , D INTEGER :: N , i N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 DO i = 1 , SIZE ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) END DO L = ( alpha * omega ) / ( 2 - omega ) * L END SUBROUTINE Calculate_SSOR_preconditioner","tags":"","url":"proc\\calculate_ssor_preconditioner.html"},{"title":"is_square_matrix – NAFPack","text":"public  function is_square_matrix(A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_square_matrix ( A ) RESULT ( is_square ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_square is_square = ( SIZE ( A , 1 ) == SIZE ( A , 2 )) END FUNCTION is_square_matrix","tags":"","url":"proc\\is_square_matrix.html"},{"title":"is_symmetric – NAFPack","text":"public  function is_symmetric(A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Called by proc~~is_symmetric~~CalledByGraph proc~is_symmetric is_symmetric proc~is_spd is_SPD proc~is_spd->proc~is_symmetric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_symmetric ( A ) RESULT ( is_sym ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_sym is_sym = ALL ( A == TRANSPOSE ( A )) END FUNCTION is_symmetric","tags":"","url":"proc\\is_symmetric.html"},{"title":"is_orthogonal – NAFPack","text":"public  function is_orthogonal(A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Calls proc~~is_orthogonal~~CallsGraph proc~is_orthogonal is_orthogonal proc~identity_n Identity_n proc~is_orthogonal->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_orthogonal ( A ) RESULT ( is_orth ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_orth is_orth = ALL ( ABS ( MATMUL ( A , TRANSPOSE ( A )) - Identity_n ( SIZE ( A , 1 ))) < epsi_test ) END FUNCTION is_orthogonal","tags":"","url":"proc\\is_orthogonal.html"},{"title":"is_SPD – NAFPack","text":"public  function is_SPD(A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical Calls proc~~is_spd~~CallsGraph proc~is_spd is_SPD proc~eigen Eigen proc~is_spd->proc~eigen proc~is_symmetric is_symmetric proc~is_spd->proc~is_symmetric proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2 norm_2 proc~normalise->proc~norm_2 proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_SPD ( A , is_sym ) RESULT ( is_spd_matrix ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: is_sym REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: lambda LOGICAL :: is_spd_matrix IF ( PRESENT ( is_sym )) THEN IF (. NOT . is_sym ) THEN is_spd_matrix = . FALSE . RETURN END IF ELSE IF (. NOT . is_symmetric ( A )) THEN is_spd_matrix = . FALSE . RETURN END IF CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( MINVAL ( lambda ) < 0 ) THEN is_spd_matrix = . FALSE . ELSE is_spd_matrix = . TRUE . END IF END FUNCTION is_SPD","tags":"","url":"proc\\is_spd.html"},{"title":"is_tridiagonal – NAFPack","text":"public  function is_tridiagonal(A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_tridiagonal ( A ) RESULT ( is_tridiag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_tridiag INTEGER :: i , j , N N = SIZE ( A , 1 ) is_tridiag = . TRUE . DO i = 1 , N DO j = 1 , N IF ( ABS ( i - j ) > 1 ) THEN IF ( ABS ( A ( i , j )) > epsi ) THEN is_tridiag = . FALSE . RETURN END IF END IF END DO END DO END FUNCTION is_tridiagonal","tags":"","url":"proc\\is_tridiagonal.html"},{"title":"is_diagonally_dominant – NAFPack","text":"public  function is_diagonally_dominant(A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION is_diagonally_dominant ( A ) RESULT ( is_diag_dom ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_diag_dom INTEGER :: i , N REAL ( dp ) :: row_sum N = SIZE ( A , 1 ) is_diag_dom = . TRUE . DO i = 1 , N row_sum = SUM ( ABS ( A ( i , :))) - ABS ( A ( i , i )) IF ( ABS ( A ( i , i )) < row_sum ) THEN is_diag_dom = . FALSE . RETURN END IF END DO END FUNCTION is_diagonally_dominant","tags":"","url":"proc\\is_diagonally_dominant.html"},{"title":"is_non_zero_diagonal – NAFPack","text":"public  function is_non_zero_diagonal(A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Calls proc~~is_non_zero_diagonal~~CallsGraph proc~is_non_zero_diagonal is_non_zero_diagonal proc~diag Diag proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION is_non_zero_diagonal ( A ) RESULT ( is_non_zero_diag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_non_zero_diag is_non_zero_diag = . TRUE . IF ( ANY ( ABS ( Diag ( A )) < epsi )) is_non_zero_diag = . FALSE . END FUNCTION is_non_zero_diagonal","tags":"","url":"proc\\is_non_zero_diagonal.html"},{"title":"meshgrid – NAFPack","text":"public  subroutine meshgrid(x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: Y Source Code SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( SIZE ( y_vector ), SIZE ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid","tags":"","url":"proc\\meshgrid.html"},{"title":"ApplyPreconditioner – NAFPack","text":"public  function ApplyPreconditioner(params, method) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method Return Value real(kind=dp), DIMENSION(SIZE(params%x_init)) Calls proc~~applypreconditioner~~CallsGraph proc~applypreconditioner ApplyPreconditioner proc~backward backward proc~applypreconditioner->proc~backward proc~forward forward proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION ApplyPreconditioner ( params , method ) RESULT ( y ) CLASS ( IterativeParams ), INTENT ( IN ) :: params CLASS ( MethodPreconditioner ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( params % x_init )) :: y SELECT CASE ( method % value ) CASE ( METHOD_PRECOND_JACOBI % value ) IF (. NOT . ALLOCATED ( params % D )) STOP \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = MATMUL ( params % D , params % residual ) CASE ( METHOD_PRECOND_GS % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) CASE ( METHOD_PRECOND_SOR % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) CASE ( METHOD_PRECOND_JOR % value ) IF (. NOT . ALLOCATED ( params % D )) STOP \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = MATMUL ( params % D , params % residual ) CASE ( METHOD_PRECOND_ILU % value ) IF (. NOT . ALLOCATED ( params % L ) . OR . & . NOT . ALLOCATED ( params % U )) STOP \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , params % residual ) y = backward ( params % U , y ) CASE ( METHOD_PRECOND_ICF % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) y = backward ( TRANSPOSE ( params % L ), y ) CASE ( METHOD_PRECOND_SSOR % value ) IF (. NOT . ALLOCATED ( params % L ) . OR . & . NOT . ALLOCATED ( params % D )) STOP \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , params % residual ) y = MATMUL ( params % D , y ) y = backward ( TRANSPOSE ( params % L ), y ) CASE DEFAULT STOP \"ERROR :: Unknown preconditioner method\" END SELECT END FUNCTION ApplyPreconditioner","tags":"","url":"proc\\applypreconditioner.html"},{"title":"dot – NAFPack","text":"public  function dot(a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) Source Code FUNCTION dot ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: result INTEGER :: i IF ( SIZE ( a ) /= SIZE ( b )) STOP \"Error: Vectors must be of the same size.\" result = 0.0_dp DO i = 1 , SIZE ( a ) result = result + a ( i ) * b ( i ) END DO END FUNCTION dot","tags":"","url":"proc\\dot.html"},{"title":"cross – NAFPack","text":"public  function cross(a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 the wedge notation can sometimes be used to denote the vector product. ↩ Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) Source Code FUNCTION cross ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross","tags":"","url":"proc\\cross.html"},{"title":"norm_2 – NAFPack","text":"public  function norm_2(a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2~~CalledByGraph proc~norm_2 norm_2 proc~normalise normalise proc~normalise->proc~norm_2 proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2 ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( DOT_PRODUCT ( a , a )) END FUNCTION norm_2","tags":"","url":"proc\\norm_2.html"},{"title":"norm_2_complex – NAFPack","text":"public  function norm_2_complex(a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_complex~~CalledByGraph proc~norm_2_complex norm_2_complex proc~normalise_complexe normalise_complexe proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION norm_2_complex ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( REAL ( DOT_PRODUCT ( a , CONJG ( a )))) END FUNCTION norm_2_complex","tags":"","url":"proc\\norm_2_complex.html"},{"title":"normalise – NAFPack","text":"public  function normalise(a) result(result) function that normalises a real vector a to make it a unit vector, \nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a)) Calls proc~~normalise~~CallsGraph proc~normalise normalise proc~norm_2 norm_2 proc~normalise->proc~norm_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~normalise~~CalledByGraph proc~normalise normalise proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2 ( a ) END FUNCTION normalise","tags":"","url":"proc\\normalise.html"},{"title":"normalise_complexe – NAFPack","text":"public  function normalise_complexe(a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a)) Calls proc~~normalise_complexe~~CallsGraph proc~normalise_complexe normalise_complexe proc~norm_2_complex norm_2_complex proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION normalise_complexe ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2_complex ( a ) END FUNCTION normalise_complexe","tags":"","url":"proc\\normalise_complexe.html"},{"title":"Trace – NAFPack","text":"public  function Trace(A) result(result) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp) Called by proc~~trace~~CalledByGraph proc~trace Trace proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Trace ( A ) RESULT ( result ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ) :: result INTEGER :: i , N N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"Error: Matrix must be square.\" result = SUM ([( A ( i , i ), i = 1 , N )]) END FUNCTION Trace","tags":"","url":"proc\\trace.html"},{"title":"Diagonally_Dominant_Matrix – NAFPack","text":"public  function Diagonally_Dominant_Matrix(A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical Source Code FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = SIZE ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = SUM ( ABS ( A ( i , :) - A ( i , i ))) if ( ABS ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix","tags":"","url":"proc\\diagonally_dominant_matrix.html"},{"title":"Identity_n – NAFPack","text":"public  function Identity_n(N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) Called by proc~~identity_n~~CalledByGraph proc~identity_n Identity_n proc~eigen Eigen proc~eigen->proc~identity_n proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~identity_n proc~ilu_decomposition ILU_decomposition proc~ilu_decomposition->proc~identity_n proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~incomplete_cholesky_decomposition->proc~identity_n proc~is_orthogonal is_orthogonal proc~is_orthogonal->proc~identity_n proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~ldl_cholesky_decomposition->proc~identity_n proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~calculate_ilu_preconditioner->proc~ilu_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_decomposition->proc~qr_householder_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( PRESENT ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n","tags":"","url":"proc\\identity_n.html"},{"title":"Diag – NAFPack","text":"public  function Diag(A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:,:) :: A Return Value real(kind=dp), DIMENSION(SIZE(A,1)) Called by proc~~diag~~CalledByGraph proc~diag Diag proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~calculate_gauss_seidel_preconditioner->proc~diag proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~calculate_jacobi_preconditioner->proc~diag proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~calculate_jor_preconditioner->proc~diag proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~calculate_sor_preconditioner->proc~diag proc~is_non_zero_diagonal is_non_zero_diagonal proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION Diag ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: D INTEGER :: i , N N = SIZE ( A , 1 ) FORALL ( i = 1 : N ) D ( i ) = A ( i , i ) END FUNCTION Diag","tags":"","url":"proc\\diag.html"},{"title":"rotation_matrix – NAFPack","text":"public  function rotation_matrix(A, rotation) result(G) Function to create a rotation matrix This function generates a rotation matrix G based on the input matrix A and the specified rotation indices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(SIZE(A, 1),SIZE(A, 2)) Calls proc~~rotation_matrix~~CallsGraph proc~rotation_matrix rotation_matrix proc~identity_n Identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation_matrix~~CalledByGraph proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( SIZE ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = SQRT ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix","tags":"","url":"proc\\rotation_matrix.html"},{"title":"forward – NAFPack","text":"public  function forward(L, b) result(y) forward algorithm, \nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(SIZE(L, 1)) Called by proc~~forward~~CalledByGraph proc~forward forward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( L , 1 )) :: y INTEGER :: i , N N = SIZE ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward","tags":"","url":"proc\\forward.html"},{"title":"backward – NAFPack","text":"public  function backward(U, y) result(x) backward algorithm, \nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(SIZE(U, 1)) Called by proc~~backward~~CalledByGraph proc~backward backward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~backward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( SIZE ( U , 1 )) :: x INTEGER :: i , N N = SIZE ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - DOT_PRODUCT ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward","tags":"","url":"proc\\backward.html"},{"title":"LU_decomposition – NAFPack","text":"public  subroutine LU_decomposition(A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U Source Code SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition","tags":"","url":"proc\\lu_decomposition.html"},{"title":"LDU_decomposition – NAFPack","text":"public  subroutine LDU_decomposition(A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U Source Code SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [ ( D ( k , k ), k = 1 , i - 1 ) ])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition","tags":"","url":"proc\\ldu_decomposition.html"},{"title":"ILU_decomposition – NAFPack","text":"public  subroutine ILU_decomposition(A, L, U) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: U Calls proc~~ilu_decomposition~~CallsGraph proc~ilu_decomposition ILU_decomposition proc~identity_n Identity_n proc~ilu_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ilu_decomposition~~CalledByGraph proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~calculate_ilu_preconditioner->proc~ilu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE ILU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U LOGICAL , DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: S INTEGER :: i , j , N N = SIZE ( A , 1 ) L = Identity_n ( N ) U = 0.d0 S = A /= 0 DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO DO j = i , N IF ( S ( i , j )) U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO END DO END SUBROUTINE ILU_decomposition","tags":"","url":"proc\\ilu_decomposition.html"},{"title":"Cholesky_decomposition – NAFPack","text":"public  subroutine Cholesky_decomposition(A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L Source Code SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = SIZE ( A , 1 ) DO j = 1 , N L ( j , j ) = SQRT ( A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition","tags":"","url":"proc\\cholesky_decomposition.html"},{"title":"LDL_Cholesky_decomposition – NAFPack","text":"public  subroutine LDL_Cholesky_decomposition(A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: D Calls proc~~ldl_cholesky_decomposition~~CallsGraph proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~identity_n Identity_n proc~ldl_cholesky_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE LDL_Cholesky_decomposition ( A , L , D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , D INTEGER :: i , j , N , k N = SIZE ( A , 1 ) L = Identity_n ( N ) D = 0.d0 DO j = 1 , N D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDL_Cholesky_decomposition","tags":"","url":"proc\\ldl_cholesky_decomposition.html"},{"title":"Incomplete_Cholesky_decomposition – NAFPack","text":"public  subroutine Incomplete_Cholesky_decomposition(A, L) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L Calls proc~~incomplete_cholesky_decomposition~~CallsGraph proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~identity_n Identity_n proc~incomplete_cholesky_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~incomplete_cholesky_decomposition~~CalledByGraph proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE Incomplete_Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L LOGICAL , DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: S INTEGER :: i , j , N N = SIZE ( A , 1 ) L = Identity_n ( N ) S = A /= 0 DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO IF ( S ( i , i )) L ( i , i ) = SQRT ( A ( i , i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) END DO END SUBROUTINE Incomplete_Cholesky_decomposition","tags":"","url":"proc\\incomplete_cholesky_decomposition.html"},{"title":"QR_decomposition – NAFPack","text":"public  subroutine QR_decomposition(A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Calls proc~~qr_decomposition~~CallsGraph proc~qr_decomposition QR_decomposition proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_decomposition~~CalledByGraph proc~qr_decomposition QR_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) END IF END SUBROUTINE QR_decomposition","tags":"","url":"proc\\qr_decomposition.html"},{"title":"QR_Householder_decomposition – NAFPack","text":"public  subroutine QR_Householder_decomposition(A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Calls proc~~qr_householder_decomposition~~CallsGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~identity_n Identity_n proc~qr_householder_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_householder_decomposition~~CalledByGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Householder_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = SIZE ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = NORM2 ( R ( k : N , k )) signe = - SIGN ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = NORM2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = MATMUL ( Q , H ) R ( k : N , k : N ) = MATMUL ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder_decomposition","tags":"","url":"proc\\qr_householder_decomposition.html"},{"title":"QR_Givens_decomposition – NAFPack","text":"public  subroutine QR_Givens_decomposition(A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Calls proc~~qr_givens_decomposition~~CallsGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_givens_decomposition~~CalledByGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Givens_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: G INTEGER :: N , i , j N = SIZE ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = MATMUL ( G , R ) Q = MATMUL ( Q , TRANSPOSE ( G )) END DO END DO END SUBROUTINE QR_Givens_decomposition","tags":"","url":"proc\\qr_givens_decomposition.html"},{"title":"QR_Gram_Schmidt_Classical_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Classical_decomposition(A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Called by proc~~qr_gram_schmidt_classical_decomposition~~CalledByGraph proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) Q = 0.d0 R = 0.d0 DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = DOT_PRODUCT ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = NORM2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical_decomposition","tags":"","url":"proc\\qr_gram_schmidt_classical_decomposition.html"},{"title":"QR_Gram_Schmidt_Modified_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Modified_decomposition(A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R Called by proc~~qr_gram_schmidt_modified_decomposition~~CalledByGraph proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = NORM2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = DOT_PRODUCT ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified_decomposition","tags":"","url":"proc\\qr_gram_schmidt_modified_decomposition.html"},{"title":"Faddeev_Leverrier – NAFPack","text":"public  subroutine Faddeev_Leverrier(A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: c real(kind=dp), intent(out), optional, DIMENSION(SIZE(A,1), SIZE(A,1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check Calls proc~~faddeev_leverrier~~CallsGraph proc~faddeev_leverrier Faddeev_Leverrier proc~identity_n Identity_n proc~faddeev_leverrier->proc~identity_n proc~trace Trace proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = KIND(1.0d0) real(kind=dp), public, DIMENSION(SIZE(A,1), SIZE(A,1)) :: Bk real(kind=dp), public, DIMENSION(SIZE(A,1), SIZE(A,1)) :: I real(kind=dp), public, DIMENSION(SIZE(A,1), SIZE(A,1)) :: B_Nm1 real(kind=dp), public, DIMENSION(SIZE(A,1), SIZE(A,1)) :: AB logical, public :: do_check = .TRUE. integer, public :: N integer, public :: k Source Code SUBROUTINE Faddeev_Leverrier ( A , c , Ainv , success , check ) INTEGER , PARAMETER :: dp = KIND ( 1.0d0 ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: c REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), OPTIONAL , INTENT ( OUT ) :: Ainv LOGICAL , OPTIONAL , INTENT ( OUT ) :: success REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: Bk , I , B_Nm1 , AB LOGICAL :: do_check = . TRUE . INTEGER :: N , k N = SIZE ( A , 1 ) IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is square and size of c is correct\" IF ( SIZE ( A , 2 ) /= N . OR . SIZE ( c ) < N + 1 ) THEN PRINT * , \"Error : Matrix A must be square and size of c must be at least N+1\" STOP END IF END IF ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I DO k = 2 , N AB = MATMUL ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / REAL ( k , dp ) Bk = AB + c ( k + 1 ) * I IF ( k == N - 1 . AND . PRESENT ( Ainv )) B_Nm1 = - Bk END DO IF ( PRESENT ( Ainv ) . AND . PRESENT ( success )) THEN IF ( ABS ( c ( N + 1 )) < 1.0e-12_dp ) THEN success = . FALSE . Ainv = 0.0_dp ELSE success = . TRUE . Ainv = B_Nm1 / c ( N + 1 ) END IF ELSE IF ( PRESENT ( Ainv )) THEN IF ( ABS ( c ( N + 1 )) < 1.0e-12_dp ) THEN Ainv = 0.0_dp ELSE Ainv = B_Nm1 / c ( N + 1 ) END IF END IF END SUBROUTINE Faddeev_Leverrier","tags":"","url":"proc\\faddeev_leverrier.html"},{"title":"NAFPack_constant – NAFPack","text":"Module for defining constants used in NAFPack This module includes mathematical constants, colors for terminal output,\nand other parameters that are used throughout the NAFPack library. Uses iso_fortran_env module~~nafpack_constant~~UsesGraph module~nafpack_constant NAFPack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_constant~~UsedByGraph module~nafpack_constant NAFPack_constant module~nafpack_config NAFPack_config module~nafpack_config->module~nafpack_constant module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_constant module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_fft NAFPack_fft module~nafpack_fft->module~nafpack_constant module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = ACOS(-1.d0) constant complex(kind=dp), public, parameter :: im = (0.d0, 1.d0) Imaginary unit real(kind=dp), public, parameter :: epsi = 1.d-12 Small value real(kind=dp), public, parameter :: epsi_test = 1.d-6 Small value integer, public, parameter :: kmax = 10000 Maximum number of iterations for iterative methods character(len=*), public, parameter :: status_len = REPEAT(\" \", 15) len of status messages character(len=10), public :: red_color = CHAR(27)//\"[31m\" red colors for terminal output character(len=10), public :: green_color = CHAR(27)//\"[32m\" green colors for terminal output character(len=10), public :: yellow_color = CHAR(27)//\"[33m\" yellow colors for terminal output character(len=10), public :: blue_color = CHAR(27)//\"[34m\" blue colors for terminal output character(len=10), public :: purple_color = CHAR(27)//\"[35m\" purple colors for terminal output character(len=10), public :: cyan_color = CHAR(27)//\"[36m\" cyan colors for terminal output character(len=10), public :: white_color = CHAR(27)//\"[37m\" white colors for terminal output character(len=10), public :: reset_color = CHAR(27)//\"[0m\" reset colors for terminal output integer, public, parameter :: NAF_SUCCESS = 0 Error codes for better error handling integer, public, parameter :: NAF_ERROR_DIMENSION = 1 integer, public, parameter :: NAF_ERROR_SINGULAR = 2 integer, public, parameter :: NAF_ERROR_CONVERGENCE = 3 integer, public, parameter :: NAF_ERROR_MEMORY = 4 integer, public, parameter :: NAF_ERROR_INVALID_METHOD = 5 real(kind=dp), public, parameter :: TOL_PIVOT = 1.0e-14_dp Improved tolerance parameters real(kind=dp), public, parameter :: TOL_CONVERGENCE = 1.0e-12_dp","tags":"","url":"module\\nafpack_constant.html"},{"title":"NAFPack_fft – NAFPack","text":"Module for Fourier Transform This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals.\nIt supports both forward and inverse transforms.\nIt allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. Uses NAFPack_constant FFTW3 module~~nafpack_fft~~UsesGraph module~nafpack_fft NAFPack_fft FFTW3 FFTW3 module~nafpack_fft->FFTW3 module~nafpack_constant NAFPack_constant module~nafpack_fft->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function FFT_1D (signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function IFFT_1D (signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function FFT_2D (signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2)) public  function IFFT_2D (signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2)) public  function FFT_3D (signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3)) public  function IFFT_3D (signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3))","tags":"","url":"module\\nafpack_fft.html"},{"title":"NAFPack_Iterative_methods – NAFPack","text":"Module for iterative methods in NAFPack Uses NAFPack_matricielle NAFPack_Iterative_types NAFPack_Preconditioners NAFPack_Iterative_Params NAFPack_matrix_decomposition NAFPack_constant NAFPack_matrix_properties NAFPack_Logger_mod module~~nafpack_iterative_methods~~UsesGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_constant NAFPack_constant module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_matricielle NAFPack_matricielle module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_methods~~UsedByGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: solve => IterativeMethod_solve procedure, public :: Init_IterativeParams procedure, public :: Dealocate_IterativeParams procedure, public :: test_matrix","tags":"","url":"module\\nafpack_iterative_methods.html"},{"title":"NAFPack_Eigen – NAFPack","text":"Module for eigenvalue and eigenvector computations in NAFPack Uses NAFPack_constant NAFPack_matrix_decomposition NAFPack_matricielle module~~nafpack_eigen~~UsesGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_constant NAFPack_constant module~nafpack_eigen->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_eigen~~UsedByGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Eigen (A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"module\\nafpack_eigen.html"},{"title":"NAFPack_config – NAFPack","text":"Module for advanced configuration and tuning parameters Uses NAFPack_constant module~~nafpack_config~~UsesGraph module~nafpack_config NAFPack_config module~nafpack_constant NAFPack_constant module~nafpack_config->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: config_type Configuration type for NAFPack Components Type Visibility Attributes Name Initial real(kind=dp), public :: pivot_tolerance = 1.0e-14_dp real(kind=dp), public :: convergence_tolerance = 1.0e-12_dp real(kind=dp), public :: residual_tolerance = 1.0e-10_dp integer, public :: max_iterations = 10000 integer, public :: block_size = 64 logical, public :: use_openmp = .TRUE. logical, public :: use_blas = .TRUE. logical, public :: preallocate_workspace = .TRUE. integer, public :: workspace_size = 1000 logical, public :: enable_debug = .FALSE. logical, public :: enable_timing = .FALSE. character(len=100), public :: log_file = \"nafpack.log\" character(len=50), public :: default_direct_method = \"A_LU\" character(len=50), public :: default_iterative_method = \"Gauss_Seidel\" character(len=50), public :: default_preconditioner = \"ILU\" Functions public  function get_default_config () result(config) Get default configuration Arguments None Return Value type( config_type ) Subroutines public  subroutine validate_config (config, is_valid, error_msg) Validate configuration parameters Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: config logical, intent(out) :: is_valid character(len=*), intent(out) :: error_msg","tags":"","url":"module\\nafpack_config.html"},{"title":"NAFPack_Preconditioners – NAFPack","text":"Uses NAFPack_constant NAFPack_Iterative_types NAFPack_matricielle NAFPack_matrix_decomposition module~~nafpack_preconditioners~~UsesGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_constant NAFPack_constant module~nafpack_preconditioners->module~nafpack_constant module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_matricielle NAFPack_matricielle module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_types->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_preconditioners~~UsedByGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_NONE = MethodPreconditioner(0, \"None\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, \"Jacobi\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_GS = MethodPreconditioner(2, \"Gauss-Seidel\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SOR = MethodPreconditioner(3, \"Successive Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JOR = MethodPreconditioner(4, \"Jacobi Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ILU = MethodPreconditioner(5, \"ILU\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ICF = MethodPreconditioner(6, \"ICF\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SSOR = MethodPreconditioner(7, \"SSOR\") Derived Types type, public :: MethodPreconditioner Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name Functions public  function Calculate_Jacobi_preconditioner (A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) public  function Calculate_Gauss_Seidel_preconditioner (A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) public  function Calculate_SOR_preconditioner (A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) public  function Calculate_JOR_preconditioner (A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) public  function Calculate_ICF_preconditioner (A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), DIMENSION(SIZE(A, 1), SIZE(A, 2)) Subroutines public  subroutine Calculate_ILU_preconditioner (A, L, U, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha public  subroutine Calculate_SSOR_preconditioner (A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha","tags":"","url":"module\\nafpack_preconditioners.html"},{"title":"NAFPack_matrix_properties – NAFPack","text":"Uses NAFPack_constant NAFPack_matricielle NAFPack_Eigen module~~nafpack_matrix_properties~~UsesGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_constant NAFPack_constant module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_properties~~UsedByGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function is_square_matrix (A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_symmetric (A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_orthogonal (A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_SPD (A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical public  function is_tridiagonal (A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_diagonally_dominant (A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function is_non_zero_diagonal (A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical","tags":"","url":"module\\nafpack_matrix_properties.html"},{"title":"NAFPack_linalg – NAFPack","text":"Uses NAFPack_Iterative_types NAFPack_Direct_method NAFPack_Direct_types NAFPack_Iterative_methods module~~nafpack_linalg~~UsesGraph module~nafpack_linalg NAFPack_linalg module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg->module~nafpack_direct_method module~nafpack_direct_types NAFPack_Direct_types module~nafpack_linalg->module~nafpack_direct_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_methods->module~nafpack_constant module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_matricielle NAFPack_matricielle module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_logger_mod->module~nafpack_constant module~nafpack_matricielle->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: linalg Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative","tags":"","url":"module\\nafpack_linalg.html"},{"title":"NAFPack_meshgrid – NAFPack","text":"Module for creating a meshgrid from two vectors This module provides a subroutine to create a meshgrid. Uses NAFPack_constant module~~nafpack_meshgrid~~UsesGraph module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_constant NAFPack_constant module~nafpack_meshgrid->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine meshgrid (x_vector, y_vector, X, Y) Make N-dimensional meshgrid from two vectors x_vector and y_vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x_vector real(kind=dp), intent(in), DIMENSION(:) :: y_vector real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: X real(kind=dp), intent(out), DIMENSION(SIZE(y_vector), SIZE(x_vector)) :: Y","tags":"","url":"module\\nafpack_meshgrid.html"},{"title":"NAFPack_Direct_types – NAFPack","text":"Used by module~~nafpack_direct_types~~UsedByGraph module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_types module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeDirect ), public, parameter :: METHOD_DIRECT_NONE = MethodTypeDirect(0, \"None\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss = MethodTypeDirect(1, \"Gauss\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss_JORDAN = MethodTypeDirect(2, \"Gauss-Jordan\") type( MethodTypeDirect ), public, parameter :: METHOD_LU = MethodTypeDirect(3, \"LU\") type( MethodTypeDirect ), public, parameter :: METHOD_LDU = MethodTypeDirect(4, \"LDU\") type( MethodTypeDirect ), public, parameter :: METHOD_CHOLESKY = MethodTypeDirect(5, \"Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_LDL_Cholesky = MethodTypeDirect(6, \"LDL-Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_QR = MethodTypeDirect(7, \"QR\") type( MethodTypeDirect ), public, parameter :: METHOD_TDMA = MethodTypeDirect(8, \"TDMA\") type( MethodTypeDirect ), public, parameter :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect(9, \"Faddeev-Leverrier\") type( MethodQR ), public, parameter :: QR_HOUSEHOLDER = MethodQR(1, \"Householder\") type( MethodQR ), public, parameter :: QR_GIVENS = MethodQR(2, \"Givens\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT = MethodQR(3, \"Gram-Schmidt\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT_Modified = MethodQR(4, \"Gram_Schmidt_Modified\") Derived Types type, public :: MethodTypeDirect Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name type, public :: MethodQR Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name type, public :: DirectMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_non_zero_diag = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_tridiagonal = .FALSE. logical, public :: needs_symmetric = .FALSE.","tags":"","url":"module\\nafpack_direct_types.html"},{"title":"NAFPack_Iterative_Params – NAFPack","text":"Uses NAFPack_constant NAFPack_Iterative_types NAFPack_matrix_decomposition NAFPack_Preconditioners module~~nafpack_iterative_params~~UsesGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_constant NAFPack_constant module~nafpack_iterative_params->module~nafpack_constant module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_params->module~nafpack_preconditioners iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_iterative_types->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_iterative_types module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_params~~UsedByGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeParams Components Type Visibility Attributes Name Initial real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: x_init real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: L real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: U real(kind=dp), public, DIMENSION(:,:), ALLOCATABLE :: D real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: residual real(kind=dp), public, DIMENSION(:), ALLOCATABLE :: p real(kind=dp), public :: omega = 1.d0 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: tol = 1.0d-12 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 logical, public :: is_stationary = .TRUE. real(kind=dp), public :: old_dot_product = 0.d0 logical, public :: strict_mode = .FALSE. procedure( ApplyPreconditioner ), public, PASS(params), POINTER :: precond Functions public  function ApplyPreconditioner (params, method) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method Return Value real(kind=dp), DIMENSION(SIZE(params%x_init))","tags":"","url":"module\\nafpack_iterative_params.html"},{"title":"NAFPack_matricielle – NAFPack","text":"Module for Tensor operations in NAFPack Uses NAFPack_constant module~~nafpack_matricielle~~UsesGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_constant NAFPack_constant module~nafpack_matricielle->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matricielle~~UsedByGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matricielle module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function dot (a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: a real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp) public  function cross (a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) public  function norm_2 (a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function norm_2_complex (a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function normalise (a) result(result) function that normalises a real vector a to make it a unit vector, \nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a)) public  function normalise_complexe (a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a)) public  function Trace (A) result(result) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value real(kind=dp) public  function Diagonally_Dominant_Matrix (A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function Identity_n (N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N) public  function Diag (A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:,:) :: A Return Value real(kind=dp), DIMENSION(SIZE(A,1)) public  function rotation_matrix (A, rotation) result(G) Function to create a rotation matrix Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A integer, intent(in), DIMENSION(2) :: rotation Return Value real(kind=dp), DIMENSION(SIZE(A, 1),SIZE(A, 2))","tags":"","url":"module\\nafpack_matricielle.html"},{"title":"NAFPack_matrix_decomposition – NAFPack","text":"Module for matrix decomposition methods This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. Uses NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_decomposition~~UsesGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_decomposition~~UsedByGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_matrix_properties->module~nafpack_eigen Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function forward (L, b) result(y) forward algorithm, \nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: L real(kind=dp), intent(in), DIMENSION(:) :: b Return Value real(kind=dp), DIMENSION(SIZE(L, 1)) public  function backward (U, y) result(x) backward algorithm, \nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: U real(kind=dp), intent(in), DIMENSION(:) :: y Return Value real(kind=dp), DIMENSION(SIZE(U, 1)) Subroutines public  subroutine LU_decomposition (A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine LDU_decomposition (A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine ILU_decomposition (A, L, U) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: U public  subroutine Cholesky_decomposition (A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L public  subroutine LDL_Cholesky_decomposition (A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: D public  subroutine Incomplete_Cholesky_decomposition (A, L) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L public  subroutine QR_decomposition (A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R public  subroutine QR_Householder_decomposition (A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R public  subroutine QR_Givens_decomposition (A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Classical_decomposition (A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Modified_decomposition (A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R","tags":"","url":"module\\nafpack_matrix_decomposition.html"},{"title":"NAFPack_Logger_mod – NAFPack","text":"Uses NAFPack_constant module~~nafpack_logger_mod~~UsesGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_constant NAFPack_constant module~nafpack_logger_mod->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_logger_mod~~UsedByGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: Logger Components Type Visibility Attributes Name Initial logical, public :: to_terminal = .TRUE. logical, public :: to_file = .FALSE. integer, public :: frequency = 10 character(len=100), public :: filename = \"log.txt\" integer, public :: file_unit = 99 integer, public :: step = 0 logical, public :: show_iteration = .TRUE. logical, public :: show_final = .TRUE. Type-Bound Procedures procedure, public :: log => log_message procedure, public :: init => init_logger procedure, public :: close => close_logger","tags":"","url":"module\\nafpack_logger_mod.html"},{"title":"NAFPack_matrix_tools – NAFPack","text":"Uses NAFPack_constant NAFPack_matricielle module~~nafpack_matrix_tools~~UsesGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_constant NAFPack_constant module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_tools->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_tools~~UsedByGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Faddeev_Leverrier (A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: c real(kind=dp), intent(out), optional, DIMENSION(SIZE(A,1), SIZE(A,1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check","tags":"","url":"module\\nafpack_matrix_tools.html"},{"title":"NAFPack_Direct_method – NAFPack","text":"Module for direct methods in NAFPack Uses NAFPack_Direct_types NAFPack_matrix_decomposition NAFPack_matrix_tools NAFPack_constant NAFPack_matrix_properties module~~nafpack_direct_method~~UsesGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_tools->module~nafpack_constant module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matricielle->module~nafpack_constant Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_direct_method~~UsedByGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: DirectMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: set_qr_method procedure, public :: solve => DirectMethod_solve procedure, public :: test_matrix","tags":"","url":"module\\nafpack_direct_method.html"},{"title":"NAFPack_Iterative_types – NAFPack","text":"Uses NAFPack_constant module~~nafpack_iterative_types~~UsesGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_constant NAFPack_constant module~nafpack_iterative_types->module~nafpack_constant iso_fortran_env iso_fortran_env module~nafpack_constant->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_types~~UsedByGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_preconditioners->module~nafpack_iterative_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeIterative ), public, parameter :: METHOD_ITERATIVE_NONE = MethodTypeIterative(0, \"None\") type( MethodTypeIterative ), public, parameter :: METHOD_Jacobi = MethodTypeIterative(1, \"Jacobi\") type( MethodTypeIterative ), public, parameter :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, \"Gauss-Seidel\") type( MethodTypeIterative ), public, parameter :: METHOD_SOR = MethodTypeIterative(3, \"Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_JOR = MethodTypeIterative(4, \"Jacobi Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ILU = MethodTypeIterative(5, \"Strongly Implicit Procedure with ILU\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ICF = MethodTypeIterative(6, \"Strongly Implicit Procedure with ICF\") type( MethodTypeIterative ), public, parameter :: METHOD_SSOR = MethodTypeIterative(7, \"Symmetric Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_RICHARDSON = MethodTypeIterative(8, \"Richardson\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, \"Conjugate Gradient\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, \"Conjugate Residual\") Derived Types type, public :: MethodTypeIterative Components Type Visibility Attributes Name Initial integer, public :: value character(len=64), public :: name type, public :: IterativeMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .FALSE. logical, public :: needs_diag_dom = .FALSE. logical, public :: needs_square = .FALSE. logical, public :: needs_symetric = .FALSE.","tags":"","url":"module\\nafpack_iterative_types.html"},{"title":"NAFPack_constant.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_constant.f90~~AfferentGraph sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_config.f90 NAFPack_config.f90 sourcefile~nafpack_config.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for defining constants used in NAFPack !> !> This module includes mathematical constants, colors for terminal output, !> and other parameters that are used throughout the NAFPack library. MODULE NAFPack_constant USE , INTRINSIC :: iso_fortran_env , ONLY : sp => real32 , dp => real64 , isp => int32 , idp => int64 IMPLICIT NONE PRIVATE PUBLIC :: pi , im , epsi , kmax , sp , dp , epsi_test , idp , isp PUBLIC :: status_len PUBLIC :: red_color , green_color , yellow_color , blue_color , white_color , cyan_color , purple_color , reset_color PUBLIC :: NAF_SUCCESS , NAF_ERROR_DIMENSION , NAF_ERROR_SINGULAR , NAF_ERROR_CONVERGENCE , NAF_ERROR_MEMORY , & NAF_ERROR_INVALID_METHOD PUBLIC :: TOL_PIVOT , TOL_CONVERGENCE !>  \\pi  constant REAL ( dp ), PARAMETER :: pi = ACOS ( - 1.d0 ) !> Imaginary unit  i&#94;2 = -1  COMPLEX ( dp ), PARAMETER :: im = ( 0.d0 , 1.d0 ) !> Small  \\epsilon  value REAL ( dp ), PARAMETER :: epsi = 1.d-12 , epsi_test = 1.d-6 !> Maximum number of iterations for iterative methods INTEGER , PARAMETER :: kmax = 10000 !> len of status messages CHARACTER ( LEN = * ), PARAMETER :: status_len = REPEAT ( \" \" , 15 ) !> red colors for terminal output CHARACTER ( len = 10 ) :: red_color = CHAR ( 27 ) // \"[31m\" !> green colors for terminal output CHARACTER ( len = 10 ) :: green_color = CHAR ( 27 ) // \"[32m\" !> yellow colors for terminal output CHARACTER ( len = 10 ) :: yellow_color = CHAR ( 27 ) // \"[33m\" !> blue colors for terminal output CHARACTER ( len = 10 ) :: blue_color = CHAR ( 27 ) // \"[34m\" !> purple colors for terminal output CHARACTER ( len = 10 ) :: purple_color = CHAR ( 27 ) // \"[35m\" !> cyan colors for terminal output CHARACTER ( len = 10 ) :: cyan_color = CHAR ( 27 ) // \"[36m\" !> white colors for terminal output CHARACTER ( len = 10 ) :: white_color = CHAR ( 27 ) // \"[37m\" !> reset colors for terminal output CHARACTER ( len = 10 ) :: reset_color = CHAR ( 27 ) // \"[0m\" !> Error codes for better error handling INTEGER , PARAMETER :: NAF_SUCCESS = 0 INTEGER , PARAMETER :: NAF_ERROR_DIMENSION = 1 INTEGER , PARAMETER :: NAF_ERROR_SINGULAR = 2 INTEGER , PARAMETER :: NAF_ERROR_CONVERGENCE = 3 INTEGER , PARAMETER :: NAF_ERROR_MEMORY = 4 INTEGER , PARAMETER :: NAF_ERROR_INVALID_METHOD = 5 !> Improved tolerance parameters REAL ( dp ), PARAMETER :: TOL_PIVOT = 1.0e-14_dp REAL ( dp ), PARAMETER :: TOL_CONVERGENCE = 1.0e-12_dp END MODULE NAFPack_constant","tags":"","url":"sourcefile\\nafpack_constant.f90.html"},{"title":"NAFPack_fft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fft.f90~~EfferentGraph sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Fourier Transform !>  F(\\omega) = \\int_{-\\infty}&#94;{\\infty} f(t) e&#94;{-i \\omega t} dt  !> This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals. !> It supports both forward and inverse transforms. !> It allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. MODULE NAFPack_fft USE FFTW3 USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: FFT_1D , FFT_2D , FFT_3D PUBLIC :: IFFT_1D , IFFT_2D , IFFT_3D CONTAINS !> Perform a 1D Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_DFT\": Direct Discrete Fourier Transform !> - \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_DFT\" ) THEN result = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN result = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_IFFT_1D\" ) THEN result = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_FFT_2D\" ) THEN result = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_IFFT_2D\" ) THEN result = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D !> Perform a 3D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION FFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D !################### FFTW ########################################## !> Perform a 1D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_1D_threads !> Perform a 1D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_1D_threads !> Perform a 2D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_2D !> Perform a 2D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_2D_threads !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_2D_threads !> Perform a 3D Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_FFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_3D !> Perform a 3D Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_FFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_3D_threads !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW FUNCTION FFTW_IFFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW with multithreading FUNCTION FFTW_IFFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_3D_threads !################### NAFPack ########################################## !> Perform a 1D Discrete Fourier Transform on a signal FUNCTION NAFPack_DFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ) :: S INTEGER :: N , i , k , j N = SIZE ( signal ) IF ( N == 1 ) THEN result = signal ELSE DO i = 1 , N k = i - 1 S = ( 0.d0 , 0.d0 ) DO j = 1 , N S = S + signal ( j ) * EXP (( - 2 * pi * im * k * ( j - 1 )) / N ) END DO result ( i ) = S END DO END IF END FUNCTION NAFPack_DFT_1D !> Compute the complex exponential factors for the FFT FUNCTION fun_omega ( N ) RESULT ( result ) INTEGER , INTENT ( IN ) :: N COMPLEX ( dp ), DIMENSION ( N / 2 ) :: result INTEGER :: i DO i = 1 , N / 2 result ( i ) = EXP ( - 2 * Im * pi * ( i - 1 ) / N ) END DO END FUNCTION fun_omega !> Perform a 1D Fast Fourier Transform (Cooley-Tukey) on a signal RECURSIVE FUNCTION NAFPack_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( signal ) / 2 ) :: f_pair , f_impair , omega INTEGER :: N N = SIZE ( signal ) IF ( MOD ( N , 2 ) == 0 ) THEN f_pair = NAFPack_FFT_1D ( signal ( 1 :: 2 )) f_impair = NAFPack_FFT_1D ( signal ( 2 :: 2 )) omega = fun_omega ( N ) result ( 1 : N / 2 ) = f_pair + f_impair * omega result ( N / 2 + 1 :) = f_pair - f_impair * omega ELSE result = NAFPack_DFT_1D ( signal ) END IF END FUNCTION NAFPack_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_1D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: f_conjugate INTEGER :: N N = SIZE ( f_signal ) f_conjugate = CONJG ( f_signal ) result = NAFPack_FFT_1D ( f_conjugate ) result = CONJG ( result ) result = result / N END FUNCTION NAFPack_IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal FUNCTION NAFPack_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( signal , 1 ) Ny = SIZE ( signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_FFT_1D ( signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_FFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal FUNCTION NAFPack_IFFT_2D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal , 1 ), SIZE ( f_signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( f_signal , 1 ) Ny = SIZE ( f_signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_IFFT_1D ( f_signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_IFFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_IFFT_2D END MODULE NAFPack_fft","tags":"","url":"sourcefile\\nafpack_fft.f90.html"},{"title":"NAFPack_Iterative_methods.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_methods.f90~~EfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_methods.f90~~AfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for iterative methods in NAFPack MODULE NAFPack_Iterative_methods USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle USE NAFPack_Iterative_types USE NAFPack_Logger_mod USE NAFPack_Preconditioners USE NAFPack_Iterative_Params USE NAFPack_matrix_properties IMPLICIT NONE PRIVATE PUBLIC :: IterativeMethod PUBLIC :: IterativeParams PUBLIC :: MethodTypeIterative PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF TYPE :: IterativeMethod PRIVATE TYPE ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE TYPE ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE TYPE ( IterativeMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Iterative ), PASS ( this ), POINTER :: solve_method => NULL () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: solve => IterativeMethod_solve PROCEDURE :: Init_IterativeParams => Init_IterativeParams PROCEDURE :: Dealocate_IterativeParams => Dealocate_IterativeParams PROCEDURE :: test_matrix => test_matrix END TYPE IterativeMethod ABSTRACT INTERFACE FUNCTION solve_interface_Iterative ( this , A , b , x0 , params ) RESULT ( x ) IMPORT :: dp IMPORT :: IterativeParams IMPORT :: IterativeMethod CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x END FUNCTION solve_interface_Iterative END INTERFACE CONTAINS SUBROUTINE set_method ( this , method ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this TYPE ( MethodTypeIterative ), INTENT ( IN ) :: method this % requirements = IterativeMethodRequirements () SELECT CASE ( method % value ) CASE ( METHOD_Jacobi % value ) this % solve_method => solve_Jacobi this % method_type = METHOD_Jacobi this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_GAUSS_SEIDEL % value ) this % solve_method => solve_Gauss_Seidel this % method_type = METHOD_GAUSS_SEIDEL this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_SOR % value ) this % solve_method => solve_SOR this % method_type = METHOD_SOR this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_JOR % value ) this % solve_method => solve_JOR this % method_type = METHOD_JOR this % requirements % needs_square = . TRUE . this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_SIP_ILU % value ) this % solve_method => solve_SIP_ILU this % method_type = METHOD_SIP_ILU this % requirements % needs_square = . TRUE . CASE ( METHOD_SIP_ICF % value ) this % solve_method => solve_SIP_ICF this % method_type = METHOD_SIP_ICF this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_SSOR % value ) this % solve_method => solve_SSOR this % method_type = METHOD_SSOR this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_RICHARDSON % value ) this % solve_method => solve_Richardson this % method_type = METHOD_RICHARDSON this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_CONJUGATE_GRADIENT % value ) this % solve_method => solve_ConjugateGradient this % method_type = METHOD_CONJUGATE_GRADIENT this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_CONJUGATE_RESIDUAL % value ) this % solve_method => solve_ConjugateResidual this % method_type = METHOD_CONJUGATE_RESIDUAL this % requirements % needs_square = . TRUE . this % requirements % needs_symetric = . TRUE . CASE DEFAULT STOP \"ERROR :: Unknown method iterative\" END SELECT END SUBROUTINE set_method FUNCTION Init_IterativeParams ( this , N , A , x0 , max_iter_choice , epsi_tol , omega , & method_preconditioner , alpha , is_stationary , is_strict_mode ) RESULT ( params ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this INTEGER , INTENT ( IN ) :: N REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: x0 INTEGER , OPTIONAL , INTENT ( IN ) :: max_iter_choice REAL ( dp ), OPTIONAL , INTENT ( IN ) :: epsi_tol REAL ( dp ), OPTIONAL , INTENT ( IN ) :: omega REAL ( dp ), OPTIONAL , INTENT ( IN ) :: alpha TYPE ( MethodPreconditioner ), OPTIONAL , INTENT ( IN ) :: method_preconditioner LOGICAL , OPTIONAL , INTENT ( IN ) :: is_stationary LOGICAL , OPTIONAL , INTENT ( IN ) :: is_strict_mode TYPE ( IterativeParams ) :: params INTEGER :: allocate_status ALLOCATE ( params % x_init ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate x_init\" IF ( PRESENT ( x0 )) THEN params % x_init = x0 ELSE params % x_init = 0.0_dp END IF IF ( PRESENT ( max_iter_choice )) params % max_iter = 1000 IF ( PRESENT ( epsi_tol )) params % tol = 1.0e-6_dp IF ( PRESENT ( omega )) params % omega = omega IF ( PRESENT ( alpha )) params % alpha = alpha ALLOCATE ( params % residual ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate residual\" SELECT CASE ( this % method_type % value ) CASE ( METHOD_SIP_ILU % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % U ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate U\" CALL ILU_decomposition ( A , params % L , params % U ) CASE ( METHOD_SIP_ICF % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" CALL Incomplete_Cholesky_decomposition ( A , params % L ) CASE ( METHOD_CONJUGATE_GRADIENT % value ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" CASE ( METHOD_CONJUGATE_RESIDUAL % value ) ALLOCATE ( params % p ( N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate optimal descent direction p\" END SELECT IF ( PRESENT ( method_preconditioner )) THEN params % precond => ApplyPreconditioner SELECT CASE ( method_preconditioner % value ) CASE ( METHOD_PRECOND_JACOBI % value ) ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" params % D = Calculate_Jacobi_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_JACOBI this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_GS % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" params % L = Calculate_Gauss_Seidel_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_GS this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_SOR % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" params % L = Calculate_SOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SOR this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_JOR % value ) ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" params % D = Calculate_JOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_JOR this % requirements % needs_diag_dom = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_ILU % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % U ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate U\" CALL Calculate_ILU_preconditioner ( A , params % L , params % U , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_ILU CASE ( METHOD_PRECOND_ICF % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" params % L = Calculate_ICF_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_ICF this % requirements % needs_SPD = . TRUE . CASE ( METHOD_PRECOND_SSOR % value ) ALLOCATE ( params % L ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate L\" ALLOCATE ( params % D ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate D\" CALL Calculate_SSOR_preconditioner ( A , params % L , params % D , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SSOR this % requirements % needs_SPD = . TRUE . CASE DEFAULT STOP \"ERROR :: Unknown method \" END SELECT END IF IF ( PRESENT ( is_stationary )) THEN IF ( is_stationary ) THEN params % is_stationary = . TRUE . this % requirements % needs_SPD = . FALSE . ELSE params % is_stationary = . FALSE . END IF END IF IF ( PRESENT ( is_strict_mode )) THEN IF ( is_strict_mode ) THEN params % strict_mode = . TRUE . ELSE params % strict_mode = . FALSE . END IF END IF END FUNCTION Init_IterativeParams SUBROUTINE test_matrix ( this , A , params ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A TYPE ( IterativeParams ), INTENT ( IN ) :: params IF ( this % requirements % needs_square ) THEN PRINT * , \"Checking if the matrix is square...\" IF (. NOT . is_square_matrix ( A )) THEN IF ( params % strict_mode ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a square matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a square matrix.\" END IF END IF END IF IF ( this % requirements % needs_SPD ) THEN PRINT * , \"Checking if the matrix is symmetric positive definite (SPD)...\" IF (. NOT . is_SPD ( A )) THEN IF ( params % strict_mode ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" END IF END IF END IF IF ( this % requirements % needs_diag_dom ) THEN PRINT * , \"Checking if the matrix is diagonally dominant...\" IF (. NOT . is_diagonally_dominant ( A )) THEN IF ( params % strict_mode ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a diagonally dominant matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a diagonally dominant matrix.\" END IF END IF END IF IF ( this % requirements % needs_symetric ) THEN PRINT * , \"Checking if the matrix is symmetric...\" IF (. NOT . is_symmetric ( A )) THEN IF ( params % strict_mode ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a symmetric matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric matrix.\" END IF END IF END IF END SUBROUTINE test_matrix SUBROUTINE Dealocate_IterativeParams ( this , params , success ) CLASS ( IterativeMethod ), INTENT ( INOUT ) :: this TYPE ( IterativeParams ), INTENT ( INOUT ) :: params LOGICAL , OPTIONAL , INTENT ( OUT ) :: success INTEGER :: deallocate_status IF ( PRESENT ( success )) success = . TRUE . IF ( ALLOCATED ( params % x_init )) DEALLOCATE ( params % x_init , STAT = deallocate_status ) IF ( ALLOCATED ( params % L )) DEALLOCATE ( params % L , STAT = deallocate_status ) IF ( ALLOCATED ( params % U )) DEALLOCATE ( params % U , STAT = deallocate_status ) IF ( ALLOCATED ( params % D )) DEALLOCATE ( params % D , STAT = deallocate_status ) IF ( ALLOCATED ( params % residual )) DEALLOCATE ( params % residual , STAT = deallocate_status ) IF ( deallocate_status /= 0 . AND . PRESENT ( success )) success = . FALSE . IF ( this % preconditioner_type % value /= METHOD_PRECOND_NONE % value ) this % preconditioner_type % value = METHOD_PRECOND_NONE % value this % requirements = IterativeMethodRequirements () END SUBROUTINE Dealocate_IterativeParams FUNCTION IterativeMethod_solve ( this , A , b , params , verbose ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b TYPE ( IterativeParams ), INTENT ( INOUT ) :: params TYPE ( Logger ), OPTIONAL :: verbose REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x0 , x_new , residu INTEGER :: k , N CHARACTER ( LEN = 64 ) :: msg N = SIZE ( A , 1 ) x0 = params % x_init params % residual = b - MATMUL ( A , x0 ) IF ( this % preconditioner_type % value == METHOD_PRECOND_NONE % value . AND . & ( this % method_type % value == METHOD_CONJUGATE_GRADIENT % value . OR . & this % method_type % value == METHOD_CONJUGATE_RESIDUAL % value )) THEN params % p = params % residual ELSE IF ( this % preconditioner_type % value /= METHOD_PRECOND_NONE % value . AND . & ( this % method_type % value == METHOD_CONJUGATE_GRADIENT % value . OR . & this % method_type % value == METHOD_CONJUGATE_RESIDUAL % value )) THEN params % p = params % precond ( this % preconditioner_type ) END IF DO k = 1 , params % max_iter params % k = k IF ( k == params % max_iter ) THEN PRINT * , \"WARNING :: non-convergence of the iterative method \" // this % method_type % name PRINT * , \"Residual norm: \" , NORM2 ( residu ) EXIT END IF x_new = this % solve_method ( A , b , x0 , params ) residu = b - MATMUL ( A , x_new ) params % residual = residu IF ( PRESENT ( verbose )) THEN IF ( verbose % show_iteration ) THEN verbose % step = k WRITE ( msg , '(A,I5,A,ES14.7)' ) \"Iter \" , k , \" | Norm residu: \" , NORM2 ( residu ) CALL verbose % log ( msg ) END IF END IF IF ( NORM2 ( residu ) < params % tol ) EXIT x0 = x_new END DO IF ( PRESENT ( verbose )) THEN IF ( verbose % show_final ) THEN verbose % step = k WRITE ( msg , '(A,I5,A,ES14.7)' ) \"Iter \" , k , \" | Norm residu: \" , NORM2 ( residu ) CALL verbose % log ( msg ) END IF END IF x = x_new END FUNCTION IterativeMethod_solve !> Jacobi iterative method !> !> This subroutine implements the Jacobi method for solving linear systems. FUNCTION solve_Jacobi ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: i , N N = SIZE ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END FUNCTION solve_Jacobi !> Gauss-Seidel iterative method !> !> This subroutine implements the Gauss-Seidel method for solving linear systems. FUNCTION solve_Gauss_Seidel ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: i , N N = SIZE ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END FUNCTION solve_Gauss_Seidel !> Successive Over-Relaxation (SOR) iterative method !> !> This subroutine implements the SOR method for solving linear systems. FUNCTION solve_SOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: i , N N = SIZE ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO END FUNCTION solve_SOR !> Jacobi over-relaxation (JOR) iterative method !> !> This subroutine implements the Jacobi over-relaxation method for solving linear systems. FUNCTION solve_JOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: i , N N = SIZE ( A , 1 ) ! forward DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO END FUNCTION solve_JOR !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete LU decomposition of the matrix A. FUNCTION solve_SIP_ILU ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , z IF (. NOT . ALLOCATED ( params % L ) . OR . . NOT . ALLOCATED ( params % U )) STOP \"ERROR :: Incomplete LU decomposition not initialized\" y = forward ( params % L , params % residual ) z = backward ( params % U , y ) x = x0 + params % omega * z END FUNCTION solve_SIP_ILU !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete Cholesky decomposition of the matrix A. FUNCTION solve_SIP_ICF ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , z IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: Incomplete LU decomposition not initialized\" y = forward ( params % L , params % residual ) z = backward ( TRANSPOSE ( params % L ), y ) x = x0 + params % omega * z END FUNCTION solve_SIP_ICF !> Symmetric successive Over-Relaxation (SSOR) iterative method !> !> This subroutine implements the SSOR method for solving linear systems. FUNCTION solve_SSOR ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x_tmp INTEGER :: i , N N = SIZE ( A , 1 ) ! forward DO i = 1 , N x_tmp ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x_tmp ( i ) = params % omega * ( x_tmp ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) END DO ! backward DO i = N , 1 , - 1 x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x_tmp ( i )) + x_tmp ( i ) END DO END FUNCTION solve_SSOR FUNCTION solve_Richardson ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: z IF ( this % preconditioner_type % value == METHOD_PRECOND_NONE % value ) THEN IF (. NOT . params % is_stationary ) THEN params % alpha = DOT_PRODUCT ( params % residual , params % residual ) / & DOT_PRODUCT ( params % residual , MATMUL ( A , params % residual )) END IF x = x0 + params % alpha * params % residual ELSE IF ( this % preconditioner_type % value /= METHOD_PRECOND_NONE % value ) THEN z = params % precond ( this % preconditioner_type ) IF (. NOT . params % is_stationary ) THEN params % alpha = DOT_PRODUCT ( params % residual , z ) / & DOT_PRODUCT ( z , MATMUL ( A , z )) END IF x = x0 + params % alpha * z END IF END FUNCTION solve_Richardson FUNCTION solve_ConjugateGradient ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: z IF ( this % preconditioner_type % value == METHOD_PRECOND_NONE % value ) THEN IF ( params % k /= 1 ) THEN params % beta = DOT_PRODUCT ( params % residual , params % residual ) / params % old_dot_product params % p = params % residual + params % beta * params % p END IF params % alpha = DOT_PRODUCT ( params % residual , params % residual ) / DOT_PRODUCT ( params % p , MATMUL ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = DOT_PRODUCT ( params % residual , params % residual ) ELSE IF ( this % preconditioner_type % value /= METHOD_PRECOND_NONE % value ) THEN IF ( this % preconditioner_type % value == METHOD_PRECOND_GS % value . AND . & this % preconditioner_type % value == METHOD_PRECOND_SOR % value ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN z = params % p ELSE IF ( params % k /= 1 ) THEN z = params % precond ( this % preconditioner_type ) params % beta = DOT_PRODUCT ( params % residual , z ) / params % old_dot_product params % p = z + params % beta * params % p END IF params % alpha = DOT_PRODUCT ( params % residual , z ) / DOT_PRODUCT ( params % p , MATMUL ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = DOT_PRODUCT ( params % residual , z ) END IF END FUNCTION solve_ConjugateGradient FUNCTION solve_ConjugateResidual ( this , A , b , x0 , params ) RESULT ( x ) CLASS ( IterativeMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 TYPE ( IterativeParams ), INTENT ( INOUT ) :: params REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: z IF ( this % preconditioner_type % value == METHOD_PRECOND_NONE % value ) THEN IF ( params % k /= 1 ) THEN params % beta = DOT_PRODUCT ( params % residual , MATMUL ( A , params % residual )) / params % old_dot_product params % p = params % residual + params % beta * params % p END IF params % alpha = DOT_PRODUCT ( params % residual , MATMUL ( A , params % residual )) / & DOT_PRODUCT ( MATMUL ( A , params % p ), MATMUL ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = DOT_PRODUCT ( params % residual , MATMUL ( A , params % residual )) ELSE IF ( this % preconditioner_type % value /= METHOD_PRECOND_NONE % value ) THEN IF ( this % preconditioner_type % value == METHOD_PRECOND_GS % value . AND . & this % preconditioner_type % value == METHOD_PRECOND_SOR % value ) THEN STOP \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" END IF IF ( params % k == 1 ) THEN z = params % p ELSE IF ( params % k /= 1 ) THEN z = params % precond ( this % preconditioner_type ) params % beta = DOT_PRODUCT ( z , MATMUL ( A , params % residual )) / params % old_dot_product params % p = z + params % beta * params % p END IF params % alpha = DOT_PRODUCT ( z , MATMUL ( A , params % residual )) / & DOT_PRODUCT ( MATMUL ( A , params % p ), MATMUL ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = DOT_PRODUCT ( z , MATMUL ( A , params % residual )) END IF END FUNCTION solve_ConjugateResidual END MODULE NAFPack_Iterative_methods","tags":"","url":"sourcefile\\nafpack_iterative_methods.f90.html"},{"title":"NAFPack_Eigen.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_eigen.f90~~EfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_eigen.f90~~AfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for eigenvalue and eigenvector computations in NAFPack MODULE NAFPack_Eigen USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: Eigen CONTAINS !================== Eigen =============================================================== !> Computes the eigenvalues and eigenvectors of a matrix A !>  A * \\vec{v} = \\lambda * \\vec{v}  !> with **A** a square matrix, **λ** the eigenvalue, and **v** the eigenvector. !> This subroutine allows you to choose the method for computing eigenvalues and eigenvectors: !> !> - Power iteration !> - QR algorithm (with or without shift) !> The default method is Power iteration. SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( PRESENT ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( PRESENT ( vp ) . AND . ( SIZE ( vp , 1 ) /= N . OR . SIZE ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( PRESENT ( vp )) vp = vp_tmp ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN IF ( PRESENT ( vp )) vp = 0 IF ( PRESENT ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = INDEX ( TRIM ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == LEN_TRIM ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen !> QR algorithm for computing eigenvalues !> !> This subroutine implements the QR algorithm for computing the eigenvalues of a matrix. SUBROUTINE Eigen_QR ( A , lambda , method , N , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), INTENT ( IN ) :: method INTEGER , INTENT ( IN ) :: N , k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: lambda_old REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R REAL ( dp ) :: diff INTEGER :: i , j A_tmp = A DO i = 1 , k lambda_old = lambda CALL QR_decomposition ( A_tmp , method , Q , R ) A_tmp = MATMUL ( R , Q ) diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR !> Shifted QR algorithm for computing eigenvalues !> !> This subroutine implements the shifted QR algorithm for computing the eigenvalues of a matrix. !> The shift is chosen as the last diagonal element of the matrix. SUBROUTINE Eigen_QR_Shifted ( A , lambda , method , N , k ) INTEGER , INTENT ( IN ) :: N , k CHARACTER ( LEN = * ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( N ), INTENT ( OUT ) :: lambda INTEGER :: i , j REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R , Id REAL ( dp ) :: shift , diff A_tmp = A Id = Identity_n ( N ) DO i = 1 , k !choice of shift: last diagonal element shift = A_tmp ( N , N ) ! Gap : A - µI A_tmp = A_tmp - shift * Id ! QR Decomposition : A - µI = Q * R CALL QR_decomposition ( A_tmp , method , Q , R ) ! A = RQ + µI A_tmp = MATMUL ( R , Q ) + shift * Id diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR_Shifted !> Power iteration method for computing the dominant eigenvalue and eigenvector !> !> This subroutine implements the power iteration method for finding the dominant eigenvalue and eigenvector of a matrix. !> It iteratively computes the eigenvector and eigenvalue until convergence SUBROUTINE Power_iteration ( A , lambda , vp , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: vp REAL ( dp ), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u , vp_tmp , r INTEGER :: i , N N = SIZE ( A , 1 ) CALL RANDOM_NUMBER ( u ) u = normalise ( u ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) r = vp_tmp - lambda * u DO i = 1 , k u = normalise ( vp_tmp ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) IF ( NORM2 ( r ) <= epsi ) EXIT r = vp_tmp - lambda * u IF ( i == k ) THEN PRINT * , \"WARNING :: non-convergence of the power iteration method\" END IF END DO vp = u END SUBROUTINE Power_iteration !> Deflation method for removing the influence of an eigenvalue and eigenvector !> !> This function performs deflation on a matrix A by removing the influence of an eigenvalue and its corresponding eigenvector. FUNCTION deflation ( A , lambda , vp , k ) RESULT ( result ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: vp REAL ( dp ), INTENT ( IN ) :: lambda INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: result REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: wp INTEGER :: i , j , N REAL ( dp ) :: lambda1 N = SIZE ( A , 1 ) result = A CALL Power_iteration ( transpose ( A ), lambda1 , wp , k ) DO i = 1 , N DO j = 1 , N result ( i , j ) = result ( i , j ) - ( lambda * vp ( i ) * wp ( j )) / DOT_PRODUCT ( vp , wp ) END DO END DO END FUNCTION deflation END MODULE NAFPack_Eigen","tags":"","url":"sourcefile\\nafpack_eigen.f90.html"},{"title":"NAFPack_config.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_config.f90~~EfferentGraph sourcefile~nafpack_config.f90 NAFPack_config.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_config.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for advanced configuration and tuning parameters MODULE NAFPack_config USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: config_type , get_default_config , validate_config !> Configuration type for NAFPack TYPE :: config_type ! Numerical tolerances REAL ( dp ) :: pivot_tolerance = 1.0e-14_dp REAL ( dp ) :: convergence_tolerance = 1.0e-12_dp REAL ( dp ) :: residual_tolerance = 1.0e-10_dp ! Performance settings INTEGER :: max_iterations = 10000 INTEGER :: block_size = 64 LOGICAL :: use_openmp = . TRUE . LOGICAL :: use_blas = . TRUE . ! Memory management LOGICAL :: preallocate_workspace = . TRUE . INTEGER :: workspace_size = 1000 ! Debugging and logging LOGICAL :: enable_debug = . FALSE . LOGICAL :: enable_timing = . FALSE . CHARACTER ( LEN = 100 ) :: log_file = \"nafpack.log\" ! Method selection CHARACTER ( LEN = 50 ) :: default_direct_method = \"A_LU\" CHARACTER ( LEN = 50 ) :: default_iterative_method = \"Gauss_Seidel\" CHARACTER ( LEN = 50 ) :: default_preconditioner = \"ILU\" END TYPE config_type CONTAINS !> Get default configuration FUNCTION get_default_config () RESULT ( config ) TYPE ( config_type ) :: config ! Default values are already set in the type definition ! No need to explicitly set them as they're defined in the type config = config_type ( pivot_tolerance = TOL_PIVOT , & convergence_tolerance = TOL_CONVERGENCE , & residual_tolerance = epsi , & max_iterations = kmax , & block_size = 64 , & use_openmp = . TRUE ., & use_blas = . TRUE ., & preallocate_workspace = . TRUE ., & workspace_size = 1000 , & enable_debug = . FALSE ., & enable_timing = . FALSE ., & log_file = \"nafpack.log\" , & default_direct_method = \"A_LU\" , & default_iterative_method = \"Gauss_Seidel\" , & default_preconditioner = \"ILU\" ) END FUNCTION get_default_config !> Validate configuration parameters SUBROUTINE validate_config ( config , is_valid , error_msg ) TYPE ( config_type ), INTENT ( IN ) :: config LOGICAL , INTENT ( OUT ) :: is_valid CHARACTER ( LEN =* ), INTENT ( OUT ) :: error_msg is_valid = . TRUE . error_msg = \"\" ! Check tolerances IF ( config % pivot_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Pivot tolerance must be positive\" RETURN END IF IF ( config % convergence_tolerance <= 0.0_dp ) THEN is_valid = . FALSE . error_msg = \"Convergence tolerance must be positive\" RETURN END IF ! Check iteration limits IF ( config % max_iterations <= 0 ) THEN is_valid = . FALSE . error_msg = \"Maximum iterations must be positive\" RETURN END IF ! Check block size IF ( config % block_size <= 0 ) THEN is_valid = . FALSE . error_msg = \"Block size must be positive\" RETURN END IF END SUBROUTINE validate_config END MODULE NAFPack_config","tags":"","url":"sourcefile\\nafpack_config.f90.html"},{"title":"NAFPack_Preconditioners.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_preconditioners.f90~~EfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_preconditioners.f90~~AfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Preconditioners USE NAFPack_constant USE NAFPack_Iterative_types USE NAFPack_matricielle USE NAFPack_matrix_decomposition IMPLICIT NONE PRIVATE PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF PUBLIC :: Calculate_Jacobi_preconditioner PUBLIC :: Calculate_Gauss_Seidel_preconditioner PUBLIC :: Calculate_SOR_preconditioner PUBLIC :: Calculate_JOR_preconditioner PUBLIC :: Calculate_ILU_preconditioner PUBLIC :: Calculate_ICF_preconditioner PUBLIC :: Calculate_SSOR_preconditioner TYPE :: MethodPreconditioner INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodPreconditioner TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_NONE = MethodPreconditioner ( 0 , \"None\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_JACOBI = MethodPreconditioner ( 1 , \"Jacobi\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_GS = MethodPreconditioner ( 2 , \"Gauss-Seidel\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_SOR = MethodPreconditioner ( 3 , \"Successive Over-Relaxation\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_JOR = MethodPreconditioner ( 4 , \"Jacobi Over-Relaxation\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_ILU = MethodPreconditioner ( 5 , \"ILU\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_ICF = MethodPreconditioner ( 6 , \"ICF\" ) TYPE ( MethodPreconditioner ), PARAMETER :: METHOD_PRECOND_SSOR = MethodPreconditioner ( 7 , \"SSOR\" ) CONTAINS FUNCTION Calculate_Jacobi_preconditioner ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: D INTEGER :: N , i N = SIZE ( A , 1 ) D = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Jacobi preconditioner\" FORALL ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) END FUNCTION Calculate_Jacobi_preconditioner FUNCTION Calculate_Gauss_Seidel_preconditioner ( A ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N , i , j N = SIZE ( A , 1 ) L = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" FORALL ( i = 1 : SIZE ( A , 1 ), j = 1 : SIZE ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) END FUNCTION Calculate_Gauss_Seidel_preconditioner FUNCTION Calculate_SOR_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N , i N = SIZE ( A , 1 ) L = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in SOR preconditioner\" DO i = 1 , SIZE ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) END DO L = alpha * L END FUNCTION Calculate_SOR_preconditioner FUNCTION Calculate_JOR_preconditioner ( A , omega , alpha ) RESULT ( D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: D INTEGER :: N , i N = SIZE ( A , 1 ) D = 0.d0 IF ( ANY ( Diag ( A ) < epsi )) STOP \"ERROR :: Zero diagonal in JOR preconditioner\" FORALL ( i = 1 : SIZE ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha END FUNCTION Calculate_JOR_preconditioner SUBROUTINE Calculate_ILU_preconditioner ( A , L , U , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )), INTENT ( OUT ) :: L , U INTEGER :: N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 CALL ILU_decomposition ( A , L , U ) L = alpha / omega * L END SUBROUTINE Calculate_ILU_preconditioner FUNCTION Calculate_ICF_preconditioner ( A , omega , alpha ) RESULT ( L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: L INTEGER :: N N = SIZE ( A , 1 ) L = 0.d0 CALL Incomplete_Cholesky_decomposition ( A , L ) L = alpha / omega * L END FUNCTION Calculate_ICF_preconditioner SUBROUTINE Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), INTENT ( IN ) :: omega , alpha REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )), INTENT ( OUT ) :: L , D INTEGER :: N , i N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 DO i = 1 , SIZE ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) END DO L = ( alpha * omega ) / ( 2 - omega ) * L END SUBROUTINE Calculate_SSOR_preconditioner END MODULE NAFPack_Preconditioners","tags":"","url":"sourcefile\\nafpack_preconditioners.f90.html"},{"title":"NAFPack_matrix_properties.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_properties.f90~~EfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_properties.f90~~AfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_matrix_properties USE NAFPack_constant USE NAFPack_matricielle USE NAFPack_Eigen IMPLICIT NONE PRIVATE PUBLIC :: is_square_matrix , is_symmetric , is_orthogonal , is_SPD , is_tridiagonal , & is_diagonally_dominant , is_non_zero_diagonal CONTAINS FUNCTION is_square_matrix ( A ) RESULT ( is_square ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_square is_square = ( SIZE ( A , 1 ) == SIZE ( A , 2 )) END FUNCTION is_square_matrix FUNCTION is_symmetric ( A ) RESULT ( is_sym ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_sym is_sym = ALL ( A == TRANSPOSE ( A )) END FUNCTION is_symmetric FUNCTION is_orthogonal ( A ) RESULT ( is_orth ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_orth is_orth = ALL ( ABS ( MATMUL ( A , TRANSPOSE ( A )) - Identity_n ( SIZE ( A , 1 ))) < epsi_test ) END FUNCTION is_orthogonal FUNCTION is_SPD ( A , is_sym ) RESULT ( is_spd_matrix ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: is_sym REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: lambda LOGICAL :: is_spd_matrix IF ( PRESENT ( is_sym )) THEN IF (. NOT . is_sym ) THEN is_spd_matrix = . FALSE . RETURN END IF ELSE IF (. NOT . is_symmetric ( A )) THEN is_spd_matrix = . FALSE . RETURN END IF CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( MINVAL ( lambda ) < 0 ) THEN is_spd_matrix = . FALSE . ELSE is_spd_matrix = . TRUE . END IF END FUNCTION is_SPD FUNCTION is_tridiagonal ( A ) RESULT ( is_tridiag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_tridiag INTEGER :: i , j , N N = SIZE ( A , 1 ) is_tridiag = . TRUE . DO i = 1 , N DO j = 1 , N IF ( ABS ( i - j ) > 1 ) THEN IF ( ABS ( A ( i , j )) > epsi ) THEN is_tridiag = . FALSE . RETURN END IF END IF END DO END DO END FUNCTION is_tridiagonal FUNCTION is_diagonally_dominant ( A ) RESULT ( is_diag_dom ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_diag_dom INTEGER :: i , N REAL ( dp ) :: row_sum N = SIZE ( A , 1 ) is_diag_dom = . TRUE . DO i = 1 , N row_sum = SUM ( ABS ( A ( i , :))) - ABS ( A ( i , i )) IF ( ABS ( A ( i , i )) < row_sum ) THEN is_diag_dom = . FALSE . RETURN END IF END DO END FUNCTION is_diagonally_dominant FUNCTION is_non_zero_diagonal ( A ) RESULT ( is_non_zero_diag ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: is_non_zero_diag is_non_zero_diag = . TRUE . IF ( ANY ( ABS ( Diag ( A )) < epsi )) is_non_zero_diag = . FALSE . END FUNCTION is_non_zero_diagonal END MODULE NAFPack_matrix_properties","tags":"","url":"sourcefile\\nafpack_matrix_properties.f90.html"},{"title":"NAFPack_linalg.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_linalg.f90~~EfferentGraph sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_linalg USE NAFPack_Direct_types USE NAFPack_Direct_method USE NAFPack_Iterative_types USE NAFPack_Iterative_methods IMPLICIT NONE PRIVATE PUBLIC :: linalg , DirectMethod , IterativeMethod PUBLIC :: MethodTypeDirect , MethodQR PUBLIC :: METHOD_DIRECT_NONE PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR PUBLIC :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT PUBLIC :: QR_GRAM_SCHMIDT_Modified PUBLIC :: IterativeParams PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: MethodPreconditioner PUBLIC :: METHOD_PRECOND_NONE PUBLIC :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR PUBLIC :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR PUBLIC :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF TYPE :: linalg TYPE ( DirectMethod ) :: direct TYPE ( IterativeMethod ) :: iterative END TYPE linalg CONTAINS END MODULE NAFPack_linalg","tags":"","url":"sourcefile\\nafpack_linalg.f90.html"},{"title":"NAFPack_meshgrid.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid.f90~~EfferentGraph sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for creating a meshgrid from two vectors !> !> This module provides a subroutine to create a meshgrid. MODULE NAFPack_meshgrid USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: meshgrid CONTAINS !> Make N-dimensional meshgrid from two vectors **x_vector** and **y_vector** SUBROUTINE meshgrid ( x_vector , y_vector , X , Y ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: x_vector , y_vector REAL ( dp ), DIMENSION ( SIZE ( y_vector ), SIZE ( x_vector )), INTENT ( OUT ) :: X , Y INTEGER :: sX , sY , i sX = size ( x_vector ) sY = size ( y_vector ) DO i = 1 , sY X ( i , :) = x_vector END DO DO i = 1 , sX Y (:, i ) = y_vector END DO END SUBROUTINE meshgrid END MODULE NAFPack_meshgrid","tags":"","url":"sourcefile\\nafpack_meshgrid.f90.html"},{"title":"NAFPack_Direct_types.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_direct_types.f90~~AfferentGraph sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Direct_types IMPLICIT NONE PRIVATE PUBLIC :: MethodTypeDirect , MethodQR PUBLIC :: METHOD_DIRECT_NONE PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR PUBLIC :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT PUBLIC :: QR_GRAM_SCHMIDT_Modified PUBLIC :: DirectMethodRequirements TYPE :: MethodTypeDirect INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeDirect TYPE :: MethodQR INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodQR TYPE :: DirectMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_non_zero_diag = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_tridiagonal = . FALSE . LOGICAL :: needs_symmetric = . FALSE . END TYPE DirectMethodRequirements TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_DIRECT_NONE = MethodTypeDirect ( 0 , \"None\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_Gauss = MethodTypeDirect ( 1 , \"Gauss\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_Gauss_JORDAN = MethodTypeDirect ( 2 , \"Gauss-Jordan\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LU = MethodTypeDirect ( 3 , \"LU\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LDU = MethodTypeDirect ( 4 , \"LDU\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_CHOLESKY = MethodTypeDirect ( 5 , \"Cholesky\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_LDL_Cholesky = MethodTypeDirect ( 6 , \"LDL-Cholesky\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_QR = MethodTypeDirect ( 7 , \"QR\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_TDMA = MethodTypeDirect ( 8 , \"TDMA\" ) TYPE ( MethodTypeDirect ), PARAMETER :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect ( 9 , \"Faddeev-Leverrier\" ) TYPE ( MethodQR ), PARAMETER :: QR_HOUSEHOLDER = MethodQR ( 1 , \"Householder\" ) TYPE ( MethodQR ), PARAMETER :: QR_GIVENS = MethodQR ( 2 , \"Givens\" ) TYPE ( MethodQR ), PARAMETER :: QR_GRAM_SCHMIDT = MethodQR ( 3 , \"Gram-Schmidt\" ) TYPE ( MethodQR ), PARAMETER :: QR_GRAM_SCHMIDT_Modified = MethodQR ( 4 , \"Gram_Schmidt_Modified\" ) END MODULE NAFPack_Direct_types","tags":"","url":"sourcefile\\nafpack_direct_types.f90.html"},{"title":"NAFPack_Iterative_Params.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_params.f90~~EfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_params.f90~~AfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Iterative_Params USE NAFPack_constant USE NAFPack_Iterative_types USE NAFPack_Preconditioners USE NAFPack_matrix_decomposition IMPLICIT NONE PRIVATE PUBLIC :: IterativeParams PUBLIC :: ApplyPreconditioner TYPE :: IterativeParams REAL ( dp ), DIMENSION (:), ALLOCATABLE :: x_init REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: L , U , D REAL ( dp ), DIMENSION (:), ALLOCATABLE :: residual REAL ( dp ), DIMENSION (:), ALLOCATABLE :: p REAL ( dp ) :: omega = 1.d0 INTEGER :: k = 0 INTEGER :: max_iter = 1000 REAL ( dp ) :: tol = 1.0d-12 REAL ( dp ) :: alpha = 1.d0 REAL ( dp ) :: beta = 1.d0 LOGICAL :: is_stationary = . TRUE . REAL ( dp ) :: old_dot_product = 0.d0 LOGICAL :: strict_mode = . FALSE . PROCEDURE ( ApplyPreconditioner ), PASS ( params ), POINTER :: precond END TYPE IterativeParams CONTAINS FUNCTION ApplyPreconditioner ( params , method ) RESULT ( y ) CLASS ( IterativeParams ), INTENT ( IN ) :: params CLASS ( MethodPreconditioner ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( params % x_init )) :: y SELECT CASE ( method % value ) CASE ( METHOD_PRECOND_JACOBI % value ) IF (. NOT . ALLOCATED ( params % D )) STOP \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = MATMUL ( params % D , params % residual ) CASE ( METHOD_PRECOND_GS % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) CASE ( METHOD_PRECOND_SOR % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) CASE ( METHOD_PRECOND_JOR % value ) IF (. NOT . ALLOCATED ( params % D )) STOP \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = MATMUL ( params % D , params % residual ) CASE ( METHOD_PRECOND_ILU % value ) IF (. NOT . ALLOCATED ( params % L ) . OR . & . NOT . ALLOCATED ( params % U )) STOP \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , params % residual ) y = backward ( params % U , y ) CASE ( METHOD_PRECOND_ICF % value ) IF (. NOT . ALLOCATED ( params % L )) STOP \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , params % residual ) y = backward ( TRANSPOSE ( params % L ), y ) CASE ( METHOD_PRECOND_SSOR % value ) IF (. NOT . ALLOCATED ( params % L ) . OR . & . NOT . ALLOCATED ( params % D )) STOP \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , params % residual ) y = MATMUL ( params % D , y ) y = backward ( TRANSPOSE ( params % L ), y ) CASE DEFAULT STOP \"ERROR :: Unknown preconditioner method\" END SELECT END FUNCTION ApplyPreconditioner END MODULE NAFPack_Iterative_Params","tags":"","url":"sourcefile\\nafpack_iterative_params.f90.html"},{"title":"NAFPack_matricielle.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matricielle.f90~~EfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matricielle.f90~~AfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Tensor operations in NAFPack MODULE NAFPack_matricielle USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: dot , cross PUBLIC :: norm_2 , norm_2_complex PUBLIC :: normalise , normalise_complexe PUBLIC :: Diagonally_Dominant_Matrix PUBLIC :: Identity_n PUBLIC :: rotation_matrix PUBLIC :: Trace PUBLIC :: Diag CONTAINS !> function that calculates the dot product of two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\cdot \\vec{b}  FUNCTION dot ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( dp ) :: result INTEGER :: i IF ( SIZE ( a ) /= SIZE ( b )) STOP \"Error: Vectors must be of the same size.\" result = 0.0_dp DO i = 1 , SIZE ( a ) result = result + a ( i ) * b ( i ) END DO END FUNCTION dot !> function that calculates the cross product between two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\times \\vec{b} [&#94;1] !> [&#94;1]: the wedge notation  \\vec{a} \\wedge \\vec{b}  can sometimes be used to denote the vector product. FUNCTION cross ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross !> function that calculates the Euclidean norm (L2 norm) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} a_i&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} a_i&#94;2 = \\vec{a} \\cdot \\vec{a}  !> where  n  is the dimension of the real vector  \\vec{a} . FUNCTION norm_2 ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( DOT_PRODUCT ( a , a )) END FUNCTION norm_2 !> Optimized norm calculation avoiding overflow/underflow PURE FUNCTION norm_2_safe ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: a REAL ( dp ) :: result REAL ( dp ) :: scale , sum_of_squares scale = MAXVAL ( ABS ( a )) IF ( scale == 0.0_dp ) THEN result = 0.0_dp ELSE sum_of_squares = SUM (( a / scale ) ** 2 ) result = scale * SQRT ( sum_of_squares ) END IF END FUNCTION norm_2_safe !> function that calculates the Euclidean norm (L2 norm or modulus) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} |a_i|&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} |a_i|&#94;2 = \\vec{a} \\cdot \\overline{\\vec{a}}  !> where  n  is the dimension of the complex vector  \\vec{a} . FUNCTION norm_2_complex ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( REAL ( DOT_PRODUCT ( a , CONJG ( a )))) END FUNCTION norm_2_complex !> function that normalises a real vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2 ( a ) END FUNCTION normalise !> function that normalises a complex vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  FUNCTION normalise_complexe ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2_complex ( a ) END FUNCTION normalise_complexe !> function that calculates the trace of a square matrix  A  !>  \\text{Tr}(A) = \\sum_{i=1}&#94;{n} A(i,i)  FUNCTION Trace ( A ) RESULT ( result ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ) :: result INTEGER :: i , N N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"Error: Matrix must be square.\" result = SUM ([( A ( i , i ), i = 1 , N )]) END FUNCTION Trace !> function which checks if **A** is diagonally dominant !>  \\forall i, |A(i,i)| \\geq \\sum_{j \\neq i} |A(i,j)|  FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = SIZE ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = SUM ( ABS ( A ( i , :) - A ( i , i ))) if ( ABS ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix !> function that returns the identity matrix for a given size N !>  I_N = \\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{pmatrix}  FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( PRESENT ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n !> function that extracts the diagonal of a matrix !>  D = \\begin{pmatrix} A(1,1) & 0 & \\cdots & 0 \\\\ 0 & A(2,2) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & A(n,n) \\end{pmatrix}  !> where  D  is a vector containing the diagonal elements of the matrix  A . FUNCTION Diag ( A ) RESULT ( D ) REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: D INTEGER :: i , N N = SIZE ( A , 1 ) FORALL ( i = 1 : N ) D ( i ) = A ( i , i ) END FUNCTION Diag !> Function to create a rotation matrix !> !> This function generates a rotation matrix **G** based on the input matrix **A** and the specified rotation indices. FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( SIZE ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = SQRT ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix END MODULE NAFPack_matricielle","tags":"","url":"sourcefile\\nafpack_matricielle.f90.html"},{"title":"NAFPack_matrix_decomposition.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_decomposition.f90~~EfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_decomposition.f90~~AfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for matrix decomposition methods !> !> This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. MODULE NAFPack_matrix_decomposition USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: forward , backward PUBLIC :: LU_decomposition , LDU_decomposition , ILU_decomposition PUBLIC :: Cholesky_decomposition , LDL_Cholesky_decomposition , Incomplete_Cholesky_decomposition PUBLIC :: QR_decomposition PUBLIC :: QR_Householder_decomposition , QR_Givens_decomposition , & QR_Gram_Schmidt_Classical_decomposition , QR_Gram_Schmidt_Modified_decomposition CONTAINS !> forward algorithm, !> solves the system !>  L * y = b  !> where **L** is a lower triangular matrix and **b** is a vector FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( L , 1 )) :: y INTEGER :: i , N N = SIZE ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward !> backward algorithm, !> solves the system !>  U * x = y  !> where **U** is an upper triangular matrix and **y** is a vector FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( SIZE ( U , 1 )) :: x INTEGER :: i , N N = SIZE ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - DOT_PRODUCT ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward !> LU decomposition of a matrix A !>  A = LU  !> This subroutine performs LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition !> LDU decomposition of a matrix A !>  A = LDU  !> This subroutine performs LDU decomposition of a given matrix **A**, where **L** is a lower triangular matrix, **D** is a diagonal matrix, and **U** is an upper triangular matrix. SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [ ( D ( k , k ), k = 1 , i - 1 ) ])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition !> Incomplete LU decomposition of a matrix A !>  A \\approx LU  !> This subroutine performs incomplete LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE ILU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U LOGICAL , DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: S INTEGER :: i , j , N N = SIZE ( A , 1 ) L = Identity_n ( N ) U = 0.d0 S = A /= 0 DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO DO j = i , N IF ( S ( i , j )) U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO END DO END SUBROUTINE ILU_decomposition !> Cholesky decomposition of a matrix A !>  A = LL&#94;T  !> This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix. SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = SIZE ( A , 1 ) DO j = 1 , N L ( j , j ) = SQRT ( A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition !> Alternative Cholesky decomposition of a matrix A !>  A = LDL&#94;T  !> This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix and **D** is a diagonal matrix. SUBROUTINE LDL_Cholesky_decomposition ( A , L , D ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , D INTEGER :: i , j , N , k N = SIZE ( A , 1 ) L = Identity_n ( N ) D = 0.d0 DO j = 1 , N D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDL_Cholesky_decomposition !> Incomplete Cholesky decomposition of a matrix A !>  A \\approx LL&#94;T  !> This subroutine performs incomplete Cholesky decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. SUBROUTINE Incomplete_Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L LOGICAL , DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: S INTEGER :: i , j , N N = SIZE ( A , 1 ) L = Identity_n ( N ) S = A /= 0 DO i = 1 , N DO j = 1 , i - 1 IF ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO IF ( S ( i , i )) L ( i , i ) = SQRT ( A ( i , i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) END DO END SUBROUTINE Incomplete_Cholesky_decomposition !> QR decomposition of a matrix **A** using various methods !>  A = QR  !> This subroutine performs QR decomposition of a given matrix **A** using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt). !> The output matrices **Q** is an orthogonal matrix and **R** is an upper triangular matrix. SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) END IF END SUBROUTINE QR_decomposition !> QR decomposition using Householder method SUBROUTINE QR_Householder_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = SIZE ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = NORM2 ( R ( k : N , k )) signe = - SIGN ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = NORM2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = MATMUL ( Q , H ) R ( k : N , k : N ) = MATMUL ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder_decomposition !> QR decomposition using Givens rotations SUBROUTINE QR_Givens_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: G INTEGER :: N , i , j N = SIZE ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = MATMUL ( G , R ) Q = MATMUL ( Q , TRANSPOSE ( G )) END DO END DO END SUBROUTINE QR_Givens_decomposition !> QR decomposition using Classical Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) Q = 0.d0 R = 0.d0 DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = DOT_PRODUCT ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = NORM2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical_decomposition !> QR decomposition using Modified Gram-Schmidt method SUBROUTINE QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = NORM2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = DOT_PRODUCT ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified_decomposition END MODULE NAFPack_matrix_decomposition","tags":"","url":"sourcefile\\nafpack_matrix_decomposition.f90.html"},{"title":"NAFPack_Logger_mod.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_logger_mod.f90~~EfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_logger_mod.f90~~AfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> MODULE NAFPack_Logger_mod USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: Logger TYPE :: Logger LOGICAL :: to_terminal = . TRUE . LOGICAL :: to_file = . FALSE . INTEGER :: frequency = 10 CHARACTER ( LEN = 100 ) :: filename = \"log.txt\" INTEGER :: file_unit = 99 INTEGER :: step = 0 LOGICAL :: show_iteration = . TRUE . LOGICAL :: show_final = . TRUE . CONTAINS PROCEDURE :: log => log_message PROCEDURE :: init => init_logger PROCEDURE :: close => close_logger END TYPE Logger CONTAINS SUBROUTINE init_logger ( this ) CLASS ( Logger ), INTENT ( INOUT ) :: this IF ( this % to_file ) THEN OPEN ( UNIT = this % file_unit , FILE = TRIM ( this % filename ), STATUS = 'REPLACE' , ACTION = 'WRITE' ) END IF END SUBROUTINE init_logger SUBROUTINE log_message ( this , msg ) CLASS ( Logger ), INTENT ( INOUT ) :: this CHARACTER ( LEN =* ), INTENT ( IN ) :: msg IF ( MOD ( this % step , this % frequency ) /= 0 . AND . this % show_iteration ) RETURN IF ( this % to_terminal ) PRINT * , msg IF ( this % to_file ) WRITE ( this % file_unit , '(A)' ) TRIM ( msg ) END SUBROUTINE log_message SUBROUTINE close_logger ( this ) CLASS ( Logger ), INTENT ( INOUT ) :: this IF ( this % to_file ) CLOSE ( this % file_unit ) END SUBROUTINE close_logger END MODULE NAFPack_Logger_mod","tags":"","url":"sourcefile\\nafpack_logger_mod.f90.html"},{"title":"NAFPack_matrix_tools.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_tools.f90~~EfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_tools.f90~~AfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_matrix_tools USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE CONTAINS SUBROUTINE Faddeev_Leverrier ( A , c , Ainv , success , check ) INTEGER , PARAMETER :: dp = KIND ( 1.0d0 ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: c REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), OPTIONAL , INTENT ( OUT ) :: Ainv LOGICAL , OPTIONAL , INTENT ( OUT ) :: success REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: Bk , I , B_Nm1 , AB LOGICAL :: do_check = . TRUE . INTEGER :: N , k N = SIZE ( A , 1 ) IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is square and size of c is correct\" IF ( SIZE ( A , 2 ) /= N . OR . SIZE ( c ) < N + 1 ) THEN PRINT * , \"Error : Matrix A must be square and size of c must be at least N+1\" STOP END IF END IF ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I DO k = 2 , N AB = MATMUL ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / REAL ( k , dp ) Bk = AB + c ( k + 1 ) * I IF ( k == N - 1 . AND . PRESENT ( Ainv )) B_Nm1 = - Bk END DO IF ( PRESENT ( Ainv ) . AND . PRESENT ( success )) THEN IF ( ABS ( c ( N + 1 )) < 1.0e-12_dp ) THEN success = . FALSE . Ainv = 0.0_dp ELSE success = . TRUE . Ainv = B_Nm1 / c ( N + 1 ) END IF ELSE IF ( PRESENT ( Ainv )) THEN IF ( ABS ( c ( N + 1 )) < 1.0e-12_dp ) THEN Ainv = 0.0_dp ELSE Ainv = B_Nm1 / c ( N + 1 ) END IF END IF END SUBROUTINE Faddeev_Leverrier END MODULE NAFPack_matrix_tools","tags":"","url":"sourcefile\\nafpack_matrix_tools.f90.html"},{"title":"NAFPack_Direct_methode.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_direct_methode.f90~~EfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_direct_methode.f90~~AfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for direct methods in NAFPack MODULE NAFPack_Direct_method USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matrix_properties USE NAFPack_Direct_types USE NAFPack_matrix_tools IMPLICIT NONE PRIVATE PUBLIC :: DirectMethod PUBLIC :: METHOD_Gauss , METHOD_Gauss_JORDAN PUBLIC :: METHOD_LU , METHOD_LDU PUBLIC :: METHOD_CHOLESKY , METHOD_LDL_Cholesky PUBLIC :: METHOD_QR PUBLIC :: METHOD_TDMA PUBLIC :: METHOD_FADDEEV_LEVERRIER PUBLIC :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT , QR_GRAM_SCHMIDT_Modified TYPE :: DirectMethod PRIVATE TYPE ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE TYPE ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT LOGICAL :: use_partial_pivot = . FALSE . LOGICAL :: use_total_pivot = . FALSE . TYPE ( DirectMethodRequirements ) :: requirements PROCEDURE ( solve_interface_Direct ), PASS ( this ), POINTER :: solve_method => NULL () CONTAINS PROCEDURE :: set_method => set_method PROCEDURE :: set_qr_method => set_qr_method PROCEDURE :: solve => DirectMethod_solve PROCEDURE :: test_matrix => test_matrix END TYPE DirectMethod ABSTRACT INTERFACE FUNCTION solve_interface_Direct ( this , A , b ) RESULT ( x ) IMPORT :: dp IMPORT :: DirectMethod CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x END FUNCTION solve_interface_Direct END INTERFACE CONTAINS SUBROUTINE set_method ( this , method , set_pivot_partial , set_pivot_total ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this TYPE ( MethodTypeDirect ), INTENT ( IN ) :: method LOGICAL , OPTIONAL :: set_pivot_partial , set_pivot_total this % use_total_pivot = . FALSE . this % use_partial_pivot = . FALSE . this % requirements = DirectMethodRequirements () SELECT CASE ( method % value ) CASE ( METHOD_Gauss % value ) this % solve_method => solve_Gauss this % method_type = METHOD_Gauss this % requirements % needs_square = . TRUE . CASE ( METHOD_Gauss_JORDAN % value ) this % solve_method => solve_GaussJordan this % method_type = METHOD_Gauss_JORDAN this % requirements % needs_square = . TRUE . CASE ( METHOD_LU % value ) this % solve_method => solve_LU this % method_type = METHOD_LU this % requirements % needs_square = . TRUE . CASE ( METHOD_LDU % value ) this % solve_method => solve_LDU this % method_type = METHOD_LDU this % requirements % needs_square = . TRUE . this % requirements % needs_non_zero_diag = . TRUE . CASE ( METHOD_CHOLESKY % value ) this % solve_method => solve_Cholesky this % method_type = METHOD_CHOLESKY this % requirements % needs_square = . TRUE . this % requirements % needs_SPD = . TRUE . CASE ( METHOD_LDL_Cholesky % value ) this % solve_method => solve_LDL_Cholesky this % method_type = METHOD_LDL_Cholesky this % requirements % needs_square = . TRUE . this % requirements % needs_symmetric = . TRUE . CASE ( METHOD_QR % value ) this % solve_method => solve_QR this % method_type = METHOD_QR this % requirements % needs_square = . TRUE . CASE ( METHOD_TDMA % value ) this % solve_method => solve_TDMA this % method_type = METHOD_TDMA this % requirements % needs_square = . TRUE . this % requirements % needs_tridiagonal = . TRUE . this % requirements % needs_non_zero_diag = . TRUE . CASE ( METHOD_FADDEEV_LEVERRIER % value ) this % solve_method => solve_Faddeev_Leverrier this % method_type = METHOD_FADDEEV_LEVERRIER this % requirements % needs_square = . TRUE . CASE DEFAULT STOP \"ERROR :: Unknown method direct\" END SELECT IF ( PRESENT ( set_pivot_partial )) THEN IF ( set_pivot_partial ) this % use_partial_pivot = . TRUE . ELSE IF ( PRESENT ( set_pivot_total )) THEN IF ( set_pivot_total ) this % use_total_pivot = . TRUE . END IF END SUBROUTINE set_method SUBROUTINE set_qr_method ( this , qr_method ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this TYPE ( MethodQR ), INTENT ( IN ) :: qr_method this % qr_method = qr_method END SUBROUTINE set_qr_method SUBROUTINE test_matrix ( this , A , strict_mode ) CLASS ( DirectMethod ), INTENT ( INOUT ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A LOGICAL , OPTIONAL , INTENT ( IN ) :: strict_mode LOGICAL :: strict strict = . FALSE . IF ( PRESENT ( strict_mode )) strict = strict_mode IF ( this % requirements % needs_square ) THEN PRINT * , \"Checking if the matrix is square...\" IF (. NOT . is_square_matrix ( A )) THEN IF ( strict ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a square matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a square matrix.\" END IF END IF END IF IF ( this % requirements % needs_SPD ) THEN PRINT * , \"Checking if the matrix is symmetric positive definite (SPD)...\" IF (. NOT . is_SPD ( A )) THEN IF ( strict ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric positive definite matrix.\" END IF END IF END IF IF ( this % requirements % needs_non_zero_diag ) THEN PRINT * , \"Checking if the matrix has a non-zero diagonal...\" IF (. NOT . is_non_zero_diagonal ( A )) THEN IF ( strict ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a non-zero diagonal matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a non-zero diagonal matrix.\" END IF END IF END IF IF ( this % requirements % needs_tridiagonal ) THEN PRINT * , \"Checking if the matrix is tridiagonal...\" IF (. NOT . is_tridiagonal ( A )) THEN IF ( strict ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a tridiagonal matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a tridiagonal matrix.\" END IF END IF END IF IF ( this % requirements % needs_symmetric ) THEN PRINT * , \"Checking if the matrix is symmetric...\" IF (. NOT . is_symmetric ( A )) THEN IF ( strict ) THEN STOP \"ERROR :: \" // this % method_type % name // \" method requires a symmetric matrix.\" ELSE PRINT * , \"WARNING :: \" // this % method_type % name // \" method requires a symmetric matrix.\" END IF END IF END IF END SUBROUTINE test_matrix FUNCTION DirectMethod_solve ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x IF (. NOT . ASSOCIATED ( this % solve_method )) THEN STOP \"ERROR :: No solution method has been set. Call set_method first.\" END IF x = this % solve_method ( A , b ) END FUNCTION DirectMethod_solve FUNCTION solve_Gauss ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER :: i , k , n , allocate_status REAL ( dp ) :: pivot , m A_tmp = A b_tmp = b N = SIZE ( A_tmp , 1 ) IF ( this % use_total_pivot ) THEN ALLOCATE ( Q_final ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q_final\" Q_final = Identity_n ( N ) END IF IF ( this % use_partial_pivot ) CALL pivot_partial ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) CALL pivot_total ( A_tmp , b_tmp , Q_final ) DO k = 1 , N - 1 pivot = A_tmp ( k , k ) IF ( ABS ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" DO i = k + 1 , N m = A_tmp ( i , k ) / pivot A_tmp ( i , k ) = 0 ! Vectorized operation A_tmp ( i , k + 1 : N ) = A_tmp ( i , k + 1 : N ) - m * A_tmp ( k , k + 1 : N ) b_tmp ( i ) = b_tmp ( i ) - m * b_tmp ( k ) END DO END DO x = backward ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) x = MATMUL ( Q_final , x ) END FUNCTION solve_Gauss FUNCTION solve_GaussJordan ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER :: i , k , N , allocate_status REAL ( dp ) :: pivot , factor A_tmp = A b_tmp = b N = SIZE ( A_tmp , 1 ) IF ( this % use_total_pivot ) THEN ALLOCATE ( Q_final ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q_final\" Q_final = Identity_n ( N ) END IF IF ( this % use_partial_pivot ) CALL pivot_partial ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) CALL pivot_total ( A_tmp , b_tmp , Q_final ) DO k = 1 , N pivot = A_tmp ( k , k ) IF ( ABS ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" ! Normalisation du pivot A_tmp ( k , :) = A_tmp ( k , :) / pivot b_tmp ( k ) = b_tmp ( k ) / pivot ! Élimination dans toutes les autres lignes DO i = 1 , N IF ( i /= k ) THEN factor = A_tmp ( i , k ) A_tmp ( i , :) = A_tmp ( i , :) - factor * A_tmp ( k , :) b_tmp ( i ) = b_tmp ( i ) - factor * b_tmp ( k ) END IF END DO END DO x = b_tmp IF ( this % use_total_pivot ) x = MATMUL ( Q_final , x ) END FUNCTION solve_GaussJordan FUNCTION solve_LU ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , U REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER :: N , allocate_status A_tmp = A b_tmp = b N = SIZE ( A , 1 ) IF ( this % use_total_pivot ) THEN ALLOCATE ( Q_final ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q_final\" Q_final = Identity_n ( N ) END IF IF ( this % use_partial_pivot ) CALL pivot_partial ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) CALL pivot_total ( A_tmp , b_tmp , Q_final ) CALL LU_decomposition ( A_tmp , L , U ) x = forward ( L , b_tmp ) x = backward ( U , x ) IF ( this % use_total_pivot ) x = MATMUL ( Q_final , x ) END FUNCTION solve_LU FUNCTION solve_LDU ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , D , U REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER :: N , allocate_status A_tmp = A b_tmp = b N = SIZE ( A , 1 ) IF ( this % use_total_pivot ) THEN ALLOCATE ( Q_final ( N , N ), STAT = allocate_status ) IF ( allocate_status /= 0 ) STOP \"ERROR :: Unable to allocate Q_final\" Q_final = Identity_n ( N ) END IF IF ( this % use_partial_pivot ) CALL pivot_partial ( A_tmp , b_tmp ) IF ( this % use_total_pivot ) CALL pivot_total ( A_tmp , b_tmp , Q_final ) CALL LDU_decomposition ( A_tmp , L , D , U ) x = forward ( L , b_tmp ) x = forward ( D , x ) x = backward ( U , x ) IF ( this % use_total_pivot ) x = MATMUL ( Q_final , x ) END FUNCTION solve_LDU FUNCTION solve_Cholesky ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L CALL Cholesky_decomposition ( A , L ) x = forward ( L , b ) x = backward ( TRANSPOSE ( L ), x ) END FUNCTION solve_Cholesky FUNCTION solve_LDL_Cholesky ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , D CALL LDL_Cholesky_decomposition ( A , L , D ) x = forward ( L , b ) x = forward ( D , x ) x = backward ( TRANSPOSE ( L ), x ) END FUNCTION solve_LDL_Cholesky FUNCTION solve_QR ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Q , R SELECT CASE ( this % qr_method % value ) CASE ( QR_HOUSEHOLDER % value ) CALL QR_Householder_decomposition ( A , Q , R ) CASE ( QR_GIVENS % value ) CALL QR_Givens_decomposition ( A , Q , R ) CASE ( QR_GRAM_SCHMIDT % value ) CALL QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) CASE ( QR_GRAM_SCHMIDT_Modified % value ) CALL QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) CASE DEFAULT STOP \"ERROR :: Unknown QR method\" END SELECT x = backward ( R , MATMUL ( TRANSPOSE ( Q ), b )) END FUNCTION solve_QR FUNCTION solve_TDMA ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: alpha , beta REAL ( dp ) :: denom INTEGER :: n , i N = SIZE ( A , 1 ) alpha = 0.0_dp beta = 0.0_dp alpha ( 1 ) = A ( 1 , 2 ) / A ( 1 , 1 ) beta ( 1 ) = b ( 1 ) / A ( 1 , 1 ) DO i = 2 , N denom = A ( i , i ) - A ( i , i - 1 ) * alpha ( i - 1 ) IF ( i < N ) alpha ( i ) = A ( i , i + 1 ) / denom beta ( i ) = ( b ( i ) - A ( i , i - 1 ) * beta ( i - 1 )) / denom END DO x ( n ) = beta ( n ) DO i = n - 1 , 1 , - 1 x ( i ) = beta ( i ) - alpha ( i ) * x ( i + 1 ) END DO END FUNCTION solve_TDMA FUNCTION solve_Faddeev_Leverrier ( this , A , b ) RESULT ( x ) CLASS ( DirectMethod ), INTENT ( IN ) :: this REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Ainv REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) + 1 ) :: c LOGICAL :: success CALL Faddeev_Leverrier ( A , c , Ainv = Ainv , success = success , check = . FALSE .) IF (. NOT . success ) THEN PRINT * , \"WARNING :: Faddeev-Leverrier method failed, using LU decomposition instead\" x = solve_LU ( this , A , b ) ELSE x = MATMUL ( Ainv , b ) END IF END FUNCTION solve_Faddeev_Leverrier SUBROUTINE pivot_partial ( A , b ) REAL ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: A REAL ( dp ), DIMENSION (:), INTENT ( INOUT ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: P INTEGER , DIMENSION ( 1 ) :: vlmax INTEGER :: N , lmax , k N = SIZE ( A , 1 ) DO k = 1 , N - 1 ! Find the maximum absolute value in the column from row k to N vlmax = MAXLOC ( ABS ( A ( k : N , k ))) lmax = vlmax ( 1 ) + k - 1 !calculate permutation matrix P P = Identity_n ( N ) IF ( k /= lmax ) THEN P = rotation_matrix ( P , [ k , lmax ]) END IF A = MATMUL ( P , A ) b = MATMUL ( P , b ) END DO END SUBROUTINE pivot_partial SUBROUTINE pivot_total ( A , b , Q_final ) REAL ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: A REAL ( dp ), DIMENSION (:), INTENT ( INOUT ) :: b REAL ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: Q_final REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: P , Q INTEGER , DIMENSION ( 2 ) :: vlmax INTEGER :: N , lmax , cmax , k N = SIZE ( A , 1 ) DO k = 1 , N - 1 ! Find max abs element in submatrix vlmax = MAXLOC ( ABS ( A ( k : N , k : N ))) lmax = vlmax ( 1 ) + k - 1 cmax = vlmax ( 2 ) + k - 1 ! permute line if necessary P = Identity_n ( N ) IF ( lmax /= k ) THEN P = rotation_matrix ( P , [ k , lmax ]) END IF ! permute column if necessary Q = Identity_n ( N ) IF ( cmax /= k ) THEN Q = rotation_matrix ( Q , [ k , cmax ]) END IF Q_final = MATMUL ( Q , Q_final ) ! Apply permutations A = MATMUL ( P , A ) A = MATMUL ( A , Q ) b = MATMUL ( P , b ) END DO END SUBROUTINE pivot_total END MODULE NAFPack_Direct_method","tags":"","url":"sourcefile\\nafpack_direct_methode.f90.html"},{"title":"NAFPack_Iterative_types.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_types.f90~~EfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_constant.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_types.f90~~AfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_iterative_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code MODULE NAFPack_Iterative_types USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: MethodTypeIterative PUBLIC :: METHOD_ITERATIVE_NONE PUBLIC :: METHOD_Jacobi , METHOD_JOR PUBLIC :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR PUBLIC :: METHOD_SIP_ILU , METHOD_SIP_ICF PUBLIC :: METHOD_RICHARDSON PUBLIC :: METHOD_CONJUGATE_GRADIENT PUBLIC :: METHOD_CONJUGATE_RESIDUAL PUBLIC :: IterativeMethodRequirements TYPE :: MethodTypeIterative INTEGER :: value CHARACTER ( LEN = 64 ) :: name END TYPE MethodTypeIterative TYPE :: IterativeMethodRequirements LOGICAL :: needs_SPD = . FALSE . LOGICAL :: needs_diag_dom = . FALSE . LOGICAL :: needs_square = . FALSE . LOGICAL :: needs_symetric = . FALSE . END TYPE IterativeMethodRequirements TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_ITERATIVE_NONE = MethodTypeIterative ( 0 , \"None\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_Jacobi = MethodTypeIterative ( 1 , \"Jacobi\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_GAUSS_SEIDEL = MethodTypeIterative ( 2 , \"Gauss-Seidel\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SOR = MethodTypeIterative ( 3 , \"Successive Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_JOR = MethodTypeIterative ( 4 , \"Jacobi Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SIP_ILU = MethodTypeIterative ( 5 , \"Strongly Implicit Procedure with ILU\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SIP_ICF = MethodTypeIterative ( 6 , \"Strongly Implicit Procedure with ICF\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_SSOR = MethodTypeIterative ( 7 , \"Symmetric Successive Over-Relaxation\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_RICHARDSON = MethodTypeIterative ( 8 , \"Richardson\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative ( 9 , \"Conjugate Gradient\" ) TYPE ( MethodTypeIterative ), PARAMETER :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative ( 10 , \"Conjugate Residual\" ) END MODULE NAFPack_Iterative_types","tags":"","url":"sourcefile\\nafpack_iterative_types.f90.html"}]}