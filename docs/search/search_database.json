var tipuesearch = {"pages":[{"title":" NAFPack ","text":"NAFPack NAFPack Features Author License About This Documentation Warning This documentation is a work in progress NAFPack A modern, modular, and open-source Fortran package for numerical analysis, designed to provide robust and efficient tools for scientific computing. Features Fast Fourier Transform (FFT) Linear system solvers Eigenvalue and eigenvector computations And more... Author Minard-Jules License This project is licensed under the MIT License . About This Documentation This documentation provides an overview of the NAFPack project, including installation instructions, usage examples. Please note that this documentation is a work in progress and may be updated frequently. Developer Info Minard Jules","tags":"home","url":"index.html"},{"title":"DirectMethod – NAFPack ","text":"type, public :: DirectMethod Inherits type~~directmethod~~InheritsGraph type~directmethod DirectMethod type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~directmethod~~InheritedByGraph type~directmethod DirectMethod type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method, set_pivot_partial, set_pivot_total) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodTypeDirect ), intent(in) :: method logical, intent(in), optional :: set_pivot_partial logical, intent(in), optional :: set_pivot_total procedure, public :: set_qr_method private  subroutine set_qr_method(this, qr_method) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this type( MethodQR ), intent(in) :: qr_method procedure, public :: solve => DirectMethod_solve private  function DirectMethod_solve(this, A, b) result(x) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(in) :: this real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp), dimension(size(A, 1)) procedure, public :: test_matrix private  subroutine test_matrix(this, A, strict_mode) Arguments Type Intent Optional Attributes Name class( DirectMethod ), intent(inout) :: this real(kind=dp), intent(in), dimension(:, :) :: A logical, intent(in), optional :: strict_mode Source Code type :: DirectMethod private type ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE type ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT logical :: use_partial_pivot = . false . logical :: use_total_pivot = . false . type ( DirectMethodRequirements ) :: requirements procedure ( solve_interface_Direct ), pass ( this ), pointer :: solve_method => null () contains procedure :: set_method => set_method procedure :: set_qr_method => set_qr_method procedure :: solve => DirectMethod_solve procedure :: test_matrix => test_matrix end type DirectMethod","tags":"","url":"type\\directmethod.html"},{"title":"MethodTypeIterative – NAFPack ","text":"type, public :: MethodTypeIterative Inherited by type~~methodtypeiterative~~InheritedByGraph type~methodtypeiterative MethodTypeIterative type~iterativemethod IterativeMethod type~iterativemethod->type~methodtypeiterative method_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name character(len=64), public :: name2 = \"\" Source Code type :: MethodTypeIterative integer :: id character ( LEN = 64 ) :: name character ( LEN = 64 ) :: name2 = \"\" end type MethodTypeIterative","tags":"","url":"type\\methodtypeiterative.html"},{"title":"IterativeMethodRequirements – NAFPack ","text":"type, public :: IterativeMethodRequirements Inherited by type~~iterativemethodrequirements~~InheritedByGraph type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod IterativeMethod type~iterativemethod->type~iterativemethodrequirements requirements type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .false. logical, public :: needs_diag_dom = .false. logical, public :: needs_square = .false. logical, public :: needs_symetric = .false. Source Code type :: IterativeMethodRequirements logical :: needs_SPD = . false . logical :: needs_diag_dom = . false . logical :: needs_square = . false . logical :: needs_symetric = . false . end type IterativeMethodRequirements","tags":"","url":"type\\iterativemethodrequirements.html"},{"title":"Norm_used – NAFPack ","text":"type, public :: Norm_used Inherited by type~~norm_used~~InheritedByGraph type~norm_used Norm_used type~iterativeparams IterativeParams type~iterativeparams->type~norm_used norm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code type :: Norm_used integer :: id character ( LEN = 64 ) :: name end type Norm_used","tags":"","url":"type\\norm_used.html"},{"title":"relaxation_factor_used – NAFPack ","text":"type, public :: relaxation_factor_used Inherited by type~~relaxation_factor_used~~InheritedByGraph type~relaxation_factor_used relaxation_factor_used type~iterativemethod IterativeMethod type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(kind=ucs4, len=64), public :: name Source Code type :: relaxation_factor_used integer :: id character ( KIND = ucs4 , LEN = 64 ) :: name end type relaxation_factor_used","tags":"","url":"type\\relaxation_factor_used.html"},{"title":"DecimationMethod – NAFPack ","text":"type, public :: DecimationMethod Inherited by type~~decimationmethod~~InheritedByGraph type~decimationmethod DecimationMethod type~fftalgorithm FFTAlgorithm type~fftalgorithm->type~decimationmethod decimation_method type~fftplan FFTPlan type~fftplan->type~fftalgorithm algorithm type~fourier_transform Fourier_Transform type~fourier_transform->type~fftplan fft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=isp), public :: id character(len=20), public :: name Source Code type :: DecimationMethod integer ( isp ) :: id character ( len = 20 ) :: name end type DecimationMethod","tags":"","url":"type\\decimationmethod.html"},{"title":"FFTAlgorithm – NAFPack ","text":"type, public :: FFTAlgorithm Inherits type~~fftalgorithm~~InheritsGraph type~fftalgorithm FFTAlgorithm type~decimationmethod DecimationMethod type~fftalgorithm->type~decimationmethod decimation_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~fftalgorithm~~InheritedByGraph type~fftalgorithm FFTAlgorithm type~fftplan FFTPlan type~fftplan->type~fftalgorithm algorithm type~fourier_transform Fourier_Transform type~fourier_transform->type~fftplan fft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=isp), public :: id character(len=20), public :: name type( DecimationMethod ), public :: decimation_method Source Code type :: FFTAlgorithm integer ( isp ) :: id character ( len = 20 ) :: name type ( DecimationMethod ) :: decimation_method end type FFTAlgorithm","tags":"","url":"type\\fftalgorithm.html"},{"title":"Fourier_Transform – NAFPack ","text":"type, public :: Fourier_Transform Inherits type~~fourier_transform~~InheritsGraph type~fourier_transform Fourier_Transform type~fftplan FFTPlan type~fourier_transform->type~fftplan fft_plan type~fftalgorithm FFTAlgorithm type~fftplan->type~fftalgorithm algorithm type~splitradixtwiddles SplitRadixTwiddles type~fftplan->type~splitradixtwiddles split_radix_twiddles type~twiddles_sp Twiddles_sp type~fftplan->type~twiddles_sp twiddles type~decimationmethod DecimationMethod type~fftalgorithm->type~decimationmethod decimation_method type~splitradixindices SplitRadixindices type~splitradixtwiddles->type~splitradixindices indices Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(FFTPlan), public :: fft_plan Type-Bound Procedures generic, public :: dft => dft_cmplx_sp, dft_cmplx_dp, dft_cmplx_qp private  interface dft_cmplx_sp() Arguments None private  interface dft_cmplx_dp() Arguments None private  interface dft_cmplx_qp() Arguments None generic, public :: dft => dft_real_sp, dft_real_dp, dft_real_qp private  interface dft_real_sp() Arguments None private  interface dft_real_dp() Arguments None private  interface dft_real_qp() Arguments None generic, public :: dft => dft2_cmplx_sp, dft2_cmplx_dp, dft2_cmplx_qp private  interface dft2_cmplx_sp() Arguments None private  interface dft2_cmplx_dp() Arguments None private  interface dft2_cmplx_qp() Arguments None generic, public :: dft => dft2_real_sp, dft2_real_dp, dft2_real_qp private  interface dft2_real_sp() Arguments None private  interface dft2_real_dp() Arguments None private  interface dft2_real_qp() Arguments None generic, public :: dft => dft3_cmplx_sp, dft3_cmplx_dp, dft3_cmplx_qp private  interface dft3_cmplx_sp() Arguments None private  interface dft3_cmplx_dp() Arguments None private  interface dft3_cmplx_qp() Arguments None generic, public :: dft => dft3_real_sp, dft3_real_dp, dft3_real_qp private  interface dft3_real_sp() Arguments None private  interface dft3_real_dp() Arguments None private  interface dft3_real_qp() Arguments None generic, public :: idft => idft_cmplx_sp, idft_cmplx_dp, idft_cmplx_qp private  interface idft_cmplx_sp() Arguments None private  interface idft_cmplx_dp() Arguments None private  interface idft_cmplx_qp() Arguments None generic, public :: idft => idft_real_sp, idft_real_dp, idft_real_qp private  interface idft_real_sp() Arguments None private  interface idft_real_dp() Arguments None private  interface idft_real_qp() Arguments None generic, public :: idft => idft2_cmplx_sp, idft2_cmplx_dp, idft2_cmplx_qp private  interface idft2_cmplx_sp() Arguments None private  interface idft2_cmplx_dp() Arguments None private  interface idft2_cmplx_qp() Arguments None generic, public :: idft => idft2_real_sp, idft2_real_dp, idft2_real_qp private  interface idft2_real_sp() Arguments None private  interface idft2_real_dp() Arguments None private  interface idft2_real_qp() Arguments None generic, public :: idft => idft3_cmplx_sp, idft3_cmplx_dp, idft3_cmplx_qp private  interface idft3_cmplx_sp() Arguments None private  interface idft3_cmplx_dp() Arguments None private  interface idft3_cmplx_qp() Arguments None generic, public :: idft => idft3_real_sp, idft3_real_dp, idft3_real_qp private  interface idft3_real_sp() Arguments None private  interface idft3_real_dp() Arguments None private  interface idft3_real_qp() Arguments None generic, public :: init_fft_plan => init_fft_plan_sp private  interface init_fft_plan_sp() Arguments None generic, public :: fft => fft_cmplx_sp private  interface fft_cmplx_sp() Arguments None generic, public :: destroy_fft_plan => destroy_fft_plan_sp private  interface destroy_fft_plan_sp() Arguments None Source Code type :: Fourier_Transform type ( FFTPlan ) :: fft_plan contains procedure , nopass , private :: dft_cmplx_sp , dft_cmplx_dp , dft_cmplx_qp generic :: dft => dft_cmplx_sp , dft_cmplx_dp , dft_cmplx_qp procedure , nopass , private :: dft_real_sp , dft_real_dp , dft_real_qp generic :: dft => dft_real_sp , dft_real_dp , dft_real_qp procedure , nopass , private :: dft2_cmplx_sp , dft2_cmplx_dp , dft2_cmplx_qp generic :: dft => dft2_cmplx_sp , dft2_cmplx_dp , dft2_cmplx_qp procedure , nopass , private :: dft2_real_sp , dft2_real_dp , dft2_real_qp generic :: dft => dft2_real_sp , dft2_real_dp , dft2_real_qp procedure , nopass , private :: dft3_cmplx_sp , dft3_cmplx_dp , dft3_cmplx_qp generic :: dft => dft3_cmplx_sp , dft3_cmplx_dp , dft3_cmplx_qp procedure , nopass , private :: dft3_real_sp , dft3_real_dp , dft3_real_qp generic :: dft => dft3_real_sp , dft3_real_dp , dft3_real_qp procedure , nopass , private :: idft_cmplx_sp , idft_cmplx_dp , idft_cmplx_qp generic :: idft => idft_cmplx_sp , idft_cmplx_dp , idft_cmplx_qp procedure , nopass , private :: idft_real_sp , idft_real_dp , idft_real_qp generic :: idft => idft_real_sp , idft_real_dp , idft_real_qp procedure , nopass , private :: idft2_cmplx_sp , idft2_cmplx_dp , idft2_cmplx_qp generic :: idft => idft2_cmplx_sp , idft2_cmplx_dp , idft2_cmplx_qp procedure , nopass , private :: idft2_real_sp , idft2_real_dp , idft2_real_qp generic :: idft => idft2_real_sp , idft2_real_dp , idft2_real_qp procedure , nopass , private :: idft3_cmplx_sp , idft3_cmplx_dp , idft3_cmplx_qp generic :: idft => idft3_cmplx_sp , idft3_cmplx_dp , idft3_cmplx_qp procedure , nopass , private :: idft3_real_sp , idft3_real_dp , idft3_real_qp generic :: idft => idft3_real_sp , idft3_real_dp , idft3_real_qp procedure , private :: init_fft_plan_sp generic :: init_fft_plan => init_fft_plan_sp procedure , private :: fft_cmplx_sp generic :: fft => fft_cmplx_sp procedure , private :: destroy_fft_plan_sp generic :: destroy_fft_plan => destroy_fft_plan_sp end type Fourier_Transform","tags":"","url":"type\\fourier_transform.html"},{"title":"linalg – NAFPack ","text":"type, public :: linalg Inherits type~~linalg~~InheritsGraph type~linalg linalg type~directmethod DirectMethod type~linalg->type~directmethod direct type~iterativemethod IterativeMethod type~linalg->type~iterativemethod iterative type~directmethodrequirements DirectMethodRequirements type~directmethod->type~directmethodrequirements requirements type~methodqr MethodQR type~directmethod->type~methodqr qr_method type~methodtypedirect MethodTypeDirect type~directmethod->type~methodtypedirect method_type type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type type~relaxation_factor_used relaxation_factor_used type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative Source Code type :: linalg type ( DirectMethod ) :: direct type ( IterativeMethod ) :: iterative end type linalg","tags":"","url":"type\\linalg.html"},{"title":"IterativeMethod – NAFPack ","text":"type, public :: IterativeMethod Inherits type~~iterativemethod~~InheritsGraph type~iterativemethod IterativeMethod type~iterativemethodrequirements IterativeMethodRequirements type~iterativemethod->type~iterativemethodrequirements requirements type~methodpreconditioner MethodPreconditioner type~iterativemethod->type~methodpreconditioner preconditioner_type type~methodtypeiterative MethodTypeIterative type~iterativemethod->type~methodtypeiterative method_type type~relaxation_factor_used relaxation_factor_used type~iterativemethod->type~relaxation_factor_used relaxation_factor, relaxation_factor_preconditioner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~iterativemethod~~InheritedByGraph type~iterativemethod IterativeMethod type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: set_method private  subroutine set_method(this, method) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( MethodTypeIterative ), intent(in) :: method procedure, public :: solve => IterativeMethod_solve private  function IterativeMethod_solve(this, A, b, params, verbose) result(x) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(in) :: this real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b type( IterativeParams ), intent(inout) :: params type( Logger ), intent(inout), optional :: verbose Return Value real(kind=dp), dimension(size(A, 1)) procedure, public :: Init_IterativeParams private  function Init_IterativeParams(this, N, A, x0, max_iter_choice, epsi_tol, omega, Norm_choice, fill_level, method_preconditioner, alpha, is_stationary, is_strict_mode) result(params) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this integer, intent(in) :: N real(kind=dp), intent(in), optional, dimension(:, :) :: A real(kind=dp), intent(in), optional, dimension(:) :: x0 integer, intent(in), optional :: max_iter_choice real(kind=dp), intent(in), optional :: epsi_tol real(kind=dp), intent(in), optional :: omega type( Norm_used ), intent(in), optional :: Norm_choice type( Fill_level_used ), intent(in), optional :: fill_level type( MethodPreconditioner ), intent(in), optional :: method_preconditioner real(kind=dp), intent(in), optional :: alpha logical, intent(in), optional :: is_stationary logical, intent(in), optional :: is_strict_mode Return Value type( IterativeParams ) procedure, public :: Dealocate_IterativeParams private  subroutine Dealocate_IterativeParams(this, params, success) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this type( IterativeParams ), intent(inout) :: params logical, intent(out), optional :: success procedure, public :: test_matrix private  subroutine test_matrix(this, A, params, verbose) Arguments Type Intent Optional Attributes Name class( IterativeMethod ), intent(inout) :: this real(kind=dp), intent(in), dimension(:, :) :: A type( IterativeParams ), intent(in) :: params type( Logger ), intent(inout), optional :: verbose Source Code type :: IterativeMethod private type ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE type ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE type ( IterativeMethodRequirements ) :: requirements type ( relaxation_factor_used ) :: relaxation_factor = RELAXATION_FACTOR_NONE type ( relaxation_factor_used ) :: relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE procedure ( solve_interface_Iterative ), pass ( this ), pointer :: solve_method => null () contains procedure :: set_method => set_method procedure :: solve => IterativeMethod_solve procedure :: Init_IterativeParams => Init_IterativeParams procedure :: Dealocate_IterativeParams => Dealocate_IterativeParams procedure :: test_matrix => test_matrix end type IterativeMethod","tags":"","url":"type\\iterativemethod.html"},{"title":"Format_file – NAFPack ","text":"type, public :: Format_file Inherited by type~~format_file~~InheritedByGraph type~format_file Format_file type~logger Logger type~logger->type~format_file file_format Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id = 1 character(len=10), public :: format_name = \"txt\" character(len=100), public :: format_description = \"Text file format\" Source Code type :: Format_file integer :: id = 1 character ( LEN = 10 ) :: format_name = \"txt\" character ( LEN = 100 ) :: format_description = \"Text file format\" end type Format_file","tags":"","url":"type\\format_file.html"},{"title":"Logger – NAFPack ","text":"type, public :: Logger Inherits type~~logger~~InheritsGraph type~logger Logger type~format_file Format_file type~logger->type~format_file file_format Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: verbosity_level = 1 logical, public :: to_terminal = .true. logical, public :: to_file = .false. integer, public :: frequency = 10 character(len=100), public :: filename = \"Log\" type( Format_file ), public :: file_format = FORMAT_FILE_LOG integer, public :: file_unit = 99 character(len=100), public :: message = \"Default log message\" logical, public :: show_Logger_initialization = .true. logical, public :: show_matrix_test = .true. logical, public :: show_info_solver = .true. logical, public :: show_iteration = .true. logical, public :: show_final = .true. Type-Bound Procedures procedure, public :: init => init_logger private  subroutine init_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this procedure, public :: log_info private  subroutine log_info(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_detail private  subroutine log_detail(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_warning private  subroutine log_warning(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_error private  subroutine log_error(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: log_time private  subroutine log_time(this, msg) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this character(kind=ucs4, len=*), intent(in) :: msg procedure, public :: write => write_output private  subroutine write_output(this, msg, name_level, color_level, box_style) Arguments Type Intent Optional Attributes Name class( Logger ), intent(in) :: this character(kind=ucs4, len=*), intent(in) :: msg character(kind=ucs4, len=*), intent(in), optional :: name_level character(kind=ucs4, len=*), intent(in), optional :: color_level character(len=*), intent(in), optional :: box_style procedure, public :: close => close_logger private  subroutine close_logger(this) Arguments Type Intent Optional Attributes Name class( Logger ), intent(inout) :: this Source Code type :: Logger integer :: verbosity_level = 1 logical :: to_terminal = . true . logical :: to_file = . false . integer :: frequency = 10 character ( LEN = 100 ) :: filename = \"Log\" type ( Format_file ) :: file_format = FORMAT_FILE_LOG integer :: file_unit = 99 character ( LEN = 100 ) :: message = \"Default log message\" logical :: show_Logger_initialization = . true . logical :: show_matrix_test = . true . logical :: show_info_solver = . true . logical :: show_iteration = . true . logical :: show_final = . true . contains procedure :: init => init_logger procedure :: log_info procedure :: log_detail procedure :: log_warning procedure :: log_error procedure :: log_time procedure :: write => write_output procedure :: close => close_logger end type Logger","tags":"","url":"type\\logger.html"},{"title":"MethodTypeDirect – NAFPack ","text":"type, public :: MethodTypeDirect Inherited by type~~methodtypedirect~~InheritedByGraph type~methodtypedirect MethodTypeDirect type~directmethod DirectMethod type~directmethod->type~methodtypedirect method_type type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code type :: MethodTypeDirect integer :: id character ( LEN = 64 ) :: name end type MethodTypeDirect","tags":"","url":"type\\methodtypedirect.html"},{"title":"MethodQR – NAFPack ","text":"type, public :: MethodQR Inherited by type~~methodqr~~InheritedByGraph type~methodqr MethodQR type~directmethod DirectMethod type~directmethod->type~methodqr qr_method type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code type :: MethodQR integer :: id character ( LEN = 64 ) :: name end type MethodQR","tags":"","url":"type\\methodqr.html"},{"title":"DirectMethodRequirements – NAFPack ","text":"type, public :: DirectMethodRequirements Inherited by type~~directmethodrequirements~~InheritedByGraph type~directmethodrequirements DirectMethodRequirements type~directmethod DirectMethod type~directmethod->type~directmethodrequirements requirements type~linalg linalg type~linalg->type~directmethod direct Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .false. logical, public :: needs_non_zero_diag = .false. logical, public :: needs_square = .false. logical, public :: needs_tridiagonal = .false. logical, public :: needs_symmetric = .false. Source Code type :: DirectMethodRequirements logical :: needs_SPD = . false . logical :: needs_non_zero_diag = . false . logical :: needs_square = . false . logical :: needs_tridiagonal = . false . logical :: needs_symmetric = . false . end type DirectMethodRequirements","tags":"","url":"type\\directmethodrequirements.html"},{"title":"AnsiCode – NAFPack ","text":"type, public :: AnsiCode Source Code type :: AnsiCode private !> Style descriptor logical :: use_style = . false . integer ( i8 ) :: style = - 1_i8 !> Foreground color logical :: use_fg = . false . integer ( i16 ) :: fg = - 1_i16 !> Background color logical :: use_bg = . false . integer ( i16 ) :: bg = - 1_i16 end type AnsiCode","tags":"","url":"type\\ansicode.html"},{"title":"ColorsAscii – NAFPack ","text":"type, public :: ColorsAscii Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: reset character(len=:), public, allocatable :: bold character(len=:), public, allocatable :: faint character(len=:), public, allocatable :: italic character(len=:), public, allocatable :: underline character(len=:), public, allocatable :: blink character(len=:), public, allocatable :: reverse character(len=:), public, allocatable :: hidden character(len=:), public, allocatable :: strikethrough character(len=:), public, allocatable :: red character(len=:), public, allocatable :: green character(len=:), public, allocatable :: yellow character(len=:), public, allocatable :: blue character(len=:), public, allocatable :: magenta character(len=:), public, allocatable :: cyan character(len=:), public, allocatable :: white character(len=:), public, allocatable :: bright_red character(len=:), public, allocatable :: bright_green character(len=:), public, allocatable :: bright_yellow character(len=:), public, allocatable :: bright_blue character(len=:), public, allocatable :: bright_magenta character(len=:), public, allocatable :: bright_cyan character(len=:), public, allocatable :: bright_white Type-Bound Procedures procedure, public :: init => init_colors_ascii interface private module subroutine init_colors_ascii(this) Arguments Type Intent Optional Attributes Name class( ColorsAscii ), intent(out) :: this Source Code type :: ColorsAscii character ( len = :), allocatable :: & reset , bold , faint , italic , underline , blink , reverse , hidden , strikethrough , & red , green , yellow , blue , magenta , cyan , white , & bright_red , bright_green , bright_yellow , bright_blue , bright_magenta , bright_cyan , & bright_white contains procedure :: init => init_colors_ascii end type ColorsAscii","tags":"","url":"type\\colorsascii.html"},{"title":"ColorsUcs4 – NAFPack ","text":"type, public :: ColorsUcs4 Components Type Visibility Attributes Name Initial character(kind=ucs4, len=:), public, allocatable :: reset character(kind=ucs4, len=:), public, allocatable :: bold character(kind=ucs4, len=:), public, allocatable :: faint character(kind=ucs4, len=:), public, allocatable :: italic character(kind=ucs4, len=:), public, allocatable :: underline character(kind=ucs4, len=:), public, allocatable :: blink character(kind=ucs4, len=:), public, allocatable :: reverse character(kind=ucs4, len=:), public, allocatable :: hidden character(kind=ucs4, len=:), public, allocatable :: strikethrough character(kind=ucs4, len=:), public, allocatable :: red character(kind=ucs4, len=:), public, allocatable :: green character(kind=ucs4, len=:), public, allocatable :: yellow character(kind=ucs4, len=:), public, allocatable :: blue character(kind=ucs4, len=:), public, allocatable :: magenta character(kind=ucs4, len=:), public, allocatable :: cyan character(kind=ucs4, len=:), public, allocatable :: white character(kind=ucs4, len=:), public, allocatable :: bright_red character(kind=ucs4, len=:), public, allocatable :: bright_green character(kind=ucs4, len=:), public, allocatable :: bright_yellow character(kind=ucs4, len=:), public, allocatable :: bright_blue character(kind=ucs4, len=:), public, allocatable :: bright_magenta character(kind=ucs4, len=:), public, allocatable :: bright_cyan character(kind=ucs4, len=:), public, allocatable :: bright_white Type-Bound Procedures procedure, public :: init => init_colors_ucs4 interface private module subroutine init_colors_ucs4(this) Arguments Type Intent Optional Attributes Name class( ColorsUcs4 ), intent(out) :: this Source Code type :: ColorsUcs4 character ( len = :, kind = ucs4 ), allocatable :: & reset , bold , faint , italic , underline , blink , reverse , hidden , strikethrough , & red , green , yellow , blue , magenta , cyan , white , & bright_red , bright_green , bright_yellow , bright_blue , bright_magenta , bright_cyan , & bright_white contains procedure :: init => init_colors_ucs4 end type ColorsUcs4","tags":"","url":"type\\colorsucs4.html"},{"title":"LoopMethod – NAFPack ","text":"type, public :: LoopMethod Inherits type~~loopmethod~~InheritsGraph type~loopmethod LoopMethod type~parallelmethod ParallelMethod type~loopmethod->type~parallelmethod parallel Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: use_do_classic = .false. logical, public :: use_vectorized = .false. logical, public :: use_do_concurrent = .false. type(ParallelMethod), public :: parallel Source Code type :: LoopMethod logical :: use_do_classic = . false . logical :: use_vectorized = . false . logical :: use_do_concurrent = . false . type ( ParallelMethod ) :: parallel end type LoopMethod","tags":"","url":"type\\loopmethod.html"},{"title":"MethodPreconditioner – NAFPack ","text":"type, public :: MethodPreconditioner Inherited by type~~methodpreconditioner~~InheritedByGraph type~methodpreconditioner MethodPreconditioner type~iterativemethod IterativeMethod type~iterativemethod->type~methodpreconditioner preconditioner_type type~linalg linalg type~linalg->type~iterativemethod iterative Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name Source Code type :: MethodPreconditioner integer :: id character ( LEN = 64 ) :: name end type MethodPreconditioner","tags":"","url":"type\\methodpreconditioner.html"},{"title":"Fill_level_used – NAFPack ","text":"type, public :: Fill_level_used Inherited by type~~fill_level_used~~InheritedByGraph type~fill_level_used Fill_level_used type~iterativeparams IterativeParams type~iterativeparams->type~fill_level_used fill_level Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name integer, public :: value Source Code type :: Fill_level_used integer :: id character ( LEN = 64 ) :: name integer :: value end type Fill_level_used","tags":"","url":"type\\fill_level_used.html"},{"title":"IterativeParams – NAFPack ","text":"type, public :: IterativeParams Inherits type~~iterativeparams~~InheritsGraph type~iterativeparams IterativeParams type~fill_level_used Fill_level_used type~iterativeparams->type~fill_level_used fill_level type~norm_used Norm_used type~iterativeparams->type~norm_used norm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(:), allocatable :: x_init real(kind=dp), public, dimension(:, :), allocatable :: L real(kind=dp), public, dimension(:, :), allocatable :: U real(kind=dp), public, dimension(:, :), allocatable :: D real(kind=dp), public, dimension(:), allocatable :: p real(kind=dp), public, dimension(:), allocatable :: residual real(kind=dp), public :: norm_residual real(kind=dp), public :: norm_initial_residual = 1.d0 real(kind=dp), public :: tol = 1.0d-12 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: omega = 1.d0 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 type( Fill_level_used ), public :: fill_level = FILL_LEVEL_NONE logical, public :: is_stationary = .true. logical, public :: strict_mode = .false. real(kind=dp), public :: old_dot_product = 0.d0 type( Norm_used ), public :: norm = NORM_2 procedure( ApplyPreconditioner ), public, pass(params), pointer :: precond Type-Bound Procedures procedure, public :: norm_function private  function norm_function(this, vector) result(result) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: this real(kind=dp), intent(in), dimension(:) :: vector Return Value real(kind=dp) Source Code type :: IterativeParams ! Solution and initial guess real ( dp ), dimension (:), allocatable :: x_init ! Preconditioner matrices real ( dp ), dimension (:, :), allocatable :: L , U , D ! Algorithm vectors real ( dp ), dimension (:), allocatable :: p real ( dp ), dimension (:), allocatable :: residual ! Norms and tolerances real ( dp ) :: norm_residual real ( dp ) :: norm_initial_residual = 1.d0 real ( dp ) :: tol = 1.0d-12 ! Iteration control integer :: k = 0 integer :: max_iter = 1000 ! Method parameters real ( dp ) :: omega = 1.d0 real ( dp ) :: alpha = 1.d0 real ( dp ) :: beta = 1.d0 ! ILU/IC fill level type ( FILL_LEVEL_USED ) :: fill_level = FILL_LEVEL_NONE ! Flags logical :: is_stationary = . true . logical :: strict_mode = . false . ! Miscellaneous real ( dp ) :: old_dot_product = 0.d0 type ( Norm_used ) :: norm = NORM_2 ! Preconditioner procedure pointer procedure ( ApplyPreconditioner ), pass ( params ), pointer :: precond contains procedure :: norm_function end type IterativeParams","tags":"","url":"type\\iterativeparams.html"},{"title":"get_memory_kb – NAFPack","text":"public  function get_memory_kb() result(memory_kb) Arguments None Return Value integer Source Code function get_memory_kb () result ( memory_kb ) integer :: memory_kb memory_kb = get_memory_usage () end function get_memory_kb","tags":"","url":"proc\\get_memory_kb.html"},{"title":"sieve_of_eratosthenes – NAFPack","text":"public pure function sieve_of_eratosthenes(N) result(primes) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N Return Value integer(kind=isp), dimension(:), allocatable Source Code pure function sieve_of_eratosthenes ( N ) result ( primes ) integer ( isp ), intent ( in ) :: N integer ( isp ), dimension (:), allocatable :: primes logical , dimension (:), allocatable :: is_prime integer ( isp ) :: i , j , count_primes , limit , idx allocate ( is_prime ( 0 : N )) is_prime = . true . is_prime ( 0 : 1 ) = . false . limit = int ( sqrt ( real ( N , kind = sp ))) do i = 2 , limit if ( is_prime ( i )) then do j = i * i , N , i is_prime ( j ) = . false . end do end if end do count_primes = count ( is_prime ) allocate ( primes ( count_primes )) idx = 1 do i = 2 , N if ( is_prime ( i )) then primes ( idx ) = i idx = idx + 1 end if end do deallocate ( is_prime ) end function sieve_of_eratosthenes","tags":"","url":"proc\\sieve_of_eratosthenes.html"},{"title":"is_power_of_two – NAFPack","text":"public pure function is_power_of_two(N) result(value) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N Return Value logical Source Code pure function is_power_of_two ( N ) result ( value ) integer ( isp ), intent ( in ) :: N logical :: value if ( N < 1 ) then value = . false . else value = ( iand ( N , N - 1 ) == 0 ) end if end function is_power_of_two","tags":"","url":"proc\\is_power_of_two.html"},{"title":"power_of_p_exponent – NAFPack","text":"public pure function power_of_p_exponent(N, p) result(exponent) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N integer(kind=isp), intent(in) :: p Return Value integer(kind=isp) Source Code pure function power_of_p_exponent ( N , p ) result ( exponent ) integer ( isp ), intent ( in ) :: N , p integer ( isp ) :: exponent integer ( isp ) :: tmp exponent = 0 tmp = N do while ( tmp > 1 ) tmp = tmp / p exponent = exponent + 1 end do end function power_of_p_exponent","tags":"","url":"proc\\power_of_p_exponent.html"},{"title":"dot – NAFPack","text":"public  function dot(a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp) Source Code function dot ( a , b ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a , b real ( dp ) :: result integer :: i if ( size ( a ) /= size ( b )) stop \"Error: Vectors must be of the same size.\" result = 0.0_dp do i = 1 , size ( a ) result = result + a ( i ) * b ( i ) end do end function dot","tags":"","url":"proc\\dot.html"},{"title":"cross – NAFPack","text":"public  function cross(a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 the wedge notation can sometimes be used to denote the vector product. ↩ Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: a real(kind=dp), intent(in), dimension(3) :: b Return Value real(kind=dp), dimension(3) Source Code function cross ( a , b ) result ( result ) real ( dp ), dimension ( 3 ), intent ( in ) :: a , b real ( dp ), dimension ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function cross","tags":"","url":"proc\\cross.html"},{"title":"norm_2_real – NAFPack","text":"public  function norm_2_real(a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_real~~CalledByGraph proc~norm_2_real norm_2_real proc~normalise normalise proc~normalise->proc~norm_2_real proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function norm_2_real ( a ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a real ( dp ) :: result result = sqrt ( dot_product ( a , a )) end function norm_2_real","tags":"","url":"proc\\norm_2_real.html"},{"title":"norm_2_complex – NAFPack","text":"public  function norm_2_complex(a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp) Called by proc~~norm_2_complex~~CalledByGraph proc~norm_2_complex norm_2_complex proc~normalise_complexe normalise_complexe proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function norm_2_complex ( a ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: a real ( dp ) :: result result = sqrt ( real ( dot_product ( a , conjg ( a )))) end function norm_2_complex","tags":"","url":"proc\\norm_2_complex.html"},{"title":"normalise – NAFPack","text":"public  function normalise(a) result(result) function that normalises a real vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp), dimension(size(a)) Calls proc~~normalise~~CallsGraph proc~normalise normalise proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~normalise~~CalledByGraph proc~normalise normalise proc~eigen Eigen proc~eigen->proc~normalise proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function normalise ( a ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a real ( dp ), dimension ( size ( a )) :: result result = a / norm_2_real ( a ) end function normalise","tags":"","url":"proc\\normalise.html"},{"title":"normalise_complexe – NAFPack","text":"public  function normalise_complexe(a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: a Return Value complex(kind=dp), dimension(size(a)) Calls proc~~normalise_complexe~~CallsGraph proc~normalise_complexe normalise_complexe proc~norm_2_complex norm_2_complex proc~normalise_complexe->proc~norm_2_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function normalise_complexe ( a ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: a complex ( dp ), dimension ( size ( a )) :: result result = a / norm_2_complex ( a ) end function normalise_complexe","tags":"","url":"proc\\normalise_complexe.html"},{"title":"Trace – NAFPack","text":"public  function Trace(A) result(result) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp) Called by proc~~trace~~CalledByGraph proc~trace Trace proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Trace ( A ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ) :: result integer :: i , N N = size ( A , 1 ) if ( size ( A , 2 ) /= N ) stop \"Error: Matrix must be square.\" result = sum ([( A ( i , i ), i = 1 , N )]) end function Trace","tags":"","url":"proc\\trace.html"},{"title":"Diagonally_Dominant_Matrix – NAFPack","text":"public  function Diagonally_Dominant_Matrix(A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Source Code function Diagonally_Dominant_Matrix ( A ) result ( diagonally_dominant ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: diagonally_dominant real ( dp ) :: summation integer :: i , N N = size ( A , 1 ) diagonally_dominant = . true . do i = 1 , N summation = sum ( abs ( A ( i , :) - A ( i , i ))) if ( abs ( A ( i , i )) < summation ) then diagonally_dominant = . false . exit end if end do end function Diagonally_Dominant_Matrix","tags":"","url":"proc\\diagonally_dominant_matrix.html"},{"title":"Identity_n – NAFPack","text":"public  function Identity_n(N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), dimension(N, N) Called by proc~~identity_n~~CalledByGraph proc~identity_n Identity_n proc~eigen Eigen proc~eigen->proc~identity_n proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~faddeev_leverrier Faddeev_Leverrier proc~faddeev_leverrier->proc~identity_n proc~is_orthogonal is_orthogonal proc~is_orthogonal->proc~identity_n proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~ldl_cholesky_decomposition->proc~identity_n proc~pivot_partial pivot_partial proc~pivot_partial->proc~identity_n proc~pivot_total pivot_total proc~pivot_total->proc~identity_n proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n proc~is_spd is_SPD proc~is_spd->proc~eigen proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_decomposition->proc~qr_householder_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Identity_n ( N , use_concurrent ) result ( Identity ) integer , intent ( in ) :: N logical , intent ( in ), optional :: use_concurrent real ( dp ), dimension ( N , N ) :: Identity integer :: i logical :: concurrent_mode concurrent_mode = . false . if ( present ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 if ( concurrent_mode ) then do concurrent ( i = 1 : N ) Identity ( i , i ) = 1.0_dp end do else forall ( i = 1 : N ) Identity ( i , i ) = 1.0_dp end if end function Identity_n","tags":"","url":"proc\\identity_n.html"},{"title":"Diag – NAFPack","text":"public  function Diag(A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1)) Called by proc~~diag~~CalledByGraph proc~diag Diag proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~calculate_gauss_seidel_preconditioner->proc~diag proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~calculate_jacobi_preconditioner->proc~diag proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~calculate_jor_preconditioner->proc~diag proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~calculate_sor_preconditioner->proc~diag proc~is_non_zero_diagonal is_non_zero_diagonal proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Diag ( A ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 )) :: D integer :: i , N N = size ( A , 1 ) forall ( i = 1 : N ) D ( i ) = A ( i , i ) end function Diag","tags":"","url":"proc\\diag.html"},{"title":"Make_Tridiagonal – NAFPack","text":"public  function Make_Tridiagonal(d_minus, d, d_plus) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: d_minus real(kind=dp), intent(in), dimension(:) :: d real(kind=dp), intent(in), dimension(:) :: d_plus Return Value real(kind=dp), dimension(size(d, 1), size(d, 1)) Source Code function Make_Tridiagonal ( d_minus , d , d_plus ) result ( T ) real ( dp ), dimension (:), intent ( in ) :: d_minus , d , d_plus real ( dp ), dimension ( size ( d , 1 ), size ( d , 1 )) :: T integer :: i , N N = size ( d , 1 ) T = 0.d0 do i = 1 , N T ( i , i ) = d ( i ) if ( i > 1 ) T ( i , i - 1 ) = d_minus ( i ) if ( i < N ) T ( i , i + 1 ) = d_plus ( i ) end do end function Make_Tridiagonal","tags":"","url":"proc\\make_tridiagonal.html"},{"title":"rotation_matrix – NAFPack","text":"public  function rotation_matrix(A, rotation) result(G) Function to create a rotation matrix This function generates a rotation matrix G based on the input matrix A and the specified rotation indices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), dimension(2) :: rotation Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~rotation_matrix~~CallsGraph proc~rotation_matrix rotation_matrix proc~identity_n Identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation_matrix~~CalledByGraph proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function rotation_matrix ( A , rotation ) result ( G ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , dimension ( 2 ), intent ( in ) :: rotation real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: G real ( dp ) :: frac , val_1 , val_2 integer :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( size ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = sqrt ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac end function rotation_matrix","tags":"","url":"proc\\rotation_matrix.html"},{"title":"is_square_matrix – NAFPack","text":"public  function is_square_matrix(A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Source Code function is_square_matrix ( A ) result ( is_square ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_square is_square = ( size ( A , 1 ) == size ( A , 2 )) end function is_square_matrix","tags":"","url":"proc\\is_square_matrix.html"},{"title":"is_symmetric – NAFPack","text":"public  function is_symmetric(A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Called by proc~~is_symmetric~~CalledByGraph proc~is_symmetric is_symmetric proc~is_spd is_SPD proc~is_spd->proc~is_symmetric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function is_symmetric ( A ) result ( is_sym ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_sym is_sym = all ( A == transpose ( A )) end function is_symmetric","tags":"","url":"proc\\is_symmetric.html"},{"title":"is_orthogonal – NAFPack","text":"public  function is_orthogonal(A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Calls proc~~is_orthogonal~~CallsGraph proc~is_orthogonal is_orthogonal proc~identity_n Identity_n proc~is_orthogonal->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function is_orthogonal ( A ) result ( is_orth ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_orth is_orth = all ( abs ( matmul ( A , transpose ( A )) - Identity_n ( size ( A , 1 ))) < TOL_TEST_dp ) end function is_orthogonal","tags":"","url":"proc\\is_orthogonal.html"},{"title":"is_SPD – NAFPack","text":"public  function is_SPD(A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical Calls proc~~is_spd~~CallsGraph proc~is_spd is_SPD proc~eigen Eigen proc~is_spd->proc~eigen proc~is_symmetric is_symmetric proc~is_spd->proc~is_symmetric proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function is_SPD ( A , is_sym ) result ( is_spd_matrix ) real ( dp ), dimension (:, :), intent ( in ) :: A logical , optional , intent ( in ) :: is_sym real ( dp ), dimension ( size ( A , 1 )) :: lambda logical :: is_spd_matrix if ( present ( is_sym )) then if (. not . is_sym ) then is_spd_matrix = . false . return end if else if (. not . is_symmetric ( A )) then is_spd_matrix = . false . return end if call Eigen ( A , lambda , method = \"Power_iteration\" ) if ( minval ( lambda ) < 0 ) then is_spd_matrix = . false . else is_spd_matrix = . true . end if end function is_SPD","tags":"","url":"proc\\is_spd.html"},{"title":"is_tridiagonal – NAFPack","text":"public  function is_tridiagonal(A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Source Code function is_tridiagonal ( A ) result ( is_tridiag ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_tridiag integer :: i , j , N N = size ( A , 1 ) is_tridiag = . true . do i = 1 , N do j = 1 , N if ( abs ( i - j ) > 1 ) then if ( abs ( A ( i , j )) > TOL_TEST_dp ) then is_tridiag = . false . return end if end if end do end do end function is_tridiagonal","tags":"","url":"proc\\is_tridiagonal.html"},{"title":"is_diagonally_dominant – NAFPack","text":"public  function is_diagonally_dominant(A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Source Code function is_diagonally_dominant ( A ) result ( is_diag_dom ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_diag_dom integer :: i , N real ( dp ) :: row_sum N = size ( A , 1 ) is_diag_dom = . true . do i = 1 , N row_sum = sum ( abs ( A ( i , :))) - abs ( A ( i , i )) if ( abs ( A ( i , i )) < row_sum ) then is_diag_dom = . false . return end if end do end function is_diagonally_dominant","tags":"","url":"proc\\is_diagonally_dominant.html"},{"title":"is_non_zero_diagonal – NAFPack","text":"public  function is_non_zero_diagonal(A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical Calls proc~~is_non_zero_diagonal~~CallsGraph proc~is_non_zero_diagonal is_non_zero_diagonal proc~diag Diag proc~is_non_zero_diagonal->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function is_non_zero_diagonal ( A ) result ( is_non_zero_diag ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_non_zero_diag is_non_zero_diag = . true . if ( any ( abs ( Diag ( A )) < TOL_TEST_dp )) is_non_zero_diag = . false . end function is_non_zero_diagonal","tags":"","url":"proc\\is_non_zero_diagonal.html"},{"title":"to_str_ascii – NAFPack","text":"public interface to_str_ascii Module Procedures private pure function int8_to_str_ascii(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: value Return Value character(kind=ascii, len=:), allocatable private pure function int16_to_str_ascii(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: value Return Value character(kind=ascii, len=:), allocatable","tags":"","url":"interface\\to_str_ascii.html"},{"title":"to_str_ucs4 – NAFPack","text":"public interface to_str_ucs4 Module Procedures private pure function int8_to_str_ucs4(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: value Return Value character(kind=ucs4, len=:), allocatable private pure function int16_to_str_ucs4(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: value Return Value character(kind=ucs4, len=:), allocatable","tags":"","url":"interface\\to_str_ucs4.html"},{"title":"print_colored_message – NAFPack","text":"public interface print_colored_message Module Procedures private  subroutine print_colored_message_ucs4(color, message) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: color character(kind=ucs4, len=*), intent(in) :: message private  subroutine print_colored_message_ascii(color, message) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: color character(kind=ascii, len=*), intent(in) :: message","tags":"","url":"interface\\print_colored_message.html"},{"title":"FFT_1D – NAFPack","text":"public  function FFT_1D(signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_DFT\": Direct Discrete Fourier Transform \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal)) Calls proc~~fft_1d~~CallsGraph proc~fft_1d FFT_1D fftw_cleanup fftw_cleanup proc~fft_1d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~fft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~fft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function FFT_1D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal )) :: result if ( method == \"NAFPack_DFT\" ) then result = NAFPack_DFT_1D ( signal ) else if ( method == \"NAFPack_FFT_1D\" ) then result = NAFPack_FFT_1D ( signal ) else if ( method == \"FFTW_FFT_1D\" . and . . not . present ( threads )) then result = FFTW_FFT_1D ( signal ) else if ( method == \"FFTW_FFT_1D\" . and . present ( threads )) then result = FFTW_FFT_1D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_1D\" end if end function FFT_1D","tags":"","url":"proc\\fft_1d.html"},{"title":"IFFT_1D – NAFPack","text":"public  function IFFT_1D(signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal)) Calls proc~~ifft_1d~~CallsGraph proc~ifft_1d IFFT_1D fftw_cleanup fftw_cleanup proc~ifft_1d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~ifft_1d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_1d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_1d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_1d->fftw_init_threads fftw_plan_dft_1d fftw_plan_dft_1d proc~ifft_1d->fftw_plan_dft_1d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_1d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function IFFT_1D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal )) :: result if ( method == \"NAFPack_IFFT_1D\" ) then result = NAFPack_IFFT_1D ( signal ) else if ( method == \"FFTW_IFFT_1D\" . and . . not . present ( threads )) then result = FFTW_IFFT_1D ( signal ) else if ( method == \"FFTW_IFFT_1D\" . and . present ( threads )) then result = FFTW_IFFT_1D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_1D","tags":"","url":"proc\\ifft_1d.html"},{"title":"FFT_2D – NAFPack","text":"public  function FFT_2D(signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2)) Calls proc~~fft_2d~~CallsGraph proc~fft_2d FFT_2D fftw_cleanup fftw_cleanup proc~fft_2d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~fft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~fft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function FFT_2D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result if ( method == \"NAFPack_FFT_2D\" ) then result = NAFPack_FFT_2D ( signal ) else if ( method == \"FFTW_FFT_2D\" . and . . not . present ( threads )) then result = FFTW_FFT_2D ( signal ) else if ( method == \"FFTW_FFT_2D\" . and . present ( threads )) then result = FFTW_FFT_2D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_2D\" end if end function FFT_2D","tags":"","url":"proc\\fft_2d.html"},{"title":"IFFT_2D – NAFPack","text":"public  function IFFT_2D(signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2)) Calls proc~~ifft_2d~~CallsGraph proc~ifft_2d IFFT_2D fftw_cleanup fftw_cleanup proc~ifft_2d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~ifft_2d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_2d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_2d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_2d->fftw_init_threads fftw_plan_dft_2d fftw_plan_dft_2d proc~ifft_2d->fftw_plan_dft_2d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_2d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function IFFT_2D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result if ( method == \"NAFPack_IFFT_2D\" ) then result = NAFPack_IFFT_2D ( signal ) else if ( method == \"FFTW_IFFT_2D\" . and . . not . present ( threads )) then result = FFTW_IFFT_2D ( signal ) else if ( method == \"FFTW_IFFT_2D\" . and . present ( threads )) then result = FFTW_IFFT_2D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_2D","tags":"","url":"proc\\ifft_2d.html"},{"title":"FFT_3D – NAFPack","text":"public  function FFT_3D(signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal This function takes a signal and performs a Fourier Transform using the specified method.\nThe available methods are: \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2), size(signal, 3)) Calls proc~~fft_3d~~CallsGraph proc~fft_3d FFT_3D fftw_cleanup fftw_cleanup proc~fft_3d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~fft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~fft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~fft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~fft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~fft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~fft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function FFT_3D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: result if ( method == \"FFTW_FFT_3D\" . and . . not . present ( threads )) then result = FFTW_FFT_3D ( signal ) else if ( method == \"FFTW_FFT_3D\" . and . present ( threads )) then result = FFTW_FFT_3D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_2D\" end if end function FFT_3D","tags":"","url":"proc\\fft_3d.html"},{"title":"IFFT_3D – NAFPack","text":"public  function IFFT_3D(signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal This function takes a signal and performs a  inverse fast Fourier Transform using the specified method.\nThe available methods are: \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2), size(signal, 3)) Calls proc~~ifft_3d~~CallsGraph proc~ifft_3d IFFT_3D fftw_cleanup fftw_cleanup proc~ifft_3d->fftw_cleanup fftw_cleanup_threads fftw_cleanup_threads proc~ifft_3d->fftw_cleanup_threads fftw_destroy_plan fftw_destroy_plan proc~ifft_3d->fftw_destroy_plan fftw_execute_dft fftw_execute_dft proc~ifft_3d->fftw_execute_dft fftw_init_threads fftw_init_threads proc~ifft_3d->fftw_init_threads fftw_plan_dft_3d fftw_plan_dft_3d proc~ifft_3d->fftw_plan_dft_3d fftw_plan_with_nthreads fftw_plan_with_nthreads proc~ifft_3d->fftw_plan_with_nthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function IFFT_3D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: result if ( method == \"FFTW_IFFT_3D\" . and . . not . present ( threads )) then result = FFTW_IFFT_3D ( signal ) else if ( method == \"IFFTW_IFFT_3D\" . and . present ( threads )) then result = FFTW_IFFT_3D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_3D","tags":"","url":"proc\\ifft_3d.html"},{"title":"dft – NAFPack","text":"public interface dft Module Procedures private  interface dft_cmplx_sp() Arguments None private  interface dft_cmplx_dp() Arguments None private  interface dft_cmplx_qp() Arguments None private  interface dft_real_sp() Arguments None private  interface dft_real_dp() Arguments None private  interface dft_real_qp() Arguments None","tags":"","url":"interface\\dft.html"},{"title":"idft – NAFPack","text":"public interface idft Module Procedures private  interface idft_cmplx_sp() Arguments None private  interface idft_cmplx_dp() Arguments None private  interface idft_cmplx_qp() Arguments None private  interface idft_real_sp() Arguments None private  interface idft_real_dp() Arguments None private  interface idft_real_qp() Arguments None","tags":"","url":"interface\\idft.html"},{"title":"dft2 – NAFPack","text":"public interface dft2 Module Procedures private  interface dft2_cmplx_sp() Arguments None private  interface dft2_cmplx_dp() Arguments None private  interface dft2_cmplx_qp() Arguments None private  interface dft2_real_sp() Arguments None private  interface dft2_real_dp() Arguments None private  interface dft2_real_qp() Arguments None","tags":"","url":"interface\\dft2.html"},{"title":"idft2 – NAFPack","text":"public interface idft2 Module Procedures private  interface idft2_cmplx_sp() Arguments None private  interface idft2_cmplx_dp() Arguments None private  interface idft2_cmplx_qp() Arguments None private  interface idft2_real_sp() Arguments None private  interface idft2_real_dp() Arguments None private  interface idft2_real_qp() Arguments None","tags":"","url":"interface\\idft2.html"},{"title":"dft3 – NAFPack","text":"public interface dft3 Module Procedures private  interface dft3_cmplx_sp() Arguments None private  interface dft3_cmplx_dp() Arguments None private  interface dft3_cmplx_qp() Arguments None private  interface dft3_real_sp() Arguments None private  interface dft3_real_dp() Arguments None private  interface dft3_real_qp() Arguments None","tags":"","url":"interface\\dft3.html"},{"title":"idft3 – NAFPack","text":"public interface idft3 Module Procedures private  interface idft3_cmplx_sp() Arguments None private  interface idft3_cmplx_dp() Arguments None private  interface idft3_cmplx_qp() Arguments None private  interface idft3_real_sp() Arguments None private  interface idft3_real_dp() Arguments None private  interface idft3_real_qp() Arguments None","tags":"","url":"interface\\idft3.html"},{"title":"readMatrixMarket – NAFPack","text":"public  subroutine readMatrixMarket(filename, A) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: A Source Code subroutine readMatrixMarket ( filename , A ) character ( LEN =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), allocatable , intent ( out ) :: A integer :: i , j , nrows , ncols , nnz , ios , k , row_idx , col_idx character ( LEN = 256 ) :: line , header character ( LEN = 50 ) :: object , format_type , field , symmetry integer :: unit real ( dp ) :: val unit = 10 ! Open the file open ( NEWUNIT = unit , FILE = filename , STATUS = 'old' , ACTION = 'read' , IOSTAT = ios ) if ( ios /= 0 ) then print * , 'Error: opening file: ' , filename stop end if ! read the header read ( unit , '(A)' , IOSTAT = ios ) header if ( ios /= 0 ) then print * , 'Error: reading header Matrix Market' close ( unit ) stop end if ! Check Matrix Market format if ( index ( header , '%%MatrixMarket' ) == 0 ) then print * , 'Error: file is not in Matrix Market format' close ( unit ) return end if ! Parse the header to extract information read ( header , * , iostat = ios ) object , object , format_type , field , symmetry if ( ios /= 0 ) then print * , 'Error reading Matrix Market header' close ( unit ) stop end if ! Skip comment lines and find the size line do read ( unit , '(A)' , IOSTAT = ios ) line if ( ios /= 0 ) then print * , 'Error: malformed file' close ( unit ) stop end if if ( line ( 1 : 1 ) /= '%' ) then exit end if end do ! Read matrix dimensions read ( line , * , iostat = ios ) nrows , ncols , nnz if ( ios /= 0 ) then print * , 'Error: unable to read dimensions' close ( unit ) return end if allocate ( A ( nrows , ncols )) A = 0.0_dp ! Read matrix entries if ( trim ( format_type ) == 'coordinate' ) then ! Coordinate format (sparse) do k = 1 , nnz read ( unit , * , iostat = ios ) row_idx , col_idx , val if ( ios /= 0 ) then print * , 'Error: reading entry' , k exit end if A ( row_idx , col_idx ) = val ! If the matrix is symmetric, also fill A(j,i) if ( trim ( symmetry ) == 'symmetric' . and . row_idx /= col_idx ) then A ( col_idx , row_idx ) = val end if end do else if ( trim ( format_type ) == 'array' ) then ! Dense format (array) do j = 1 , ncols do i = 1 , nrows read ( unit , * , iostat = ios ) val if ( ios /= 0 ) then print * , 'Error: reading element (' , i , ',' , j , ')' close ( unit ) return end if A ( i , j ) = val end do end do else print * , 'Error: unsupported format: ' , trim ( format_type ) close ( unit ) return end if close ( unit ) end subroutine readMatrixMarket","tags":"","url":"proc\\readmatrixmarket.html"},{"title":"forward – NAFPack","text":"public  function forward(L, b) result(y) forward algorithm,\nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: L real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp), dimension(size(L, 1)) Called by proc~~forward~~CalledByGraph proc~forward forward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function forward ( L , b ) result ( y ) real ( dp ), dimension (:, :), intent ( in ) :: L real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( L , 1 )) :: y integer :: i , N N = size ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) do i = 2 , N y ( i ) = ( b ( i ) - dot_product ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) end do end function forward","tags":"","url":"proc\\forward.html"},{"title":"backward – NAFPack","text":"public  function backward(U, y) result(x) backward algorithm,\nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: U real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp), dimension(size(U, 1)) Called by proc~~backward~~CalledByGraph proc~backward backward proc~applypreconditioner ApplyPreconditioner proc~applypreconditioner->proc~backward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function backward ( U , y ) result ( x ) real ( dp ), dimension (:, :), intent ( in ) :: U real ( dp ), dimension (:), intent ( in ) :: y real ( dp ), dimension ( size ( U , 1 )) :: x integer :: i , N N = size ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) do i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - dot_product ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) end do end function backward","tags":"","url":"proc\\backward.html"},{"title":"LU_decomposition – NAFPack","text":"public  subroutine LU_decomposition(A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U Source Code subroutine LU_decomposition ( A , L , U ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U integer :: i , j , N N = size ( A , 1 ) L = 0.d0 U = 0.d0 do j = 1 , N L ( j , j ) = 1.d0 do i = 1 , j U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) end do do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) end do end do end subroutine LU_decomposition","tags":"","url":"proc\\lu_decomposition.html"},{"title":"LDU_decomposition – NAFPack","text":"public  subroutine LDU_decomposition(A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: D real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U Source Code subroutine LDU_decomposition ( A , L , D , U ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U , D integer :: i , j , k , N N = size ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 do j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 do i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [( D ( k , k ), k = 1 , i - 1 )])) / & D ( i , i ) end do i = j D ( j , j ) = A ( j , j ) - & dot_product ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )]) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )])) / & D ( j , j ) end do end do end subroutine LDU_decomposition","tags":"","url":"proc\\ldu_decomposition.html"},{"title":"ILU_decomposition – NAFPack","text":"public  subroutine ILU_decomposition(A, L, U, level) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U integer, intent(in), optional :: level Called by proc~~ilu_decomposition~~CalledByGraph proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~calculate_ilu_preconditioner->proc~ilu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ILU_decomposition ( A , L , U , level ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U integer , optional , intent ( in ) :: level integer :: N , i , j integer , dimension ( size ( A , 1 ), size ( A , 1 )) :: fill_level logical , dimension ( size ( A , 1 ), size ( A , 1 )) :: S N = size ( A , 1 ) L = 0.d0 U = 0.d0 if ( present ( level )) then call compute_fill_pattern_ILU ( A , fill_level , level , N ) S = ( fill_level <= level ) else S = A /= 0 end if do j = 1 , N L ( j , j ) = 1.d0 do i = 1 , j if ( S ( i , j )) U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) end do if ( abs ( U ( j , j )) < 1.0e-12_dp ) then print * , \"Warning: Near-zero pivot at row \" , j , \", value =\" , U ( j , j ) print * , \"Replacing with small value, value =\" , sign ( 1.0e-12_dp , U ( j , j )) U ( j , j ) = sign ( 1.0e-12_dp , U ( j , j )) end if do i = j + 1 , N if ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / & U ( j , j ) end do end do end subroutine ILU_decomposition","tags":"","url":"proc\\ilu_decomposition.html"},{"title":"Cholesky_decomposition – NAFPack","text":"public  subroutine Cholesky_decomposition(A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L Source Code subroutine Cholesky_decomposition ( A , L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L integer :: i , j , N N = size ( A , 1 ) do j = 1 , N L ( j , j ) = sqrt ( A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) end do end do end subroutine Cholesky_decomposition","tags":"","url":"proc\\cholesky_decomposition.html"},{"title":"LDL_Cholesky_decomposition – NAFPack","text":"public  subroutine LDL_Cholesky_decomposition(A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: D Calls proc~~ldl_cholesky_decomposition~~CallsGraph proc~ldl_cholesky_decomposition LDL_Cholesky_decomposition proc~identity_n Identity_n proc~ldl_cholesky_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine LDL_Cholesky_decomposition ( A , L , D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , D integer :: i , j , N , k N = size ( A , 1 ) L = Identity_n ( N ) D = 0.d0 do j = 1 , N D ( j , j ) = A ( j , j ) - & dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )]) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )])) / & D ( j , j ) end do end do end subroutine LDL_Cholesky_decomposition","tags":"","url":"proc\\ldl_cholesky_decomposition.html"},{"title":"Incomplete_Cholesky_decomposition – NAFPack","text":"public  subroutine Incomplete_Cholesky_decomposition(A, L, level) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L integer, intent(in), optional :: level Called by proc~~incomplete_cholesky_decomposition~~CalledByGraph proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Incomplete_Cholesky_decomposition ( A , L , level ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , optional , intent ( in ) :: level real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L logical , dimension ( size ( A , 1 ), size ( A , 1 )) :: S integer :: N , i , j integer , dimension ( size ( A , 1 ), size ( A , 1 )) :: fill_level N = size ( A , 1 ) L = 0.d0 if ( present ( level )) then call compute_fill_pattern_IC ( A , fill_level , level , N ) S = ( fill_level <= level ) else S = A /= 0 end if do i = 1 , N do j = 1 , i - 1 if ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / & L ( j , j ) end do if ( S ( i , i )) L ( i , i ) = sqrt ( A ( i , i ) - & dot_product ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) end do end subroutine Incomplete_Cholesky_decomposition","tags":"","url":"proc\\incomplete_cholesky_decomposition.html"},{"title":"QR_decomposition – NAFPack","text":"public  subroutine QR_decomposition(A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R Calls proc~~qr_decomposition~~CallsGraph proc~qr_decomposition QR_decomposition proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_decomposition~~CalledByGraph proc~qr_decomposition QR_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine QR_decomposition ( A , method , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A character ( LEN =* ), optional , intent ( in ) :: method real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R if ( method == \"QR_Householder\" ) then call QR_Householder_decomposition ( A , Q , R ) else if ( method == \"QR_Givens\" ) then call QR_Givens_decomposition ( A , Q , R ) else if ( method == \"QR_Gram_Schmidt_Classical\" ) then call QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) else if ( method == \"QR_Gram_Schmidt_Modified\" ) then call QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) end if end subroutine QR_decomposition","tags":"","url":"proc\\qr_decomposition.html"},{"title":"QR_Householder_decomposition – NAFPack","text":"public  subroutine QR_Householder_decomposition(A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R Calls proc~~qr_householder_decomposition~~CallsGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~identity_n Identity_n proc~qr_householder_decomposition->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_householder_decomposition~~CalledByGraph proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine QR_Householder_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: Id , H , v_mat_tmp real ( dp ), dimension ( size ( A , 1 )) :: v , u , x integer :: N , i , j , k real ( dp ) :: alpha , w , signe , norm_u N = size ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) do k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = norm2 ( R ( k : N , k )) signe = - sign ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = norm2 ( u ) if ( norm_u < TOL_CONVERGENCE_dp ) cycle v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 do i = k , N do j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) end do end do H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = matmul ( Q , H ) R ( k : N , k : N ) = matmul ( H ( k : N , k : N ), R ( k : N , k : N )) end do end subroutine QR_Householder_decomposition","tags":"","url":"proc\\qr_householder_decomposition.html"},{"title":"QR_Givens_decomposition – NAFPack","text":"public  subroutine QR_Givens_decomposition(A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R Calls proc~~qr_givens_decomposition~~CallsGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~identity_n Identity_n proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qr_givens_decomposition~~CalledByGraph proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine QR_Givens_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: G integer :: N , i , j N = size ( A , 1 ) R = A Q = Identity_n ( N ) do j = 1 , N - 1 do i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = matmul ( G , R ) Q = matmul ( Q , transpose ( G )) end do end do end subroutine QR_Givens_decomposition","tags":"","url":"proc\\qr_givens_decomposition.html"},{"title":"QR_Gram_Schmidt_Classical_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Classical_decomposition(A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R Called by proc~~qr_gram_schmidt_classical_decomposition~~CalledByGraph proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 )) :: u integer :: N , i , j N = size ( A , 1 ) Q = 0.d0 R = 0.d0 do j = 1 , N u = A (:, j ) do i = 1 , j - 1 R ( i , j ) = dot_product ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) end do R ( j , j ) = norm2 ( u ) Q (:, j ) = u / R ( j , j ) end do end subroutine QR_Gram_Schmidt_Classical_decomposition","tags":"","url":"proc\\qr_gram_schmidt_classical_decomposition.html"},{"title":"QR_Gram_Schmidt_Modified_decomposition – NAFPack","text":"public  subroutine QR_Gram_Schmidt_Modified_decomposition(A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R Called by proc~~qr_gram_schmidt_modified_decomposition~~CalledByGraph proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition QR_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~eigen Eigen proc~eigen->proc~qr_decomposition proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: u integer :: N , i , j N = size ( A , 1 ) u = A Q = 0.d0 R = 0.d0 do i = 1 , N R ( i , i ) = norm2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) do j = i + 1 , N R ( i , j ) = dot_product ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) end do end do end subroutine QR_Gram_Schmidt_Modified_decomposition","tags":"","url":"proc\\qr_gram_schmidt_modified_decomposition.html"},{"title":"pivot_partial – NAFPack","text":"public  subroutine pivot_partial(A, P) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: P Calls proc~~pivot_partial~~CallsGraph proc~pivot_partial pivot_partial proc~identity_n Identity_n proc~pivot_partial->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine pivot_partial ( A , P ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: P integer , dimension ( 1 ) :: vlmax integer :: N , lmax , k real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: P_tmp N = size ( A , 1 ) P = Identity_n ( N ) do k = 1 , N - 1 ! Find the maximum absolute value in the column from row k to N vlmax = maxloc ( abs ( A ( k : N , k ))) lmax = vlmax ( 1 ) + k - 1 !calculate permutation matrix P P_tmp = Identity_n ( N ) if ( k /= lmax ) then P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) end if P = matmul ( P_tmp , P ) end do end subroutine pivot_partial","tags":"","url":"proc\\pivot_partial.html"},{"title":"pivot_total – NAFPack","text":"public  subroutine pivot_total(A, P, Q) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: P real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: Q Calls proc~~pivot_total~~CallsGraph proc~pivot_total pivot_total proc~identity_n Identity_n proc~pivot_total->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine pivot_total ( A , P , Q ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: P , Q real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: P_tmp , Q_tmp integer , dimension ( 2 ) :: vlmax integer :: N , lmax , cmax , k N = size ( A , 1 ) P = Identity_n ( N ) Q = Identity_n ( N ) do k = 1 , N - 1 ! Find max abs element in submatrix vlmax = maxloc ( abs ( A ( k : N , k : N ))) lmax = vlmax ( 1 ) + k - 1 cmax = vlmax ( 2 ) + k - 1 ! permute line if necessary P_tmp = Identity_n ( N ) if ( k /= lmax ) then P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) end if P = matmul ( P_tmp , P ) ! permute column if necessary Q_tmp = Identity_n ( N ) if ( cmax /= k ) then Q_tmp (:, [ k , cmax ]) = Q_tmp (:, [ cmax , k ]) end if Q = matmul ( Q_tmp , Q ) end do end subroutine pivot_total","tags":"","url":"proc\\pivot_total.html"},{"title":"realloc – NAFPack","text":"public interface realloc Module Procedures private  interface realloc_vec_integer_i8_1D() Arguments None private  interface realloc_vec_integer_i16_1D() Arguments None private  interface realloc_vec_integer_isp_1D() Arguments None private  interface realloc_vec_integer_idp_1D() Arguments None private  interface realloc_vec_integer_i8_2D() Arguments None private  interface realloc_vec_integer_i16_2D() Arguments None private  interface realloc_vec_integer_isp_2D() Arguments None private  interface realloc_vec_integer_idp_2D() Arguments None private  interface realloc_vec_integer_i8_3D() Arguments None private  interface realloc_vec_integer_i16_3D() Arguments None private  interface realloc_vec_integer_isp_3D() Arguments None private  interface realloc_vec_integer_idp_3D() Arguments None private  interface realloc_vec_real_sp_1D() Arguments None private  interface realloc_vec_real_dp_1D() Arguments None private  interface realloc_vec_real_qp_1D() Arguments None private  interface realloc_vec_real_sp_2D() Arguments None private  interface realloc_vec_real_dp_2D() Arguments None private  interface realloc_vec_real_qp_2D() Arguments None private  interface realloc_vec_real_sp_3D() Arguments None private  interface realloc_vec_real_dp_3D() Arguments None private  interface realloc_vec_real_qp_3D() Arguments None private  interface realloc_vec_complex_sp_1D() Arguments None private  interface realloc_vec_complex_dp_1D() Arguments None private  interface realloc_vec_complex_qp_1D() Arguments None private  interface realloc_vec_complex_sp_2D() Arguments None private  interface realloc_vec_complex_dp_2D() Arguments None private  interface realloc_vec_complex_qp_2D() Arguments None private  interface realloc_vec_complex_sp_3D() Arguments None private  interface realloc_vec_complex_dp_3D() Arguments None private  interface realloc_vec_complex_qp_3D() Arguments None","tags":"","url":"interface\\realloc.html"},{"title":"center_with_fill – NAFPack","text":"public  function center_with_fill(text, width, fill_char) result(centered_text) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text integer, intent(in) :: width character(len=1), intent(in), optional :: fill_char Return Value character(kind=ucs4, len=width) Source Code function center_with_fill ( text , width , fill_char ) result ( centered_text ) character ( LEN =* ), intent ( in ) :: text integer , intent ( in ) :: width character ( LEN = 1 ), optional , intent ( in ) :: fill_char character ( LEN = 1 ) :: fill character ( KIND = ucs4 , LEN = width ) :: centered_text integer :: text_len , padding , left_padding , right_padding , i if ( present ( fill_char )) then fill = fill_char else fill = \" \" end if text_len = len_trim ( text ) if ( text_len >= width ) then centered_text = text ( 1 : width ) return end if ! Calculate the total padding required padding = width - text_len if ( trim ( text ) == \"\" ) then left_padding = padding / 2 right_padding = padding - left_padding - mod ( padding , 2 ) else text_len = text_len + 1 left_padding = padding / 2 - 1 right_padding = padding - left_padding - mod ( padding , 2 ) end if ! Initialize the result centered_text = repeat ( ' ' , width ) ! Fill with fill on the left do i = 1 , left_padding centered_text ( i : i ) = fill end do ! Place the text in the center if ( trim ( text ) == \"\" ) then centered_text ( left_padding + 1 : left_padding + text_len ) = trim ( text ) else centered_text ( left_padding + 1 : left_padding + text_len ) = \" \" // trim ( text ) // \" \" end if ! Fill with fill on the right do i = right_padding + text_len , width centered_text ( i : i ) = fill end do end function center_with_fill","tags":"","url":"proc\\center_with_fill.html"},{"title":"log_field – NAFPack","text":"public interface log_field Module Procedures private  subroutine log_field_str(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(len=*), intent(in) :: value private  subroutine log_field_real(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label real(kind=dp), intent(in) :: value private  subroutine log_field_int(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label integer, intent(in) :: value private  subroutine log_field_ucs4(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(kind=ucs4, len=*), intent(in) :: value private  subroutine log_field_logical(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label logical, intent(in) :: value","tags":"","url":"interface\\log_field.html"},{"title":"Eigen – NAFPack","text":"public  subroutine Eigen(A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Power iteration QR algorithm (with or without shift)\nThe default method is Power iteration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:) :: lambda real(kind=dp), intent(out), optional, dimension(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k Calls proc~~eigen~~CallsGraph proc~eigen Eigen proc~identity_n Identity_n proc~eigen->proc~identity_n proc~normalise normalise proc~eigen->proc~normalise proc~qr_decomposition QR_decomposition proc~eigen->proc~qr_decomposition proc~norm_2_real norm_2_real proc~normalise->proc~norm_2_real proc~qr_givens_decomposition QR_Givens_decomposition proc~qr_decomposition->proc~qr_givens_decomposition proc~qr_gram_schmidt_classical_decomposition QR_Gram_Schmidt_Classical_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_classical_decomposition proc~qr_gram_schmidt_modified_decomposition QR_Gram_Schmidt_Modified_decomposition proc~qr_decomposition->proc~qr_gram_schmidt_modified_decomposition proc~qr_householder_decomposition QR_Householder_decomposition proc~qr_decomposition->proc~qr_householder_decomposition proc~qr_givens_decomposition->proc~identity_n proc~rotation_matrix rotation_matrix proc~qr_givens_decomposition->proc~rotation_matrix proc~qr_householder_decomposition->proc~identity_n proc~rotation_matrix->proc~identity_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~eigen~~CalledByGraph proc~eigen Eigen proc~is_spd is_SPD proc~is_spd->proc~eigen Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Eigen ( A , lambda , vp , method , k ) real ( dp ), dimension (:, :), intent ( in ) :: A character ( LEN =* ), optional , intent ( in ) :: method integer , optional , intent ( in ) :: k real ( dp ), dimension (:, :), optional , intent ( out ) :: vp real ( dp ), dimension (:), intent ( out ) :: lambda real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: A_tmp real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: vp_tmp character ( LEN = 50 ) :: base_method integer :: N , i , k_max , pos if ( present ( k )) then if ( k <= 0 ) stop \"ERROR :: k must be a positive integer\" k_max = k else k_max = MAX_ITERATION end if N = size ( A , 1 ) if ( size ( A , 2 ) /= N ) stop \"ERROR :: Matrix A not square\" if ( size ( lambda , 1 ) /= N ) stop \"ERROR :: dimension lambda\" if ( present ( vp ) . and . ( size ( vp , 1 ) /= N . or . size ( vp , 2 ) /= N )) stop \"ERROR :: dimension vp\" if ( method == \"Power_iteration\" ) then A_tmp = A do i = 1 , N call Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) end do if ( present ( vp )) vp = vp_tmp else if ( index ( method , \"QR\" ) == 1 ) then if ( present ( vp )) vp = 0 if ( present ( vp )) print * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = index ( trim ( method ), \"_Shifted\" ) if ( pos > 0 . and . pos + 7 == len_trim ( method )) then base_method = method (: pos - 1 ) call Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) else call Eigen_QR ( A , lambda , method , N , k_max ) end if else stop \"ERROR :: Wrong method for Eigen\" end if end subroutine Eigen","tags":"","url":"proc\\eigen.html"},{"title":"Faddeev_Leverrier – NAFPack","text":"public  subroutine Faddeev_Leverrier(A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:) :: c real(kind=dp), intent(out), optional, dimension(size(A, 1), size(A, 1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check Calls proc~~faddeev_leverrier~~CallsGraph proc~faddeev_leverrier Faddeev_Leverrier proc~identity_n Identity_n proc~faddeev_leverrier->proc~identity_n proc~trace Trace proc~faddeev_leverrier->proc~trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Faddeev_Leverrier ( A , c , Ainv , success , check ) integer , parameter :: dp = kind ( 1.0d0 ) real ( dp ), dimension (:, :), intent ( in ) :: A logical , optional , intent ( in ) :: check real ( dp ), dimension (:), intent ( out ) :: c real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), optional , intent ( out ) :: Ainv logical , optional , intent ( out ) :: success real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: Bk , I , B_Nm1 , AB logical :: do_check integer :: N , k N = size ( A , 1 ) do_check = . true . if ( present ( check )) do_check = check if ( do_check ) then print * , \"Checking if the matrix A is square and size of c is correct\" if ( size ( A , 2 ) /= N . or . size ( c ) < N + 1 ) then print * , \"Error : Matrix A must be square and size of c must be at least N+1\" stop end if end if ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I do k = 2 , N AB = matmul ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / real ( k , dp ) Bk = AB + c ( k + 1 ) * I if ( k == N - 1 . and . present ( Ainv )) B_Nm1 = - Bk end do if ( present ( Ainv ) . and . present ( success )) then if ( abs ( c ( N + 1 )) < 1.0e-12_dp ) then success = . false . Ainv = 0.0_dp else success = . true . Ainv = B_Nm1 / c ( N + 1 ) end if else if ( present ( Ainv )) then if ( abs ( c ( N + 1 )) < 1.0e-12_dp ) then Ainv = 0.0_dp else Ainv = B_Nm1 / c ( N + 1 ) end if end if end subroutine Faddeev_Leverrier","tags":"","url":"proc\\faddeev_leverrier.html"},{"title":"check_indexing – NAFPack","text":"public  subroutine check_indexing(indexing, strict_mode, use_ij_indexing, use_xy_indexing) Arguments Type Intent Optional Attributes Name type(meshgrid_indexing), intent(in), optional :: indexing logical, intent(in), optional :: strict_mode logical, intent(out) :: use_ij_indexing logical, intent(out) :: use_xy_indexing Source Code subroutine check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode logical , intent ( out ) :: use_ij_indexing , use_xy_indexing logical :: is_strict is_strict = . false . if ( present ( strict_mode )) is_strict = strict_mode use_ij_indexing = . false . use_xy_indexing = . false . if ( present ( indexing )) then if ( indexing % id == INDEXING_IJ % id ) then use_ij_indexing = . true . else if ( indexing % id == INDEXING_XY % id ) then use_xy_indexing = . true . else if ( is_strict ) then error stop \"Error: Unknown indexing%id in meshgrid\" else use_ij_indexing = . true . end if end if else use_ij_indexing = . true . end if end subroutine check_indexing","tags":"","url":"proc\\check_indexing.html"},{"title":"meshgrid – NAFPack","text":"public interface meshgrid Make N-dimensional meshgrid from two vectors x_vector and y_vector Module Procedures private  interface meshgrid_real_sp_2D() Arguments None private  interface meshgrid_real_dp_2D() Arguments None private  interface meshgrid_real_qp_2D() Arguments None private  interface meshgrid_real_sp_3D() Arguments None private  interface meshgrid_real_dp_3D() Arguments None private  interface meshgrid_real_qp_3D() Arguments None private  interface meshgrid_integer_i8_2D() Arguments None private  interface meshgrid_integer_i16_2D() Arguments None private  interface meshgrid_integer_isp_2D() Arguments None private  interface meshgrid_integer_idp_2D() Arguments None private  interface meshgrid_integer_i8_3D() Arguments None private  interface meshgrid_integer_i16_3D() Arguments None private  interface meshgrid_integer_isp_3D() Arguments None private  interface meshgrid_integer_idp_3D() Arguments None private  interface meshgrid_cmplx_sp_2D() Arguments None private  interface meshgrid_cmplx_dp_2D() Arguments None private  interface meshgrid_cmplx_qp_2D() Arguments None private  interface meshgrid_cmplx_sp_3D() Arguments None private  interface meshgrid_cmplx_dp_3D() Arguments None private  interface meshgrid_cmplx_qp_3D() Arguments None","tags":"","url":"interface\\meshgrid.html"},{"title":"set_ansi_code – NAFPack","text":"public pure module function set_ansi_code(style, fg_color, bg_color) result(ansi_code) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in), optional :: style integer(kind=i16), intent(in), optional :: fg_color integer(kind=i16), intent(in), optional :: bg_color Return Value type( AnsiCode ) Source Code pure module function set_ansi_code ( style , fg_color , bg_color ) result ( ansi_code ) integer ( i8 ), optional , intent ( in ) :: style integer ( i16 ), optional , intent ( in ) :: fg_color , bg_color type ( AnsiCode ) :: ansi_code ansi_code % use_style = . false . ansi_code % use_fg = . false . ansi_code % use_bg = . false . if ( present ( style )) then ansi_code % use_style = style >= 0 . and . style < 10 if ( ansi_code % use_style ) ansi_code % style = style end if if ( present ( fg_color )) then ansi_code % use_fg = fg_color >= 0 . and . fg_color <= 255 if ( ansi_code % use_fg ) ansi_code % fg = fg_color end if if ( present ( bg_color )) then ansi_code % use_bg = bg_color >= 0 . and . bg_color <= 255 if ( ansi_code % use_bg ) ansi_code % bg = bg_color end if if (. not . ( ansi_code % use_style . or . ansi_code % use_fg . or . ansi_code % use_bg )) then ansi_code = Ansi_Constants % STYLE_RESET end if end function set_ansi_code","tags":"","url":"proc\\set_ansi_code.html"},{"title":"reset_ansi_code – NAFPack","text":"public pure module function reset_ansi_code() result(ansi_code) Arguments None Return Value type( AnsiCode ) Source Code pure module function reset_ansi_code () result ( ansi_code ) type ( AnsiCode ) :: ansi_code ansi_code = Ansi_Constants % STYLE_RESET end function reset_ansi_code","tags":"","url":"proc\\reset_ansi_code.html"},{"title":"create_ansi_ascii – NAFPack","text":"interface public pure module function create_ansi_ascii(ansi_code) result(ansi_string) Arguments Type Intent Optional Attributes Name type( AnsiCode ), intent(in) :: ansi_code Return Value character(kind=ascii,len=:),allocatable","tags":"","url":"interface\\create_ansi_ascii.html"},{"title":"apply_style_ascii – NAFPack","text":"interface public pure module function apply_style_ascii(text, style) result(styled_text) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: text type( AnsiCode ), intent(in) :: style Return Value character(kind=ascii,len=:),allocatable","tags":"","url":"interface\\apply_style_ascii.html"},{"title":"colorize_text_ascii – NAFPack","text":"interface public pure module function colorize_text_ascii(text, color) result(colored_text) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: text integer(kind=i16), intent(in) :: color Return Value character(kind=ascii,len=:),allocatable","tags":"","url":"interface\\colorize_text_ascii.html"},{"title":"cursor_position_ascii – NAFPack","text":"interface public module subroutine cursor_position_ascii(row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: row integer, intent(in) :: col","tags":"","url":"interface\\cursor_position_ascii.html"},{"title":"clear_screen_ascii – NAFPack","text":"interface public module subroutine clear_screen_ascii() Arguments None","tags":"","url":"interface\\clear_screen_ascii.html"},{"title":"clear_line_ascii – NAFPack","text":"interface public module subroutine clear_line_ascii() Arguments None","tags":"","url":"interface\\clear_line_ascii.html"},{"title":"save_cursor_ascii – NAFPack","text":"interface public module subroutine save_cursor_ascii() Arguments None","tags":"","url":"interface\\save_cursor_ascii.html"},{"title":"restore_cursor_ascii – NAFPack","text":"interface public module subroutine restore_cursor_ascii() Arguments None","tags":"","url":"interface\\restore_cursor_ascii.html"},{"title":"create_ansi_ucs4 – NAFPack","text":"interface public pure module function create_ansi_ucs4(ansi_code) result(ansi_string) Arguments Type Intent Optional Attributes Name type( AnsiCode ), intent(in) :: ansi_code Return Value character(kind=ucs4,len=:),allocatable","tags":"","url":"interface\\create_ansi_ucs4.html"},{"title":"apply_style_ucs4 – NAFPack","text":"interface public pure module function apply_style_ucs4(text, style) result(styled_text) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: text type( AnsiCode ), intent(in) :: style Return Value character(kind=ucs4,len=:),allocatable","tags":"","url":"interface\\apply_style_ucs4.html"},{"title":"colorize_text_ucs4 – NAFPack","text":"interface public pure module function colorize_text_ucs4(text, color) result(colored_text) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: text integer(kind=i16), intent(in) :: color Return Value character(kind=ucs4,len=:),allocatable","tags":"","url":"interface\\colorize_text_ucs4.html"},{"title":"cursor_position_ucs4 – NAFPack","text":"interface public module subroutine cursor_position_ucs4(row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: row integer, intent(in) :: col","tags":"","url":"interface\\cursor_position_ucs4.html"},{"title":"clear_screen_ucs4 – NAFPack","text":"interface public module subroutine clear_screen_ucs4() Arguments None","tags":"","url":"interface\\clear_screen_ucs4.html"},{"title":"clear_line_ucs4 – NAFPack","text":"interface public module subroutine clear_line_ucs4() Arguments None","tags":"","url":"interface\\clear_line_ucs4.html"},{"title":"save_cursor_ucs4 – NAFPack","text":"interface public module subroutine save_cursor_ucs4() Arguments None","tags":"","url":"interface\\save_cursor_ucs4.html"},{"title":"restore_cursor_ucs4 – NAFPack","text":"interface public module subroutine restore_cursor_ucs4() Arguments None","tags":"","url":"interface\\restore_cursor_ucs4.html"},{"title":"init_loop_method – NAFPack","text":"public pure function init_loop_method(use_do_classic, use_vectorized, use_do_concurrent, use_openmp, use_mpi, num_threads) result(loop_method) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: use_do_classic logical, intent(in), optional :: use_vectorized logical, intent(in), optional :: use_do_concurrent logical, intent(in), optional :: use_openmp logical, intent(in), optional :: use_mpi integer, intent(in), optional :: num_threads Return Value type( LoopMethod ) Source Code pure function init_loop_method ( & use_do_classic , & use_vectorized , & use_do_concurrent , & use_openmp , & use_mpi , & num_threads ) result ( loop_method ) logical , intent ( in ), optional :: use_do_classic , & use_vectorized , & use_do_concurrent , & use_openmp , & use_mpi integer , intent ( in ), optional :: num_threads type ( LoopMethod ) :: loop_method logical :: method_used loop_method = empty_loop_method method_used = . false . if ( present ( use_do_classic )) then if ( use_do_classic ) loop_method % use_do_classic = . true . end if if ( present ( use_vectorized )) then if ( use_vectorized ) loop_method % use_vectorized = . true . call check_method_used ( method_used ) end if if ( present ( use_do_concurrent )) then if ( use_do_concurrent ) loop_method % use_do_concurrent = . true . call check_method_used ( method_used ) end if if ( present ( use_openmp )) then if ( use_openmp ) loop_method % parallel % use_openmp = . true . if ( present ( num_threads )) then if ( num_threads > 0 ) then loop_method % parallel % num_threads = num_threads else error stop \"num_threads must be a positive integer\" end if end if call check_method_used ( method_used ) end if if ( present ( use_mpi )) then if ( use_mpi ) loop_method % parallel % use_mpi = . true . if ( present ( num_threads )) then if ( num_threads > 0 ) then loop_method % parallel % num_threads = num_threads else error stop \"num_threads must be a positive integer\" end if end if call check_method_used ( method_used ) end if if (. not . method_used ) then loop_method = default_loop_method end if end function init_loop_method","tags":"","url":"proc\\init_loop_method.html"},{"title":"count_true_methods – NAFPack","text":"public pure function count_true_methods(loop_method) result(count_true) Arguments Type Intent Optional Attributes Name type( LoopMethod ), intent(in) :: loop_method Return Value integer Called by proc~~count_true_methods~~CalledByGraph proc~count_true_methods count_true_methods proc~check_loop_method check_loop_method proc~check_loop_method->proc~count_true_methods Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function count_true_methods ( loop_method ) result ( count_true ) type ( LoopMethod ), intent ( in ) :: loop_method integer :: count_true count_true = 0 if ( loop_method % use_do_classic ) count_true = count_true + 1 if ( loop_method % use_vectorized ) count_true = count_true + 1 if ( loop_method % use_do_concurrent ) count_true = count_true + 1 if ( loop_method % parallel % use_openmp ) count_true = count_true + 1 if ( loop_method % parallel % use_mpi ) count_true = count_true + 1 end function count_true_methods","tags":"","url":"proc\\count_true_methods.html"},{"title":"check_loop_method – NAFPack","text":"public  function check_loop_method(loop_method) result(loop_method_used) Arguments Type Intent Optional Attributes Name type( LoopMethod ), intent(in) :: loop_method Return Value type( LoopMethod ) Calls proc~~check_loop_method~~CallsGraph proc~check_loop_method check_loop_method proc~count_true_methods count_true_methods proc~check_loop_method->proc~count_true_methods Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function check_loop_method ( loop_method ) result ( loop_method_used ) type ( LoopMethod ), intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used integer :: nb_of_true nb_of_true = count_true_methods ( loop_method ) if ( nb_of_true == 0 ) then loop_method_used = default_loop_method else if ( nb_of_true == 1 ) then loop_method_used = loop_method else loop_method_used = default_loop_method end if end function check_loop_method","tags":"","url":"proc\\check_loop_method.html"},{"title":"Calculate_Jacobi_preconditioner – NAFPack","text":"public  function Calculate_Jacobi_preconditioner(A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~calculate_jacobi_preconditioner~~CallsGraph proc~calculate_jacobi_preconditioner Calculate_Jacobi_preconditioner proc~diag Diag proc~calculate_jacobi_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Calculate_Jacobi_preconditioner ( A ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: D integer :: N , i N = size ( A , 1 ) D = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in Jacobi preconditioner\" forall ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) end function Calculate_Jacobi_preconditioner","tags":"","url":"proc\\calculate_jacobi_preconditioner.html"},{"title":"Calculate_Gauss_Seidel_preconditioner – NAFPack","text":"public  function Calculate_Gauss_Seidel_preconditioner(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~calculate_gauss_seidel_preconditioner~~CallsGraph proc~calculate_gauss_seidel_preconditioner Calculate_Gauss_Seidel_preconditioner proc~diag Diag proc~calculate_gauss_seidel_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Calculate_Gauss_Seidel_preconditioner ( A ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer :: N , i , j N = size ( A , 1 ) L = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" forall ( i = 1 : size ( A , 1 ), j = 1 : size ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) end function Calculate_Gauss_Seidel_preconditioner","tags":"","url":"proc\\calculate_gauss_seidel_preconditioner.html"},{"title":"Calculate_SOR_preconditioner – NAFPack","text":"public  function Calculate_SOR_preconditioner(A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~calculate_sor_preconditioner~~CallsGraph proc~calculate_sor_preconditioner Calculate_SOR_preconditioner proc~diag Diag proc~calculate_sor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Calculate_SOR_preconditioner ( A , omega , alpha ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer :: N , i N = size ( A , 1 ) L = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in SOR preconditioner\" do i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) end do L = alpha * L end function Calculate_SOR_preconditioner","tags":"","url":"proc\\calculate_sor_preconditioner.html"},{"title":"Calculate_JOR_preconditioner – NAFPack","text":"public  function Calculate_JOR_preconditioner(A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~calculate_jor_preconditioner~~CallsGraph proc~calculate_jor_preconditioner Calculate_JOR_preconditioner proc~diag Diag proc~calculate_jor_preconditioner->proc~diag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Calculate_JOR_preconditioner ( A , omega , alpha ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: D integer :: N , i N = size ( A , 1 ) D = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in JOR preconditioner\" forall ( i = 1 : size ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha end function Calculate_JOR_preconditioner","tags":"","url":"proc\\calculate_jor_preconditioner.html"},{"title":"Calculate_ICF_preconditioner – NAFPack","text":"public  function Calculate_ICF_preconditioner(A, omega, alpha, fill_level) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Calls proc~~calculate_icf_preconditioner~~CallsGraph proc~calculate_icf_preconditioner Calculate_ICF_preconditioner proc~incomplete_cholesky_decomposition Incomplete_Cholesky_decomposition proc~calculate_icf_preconditioner->proc~incomplete_cholesky_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function Calculate_ICF_preconditioner ( A , omega , alpha , fill_level ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer , optional , intent ( in ) :: fill_level integer :: N N = size ( A , 1 ) L = 0.d0 if ( present ( fill_level )) then call Incomplete_Cholesky_decomposition ( A , L , fill_level ) else call Incomplete_Cholesky_decomposition ( A , L ) end if L = alpha / omega * L end function Calculate_ICF_preconditioner","tags":"","url":"proc\\calculate_icf_preconditioner.html"},{"title":"Calculate_ILU_preconditioner – NAFPack","text":"public  subroutine Calculate_ILU_preconditioner(A, L, U, omega, alpha, fill_level) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Calls proc~~calculate_ilu_preconditioner~~CallsGraph proc~calculate_ilu_preconditioner Calculate_ILU_preconditioner proc~ilu_decomposition ILU_decomposition proc~calculate_ilu_preconditioner->proc~ilu_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Calculate_ILU_preconditioner ( A , L , U , omega , alpha , fill_level ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: L , U integer , optional , intent ( in ) :: fill_level integer :: N N = size ( A , 1 ) L = 0.d0 U = 0.d0 if ( present ( fill_level )) then call ILU_decomposition ( A , L , U , fill_level ) else call ILU_decomposition ( A , L , U ) end if L = alpha / omega * L end subroutine Calculate_ILU_preconditioner","tags":"","url":"proc\\calculate_ilu_preconditioner.html"},{"title":"Calculate_SSOR_preconditioner – NAFPack","text":"public  subroutine Calculate_SSOR_preconditioner(A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Source Code subroutine Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: L , D integer :: N , i N = size ( A , 1 ) L = 0.d0 D = 0.d0 do i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) end do L = ( alpha * omega ) / ( 2 - omega ) * L end subroutine Calculate_SSOR_preconditioner","tags":"","url":"proc\\calculate_ssor_preconditioner.html"},{"title":"ApplyPreconditioner – NAFPack","text":"public  function ApplyPreconditioner(params, method, x) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp), dimension(size(params%x_init)) Calls proc~~applypreconditioner~~CallsGraph proc~applypreconditioner ApplyPreconditioner proc~backward backward proc~applypreconditioner->proc~backward proc~forward forward proc~applypreconditioner->proc~forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function ApplyPreconditioner ( params , method , x ) result ( y ) class ( IterativeParams ), intent ( in ) :: params class ( MethodPreconditioner ), intent ( in ) :: method real ( dp ), dimension (:), intent ( in ) :: x real ( dp ), dimension ( size ( params % x_init )) :: y select case ( method % id ) case ( METHOD_PRECOND_JACOBI % id ) if (. not . allocated ( params % D )) stop \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) case ( METHOD_PRECOND_GS % id ) if (. not . allocated ( params % L )) stop \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) case ( METHOD_PRECOND_SOR % id ) if (. not . allocated ( params % L )) stop \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) case ( METHOD_PRECOND_JOR % id ) if (. not . allocated ( params % D )) stop \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) case ( METHOD_PRECOND_ILU % id ) if (. not . allocated ( params % L ) . or . & . not . allocated ( params % U )) stop \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , x ) y = backward ( params % U , y ) case ( METHOD_PRECOND_ICF % id ) if (. not . allocated ( params % L )) stop \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) y = backward ( transpose ( params % L ), y ) case ( METHOD_PRECOND_SSOR % id ) if (. not . allocated ( params % L ) . or . & . not . allocated ( params % D )) stop \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , x ) y = matmul ( params % D , y ) y = backward ( transpose ( params % L ), y ) case DEFAULT stop \"ERROR :: Unknown preconditioner method\" end select end function ApplyPreconditioner","tags":"","url":"proc\\applypreconditioner.html"},{"title":"NAFPack_memory_monitor – NAFPack","text":"Used by module~~nafpack_memory_monitor~~UsedByGraph module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_memory_kb () result(memory_kb) Arguments None Return Value integer","tags":"","url":"module\\nafpack_memory_monitor.html"},{"title":"NAFPack_math_utils – NAFPack","text":"Uses NAFPack_kinds module~~nafpack_math_utils~~UsesGraph module~nafpack_math_utils NAFPack_math_utils module~nafpack_kinds NAFPack_kinds module~nafpack_math_utils->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_math_utils~~UsedByGraph module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function sieve_of_eratosthenes (N) result(primes) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N Return Value integer(kind=isp), dimension(:), allocatable public pure function is_power_of_two (N) result(value) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N Return Value logical public pure function power_of_p_exponent (N, p) result(exponent) Arguments Type Intent Optional Attributes Name integer(kind=isp), intent(in) :: N integer(kind=isp), intent(in) :: p Return Value integer(kind=isp)","tags":"","url":"module\\nafpack_math_utils.html"},{"title":"NAFPack_matricielle – NAFPack","text":"Module for Tensor operations in NAFPack Uses NAFPack_kinds module~~nafpack_matricielle~~UsesGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_kinds NAFPack_kinds module~nafpack_matricielle->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matricielle~~UsedByGraph module~nafpack_matricielle NAFPack_matricielle module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_krylov_method->module~nafpack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function dot (a, b) result(result) function that calculates the dot product of two real 3-dimensional vectors and Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp) public  function cross (a, b) result(result) function that calculates the cross product between two real 3-dimensional vectors and 1 Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: a real(kind=dp), intent(in), dimension(3) :: b Return Value real(kind=dp), dimension(3) public  function norm_2_real (a) result(result) function that calculates the Euclidean norm (L2 norm) of a vector ,\nwhere where is the dimension of the real vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp) public  function norm_2_complex (a) result(result) function that calculates the Euclidean norm (L2 norm or modulus) of a vector ,\nwhere where is the dimension of the complex vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp) public  function normalise (a) result(result) function that normalises a real vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: a Return Value real(kind=dp), dimension(size(a)) public  function normalise_complexe (a) result(result) function that normalises a complex vector a to make it a unit vector,\nwhere Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: a Return Value complex(kind=dp), dimension(size(a)) public  function Trace (A) result(result) function that calculates the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp) public  function Diagonally_Dominant_Matrix (A) result(diagonally_dominant) function which checks if A is diagonally dominant Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function Identity_n (N, use_concurrent) result(Identity) function that returns the identity matrix for a given size N Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), dimension(N, N) public  function Diag (A) result(D) function that extracts the diagonal of a matrix where is a vector containing the diagonal elements of the matrix . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1)) public  function Make_Tridiagonal (d_minus, d, d_plus) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: d_minus real(kind=dp), intent(in), dimension(:) :: d real(kind=dp), intent(in), dimension(:) :: d_plus Return Value real(kind=dp), dimension(size(d, 1), size(d, 1)) public  function rotation_matrix (A, rotation) result(G) Function to create a rotation matrix Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), dimension(2) :: rotation Return Value real(kind=dp), dimension(size(A, 1), size(A, 2))","tags":"","url":"module\\nafpack_matricielle.html"},{"title":"NAFPack_Direct_method – NAFPack","text":"Module for direct methods in NAFPack Uses NAFPack_matrix_properties NAFPack_kinds NAFPack_matrix_decomposition NAFPack_Direct_types NAFPack_matrix_tools NAFPack_matricielle NAFPack_constant module~~nafpack_direct_method~~UsesGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_kinds NAFPack_kinds module~nafpack_direct_method->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_direct_method->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_kinds module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools->module~nafpack_kinds module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_kinds module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_direct_method~~UsedByGraph module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: DirectMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: set_qr_method procedure, public :: solve => DirectMethod_solve procedure, public :: test_matrix","tags":"","url":"module\\nafpack_direct_method.html"},{"title":"NAFPack_Iterative_types – NAFPack","text":"Uses NAFPack_kinds module~~nafpack_iterative_types~~UsesGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_kinds NAFPack_kinds module~nafpack_iterative_types->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_types~~UsedByGraph module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeIterative ), public, parameter :: METHOD_ITERATIVE_NONE = MethodTypeIterative(0, \"None\") type( MethodTypeIterative ), public, parameter :: METHOD_Jacobi = MethodTypeIterative(1, \"Jacobi\") type( MethodTypeIterative ), public, parameter :: METHOD_GAUSS_SEIDEL = MethodTypeIterative(2, \"Gauss-Seidel\") type( MethodTypeIterative ), public, parameter :: METHOD_SOR = MethodTypeIterative(3, \"Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_JOR = MethodTypeIterative(4, \"Jacobi Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ILU = MethodTypeIterative(5, \"Strongly Implicit Procedure\", \"ILU\") type( MethodTypeIterative ), public, parameter :: METHOD_SIP_ICF = MethodTypeIterative(6, \"Strongly Implicit Procedure\", \"ICF\") type( MethodTypeIterative ), public, parameter :: METHOD_SSOR = MethodTypeIterative(7, \"Symmetric Successive Over-Relaxation\") type( MethodTypeIterative ), public, parameter :: METHOD_RICHARDSON = MethodTypeIterative(8, \"Richardson\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_GRADIENT = MethodTypeIterative(9, \"Conjugate Gradient\") type( MethodTypeIterative ), public, parameter :: METHOD_CONJUGATE_RESIDUAL = MethodTypeIterative(10, \"Conjugate Residual\") type( MethodTypeIterative ), public, parameter :: METHOD_CGNE = MethodTypeIterative(11, \"Conjugate Gradient on Normal Equations\") type( MethodTypeIterative ), public, parameter :: METHOD_CGNR = MethodTypeIterative(12, \"Conjugate Gradient on Normal Residual\") type( MethodTypeIterative ), public, parameter :: METHOD_GMRES = MethodTypeIterative(13, \"Generalized Minimal Residual\") type( Norm_used ), public, parameter :: NORM_2 = Norm_used(1, \"Norm L2 or Euclidean\") type( Norm_used ), public, parameter :: NORM_1 = Norm_used(2, \"Norm L1 or Manhattan\") type( Norm_used ), public, parameter :: NORM_INF = Norm_used(3, \"Norm LInfini or Maximum\") type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_NONE = relaxation_factor_used(0, none) type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_OMEGA = relaxation_factor_used(1, omega) type( relaxation_factor_used ), public, parameter :: RELAXATION_FACTOR_ALPHA = relaxation_factor_used(2, alpha) Derived Types type, public :: MethodTypeIterative Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name character(len=64), public :: name2 = \"\" type, public :: IterativeMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .false. logical, public :: needs_diag_dom = .false. logical, public :: needs_square = .false. logical, public :: needs_symetric = .false. type, public :: Norm_used Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: relaxation_factor_used Components Type Visibility Attributes Name Initial integer, public :: id character(kind=ucs4, len=64), public :: name","tags":"","url":"module\\nafpack_iterative_types.html"},{"title":"NAFPack_matrix_properties – NAFPack","text":"Uses NAFPack_kinds NAFPack_Eigen NAFPack_matricielle NAFPack_constant module~~nafpack_matrix_properties~~UsesGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_constant NAFPack_constant module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_kinds NAFPack_kinds module~nafpack_matrix_properties->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_constant->module~nafpack_kinds module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_kinds module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_properties~~UsedByGraph module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function is_square_matrix (A) result(is_square) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function is_symmetric (A) result(is_sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function is_orthogonal (A) result(is_orth) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function is_SPD (A, is_sym) result(is_spd_matrix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A logical, intent(in), optional :: is_sym Return Value logical public  function is_tridiagonal (A) result(is_tridiag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function is_diagonally_dominant (A) result(is_diag_dom) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical public  function is_non_zero_diagonal (A) result(is_non_zero_diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value logical","tags":"","url":"module\\nafpack_matrix_properties.html"},{"title":"NAFPack_io_utils – NAFPack","text":"Uses NAFPack_kinds module~~nafpack_io_utils~~UsesGraph module~nafpack_io_utils NAFPack_io_utils module~nafpack_kinds NAFPack_kinds module~nafpack_io_utils->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_io_utils~~UsedByGraph module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi NAFPack_ANSI module~nafpack_ansi->module~nafpack_io_utils module~nafpack_ansi_ascii NAFPack_ANSI_ASCII module~nafpack_ansi_ascii->module~nafpack_ansi module~nafpack_ansi_ucs4 NAFPack_ANSI_ucs4 module~nafpack_ansi_ucs4->module~nafpack_ansi module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_terminal->module~nafpack_ansi module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface to_str_ascii private pure function int8_to_str_ascii(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: value Return Value character(kind=ascii, len=:), allocatable private pure function int16_to_str_ascii(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: value Return Value character(kind=ascii, len=:), allocatable public        interface to_str_ucs4 private pure function int8_to_str_ucs4(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: value Return Value character(kind=ucs4, len=:), allocatable private pure function int16_to_str_ucs4(value) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: value Return Value character(kind=ucs4, len=:), allocatable","tags":"","url":"module\\nafpack_io_utils.html"},{"title":"NAFPack_terminal – NAFPack","text":"Uses NAFPack_kinds NAFPack_ANSI module~~nafpack_terminal~~UsesGraph module~nafpack_terminal NAFPack_terminal module~nafpack_ansi NAFPack_ANSI module~nafpack_terminal->module~nafpack_ansi module~nafpack_kinds NAFPack_kinds module~nafpack_terminal->module~nafpack_kinds module~nafpack_ansi->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_kinds->iso_fortran_env module~nafpack_io_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_terminal~~UsedByGraph module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface print_colored_message private  subroutine print_colored_message_ucs4(color, message) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: color character(kind=ucs4, len=*), intent(in) :: message private  subroutine print_colored_message_ascii(color, message) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: color character(kind=ascii, len=*), intent(in) :: message","tags":"","url":"module\\nafpack_terminal.html"},{"title":"NAFPack_fft – NAFPack","text":"Module for Fourier Transform This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals.\nIt supports both forward and inverse transforms.\nIt allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. Uses NAFPack_kinds NAFPack_constant FFTW3 module~~nafpack_fft~~UsesGraph module~nafpack_fft NAFPack_fft FFTW3 FFTW3 module~nafpack_fft->FFTW3 module~nafpack_constant NAFPack_constant module~nafpack_fft->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fft->module~nafpack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function FFT_1D (signal, method, threads) result(result) Perform a 1D Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal)) public  function IFFT_1D (signal, method, threads) result(result) Perform a 1D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal)) public  function FFT_2D (signal, method, threads) result(result) Perform a 2D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2)) public  function IFFT_2D (signal, method, threads) result(result) Perform a 2D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2)) public  function FFT_3D (signal, method, threads) result(result) Perform a 3D Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2), size(signal, 3)) public  function IFFT_3D (signal, method, threads) result(result) Perform a 3D inverse Fast Fourier Transform on a signal Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), dimension(size(signal, 1), size(signal, 2), size(signal, 3))","tags":"","url":"module\\nafpack_fft.html"},{"title":"NAFPack_Fourier_Transform – NAFPack","text":"Uses NAFPack_kinds NAFPack_loop_method NAFPack_math_utils NAFPack_constant module~~nafpack_fourier_transform~~UsesGraph module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_Fourier_Transform_dft NAFPack_Fourier_Transform_dft2 NAFPack_Fourier_Transform_dft3 NAFPack_Fourier_Transform_fft module~~nafpack_fourier_transform~~UsedByGraph module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( DecimationMethod ), public, parameter :: DIT = DecimationMethod(1, \"DIT\") type( DecimationMethod ), public, parameter :: DIF = DecimationMethod(2, \"DIF\") type( FFTAlgorithm ), public, parameter :: ALG_AUTO = FFTAlgorithm(0, \"Auto\", DIT) type( FFTAlgorithm ), public, parameter :: ALG_RADIX2_DIT = FFTAlgorithm(1, \"Radix-2 DIT\", DIT) type( FFTAlgorithm ), public, parameter :: ALG_RADIX2_DIF = FFTAlgorithm(2, \"Radix-2 DIF\", DIF) type( FFTAlgorithm ), public, parameter :: ALG_MIXED_DIT = FFTAlgorithm(3, \"Mixed Radix DIT\", DIT) type( FFTAlgorithm ), public, parameter :: ALG_MIXED_DIF = FFTAlgorithm(4, \"Mixed Radix DIF\", DIF) type( FFTAlgorithm ), public, parameter :: ALG_SPLIT_DIT = FFTAlgorithm(5, \"Split Radix DIT\", DIT) type( FFTAlgorithm ), public, parameter :: ALG_SPLIT_DIF = FFTAlgorithm(6, \"Split Radix DIF\", DIF) Interfaces public        interface dft private  interface dft_cmplx_sp() Arguments None private  interface dft_cmplx_dp() Arguments None private  interface dft_cmplx_qp() Arguments None private  interface dft_real_sp() Arguments None private  interface dft_real_dp() Arguments None private  interface dft_real_qp() Arguments None public        interface idft private  interface idft_cmplx_sp() Arguments None private  interface idft_cmplx_dp() Arguments None private  interface idft_cmplx_qp() Arguments None private  interface idft_real_sp() Arguments None private  interface idft_real_dp() Arguments None private  interface idft_real_qp() Arguments None public        interface dft2 private  interface dft2_cmplx_sp() Arguments None private  interface dft2_cmplx_dp() Arguments None private  interface dft2_cmplx_qp() Arguments None private  interface dft2_real_sp() Arguments None private  interface dft2_real_dp() Arguments None private  interface dft2_real_qp() Arguments None public        interface idft2 private  interface idft2_cmplx_sp() Arguments None private  interface idft2_cmplx_dp() Arguments None private  interface idft2_cmplx_qp() Arguments None private  interface idft2_real_sp() Arguments None private  interface idft2_real_dp() Arguments None private  interface idft2_real_qp() Arguments None public        interface dft3 private  interface dft3_cmplx_sp() Arguments None private  interface dft3_cmplx_dp() Arguments None private  interface dft3_cmplx_qp() Arguments None private  interface dft3_real_sp() Arguments None private  interface dft3_real_dp() Arguments None private  interface dft3_real_qp() Arguments None public        interface idft3 private  interface idft3_cmplx_sp() Arguments None private  interface idft3_cmplx_dp() Arguments None private  interface idft3_cmplx_qp() Arguments None private  interface idft3_real_sp() Arguments None private  interface idft3_real_dp() Arguments None private  interface idft3_real_qp() Arguments None Derived Types type, public :: DecimationMethod Components Type Visibility Attributes Name Initial integer(kind=isp), public :: id character(len=20), public :: name type, public :: FFTAlgorithm Components Type Visibility Attributes Name Initial integer(kind=isp), public :: id character(len=20), public :: name type( DecimationMethod ), public :: decimation_method type, public :: Fourier_Transform Components Type Visibility Attributes Name Initial type(FFTPlan), public :: fft_plan Type-Bound Procedures generic, public :: dft => dft_cmplx_sp, dft_cmplx_dp, dft_cmplx_qp generic, public :: dft => dft_real_sp, dft_real_dp, dft_real_qp generic, public :: dft => dft2_cmplx_sp, dft2_cmplx_dp, dft2_cmplx_qp generic, public :: dft => dft2_real_sp, dft2_real_dp, dft2_real_qp generic, public :: dft => dft3_cmplx_sp, dft3_cmplx_dp, dft3_cmplx_qp generic, public :: dft => dft3_real_sp, dft3_real_dp, dft3_real_qp generic, public :: idft => idft_cmplx_sp, idft_cmplx_dp, idft_cmplx_qp generic, public :: idft => idft_real_sp, idft_real_dp, idft_real_qp generic, public :: idft => idft2_cmplx_sp, idft2_cmplx_dp, idft2_cmplx_qp generic, public :: idft => idft2_real_sp, idft2_real_dp, idft2_real_qp generic, public :: idft => idft3_cmplx_sp, idft3_cmplx_dp, idft3_cmplx_qp generic, public :: idft => idft3_real_sp, idft3_real_dp, idft3_real_qp generic, public :: init_fft_plan => init_fft_plan_sp generic, public :: fft => fft_cmplx_sp generic, public :: destroy_fft_plan => destroy_fft_plan_sp","tags":"","url":"module\\nafpack_fourier_transform.html"},{"title":"NAFPack_matrix_market – NAFPack","text":"Uses NAFPack_kinds module~~nafpack_matrix_market~~UsesGraph module~nafpack_matrix_market NAFPack_matrix_market module~nafpack_kinds NAFPack_kinds module~nafpack_matrix_market->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine readMatrixMarket (filename, A) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: A","tags":"","url":"module\\nafpack_matrix_market.html"},{"title":"NAFPack_linalg – NAFPack","text":"Uses NAFPack_Direct_method NAFPack_Iterative_methods NAFPack_Iterative_types NAFPack_Iterative_Params NAFPack_Direct_types NAFPack_Preconditioners module~~nafpack_linalg~~UsesGraph module~nafpack_linalg NAFPack_linalg module~nafpack_direct_method NAFPack_Direct_method module~nafpack_linalg->module~nafpack_direct_method module~nafpack_direct_types NAFPack_Direct_types module~nafpack_linalg->module~nafpack_direct_types module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_linalg->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_constant NAFPack_constant module~nafpack_direct_method->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_direct_method->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_direct_method->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_methods->module~nafpack_kinds module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_kinds module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_types->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_logger_mod->module~nafpack_kinds module~nafpack_ansi NAFPack_ANSI module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_kinds module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_tools->module~nafpack_kinds module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_ansi->module~nafpack_kinds module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_kinds module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_terminal->module~nafpack_kinds module~nafpack_terminal->module~nafpack_ansi module~nafpack_io_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: linalg Components Type Visibility Attributes Name Initial type( DirectMethod ), public :: direct type( IterativeMethod ), public :: iterative","tags":"","url":"module\\nafpack_linalg.html"},{"title":"NAFPack_Iterative_methods – NAFPack","text":"Module for iterative methods in NAFPack Uses NAFPack_matrix_properties NAFPack_memory_monitor NAFPack_Iterative_types NAFPack_kinds NAFPack_Logger_mod NAFPack_matrix_decomposition NAFPack_Preconditioners NAFPack_Iterative_Params module~~nafpack_iterative_methods~~UsesGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_kinds NAFPack_kinds module~nafpack_iterative_methods->module~nafpack_kinds module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_memory_monitor NAFPack_memory_monitor module~nafpack_iterative_methods->module~nafpack_memory_monitor module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_kinds module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_logger_mod->module~nafpack_kinds module~nafpack_ansi NAFPack_ANSI module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_properties->module~nafpack_kinds module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_ansi->module~nafpack_kinds module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_constant->module~nafpack_kinds module~nafpack_eigen->module~nafpack_kinds module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matricielle->module~nafpack_kinds module~nafpack_terminal->module~nafpack_kinds module~nafpack_terminal->module~nafpack_ansi module~nafpack_io_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_methods~~UsedByGraph module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeMethod Type-Bound Procedures procedure, public :: set_method procedure, public :: solve => IterativeMethod_solve procedure, public :: Init_IterativeParams procedure, public :: Dealocate_IterativeParams procedure, public :: test_matrix","tags":"","url":"module\\nafpack_iterative_methods.html"},{"title":"NAFPack_matrix_decomposition – NAFPack","text":"Module for matrix decomposition methods This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. Uses NAFPack_kinds NAFPack_matricielle NAFPack_constant module~~nafpack_matrix_decomposition~~UsesGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_decomposition~~UsedByGraph module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_matrix_properties->module~nafpack_eigen Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function forward (L, b) result(y) forward algorithm,\nsolves the system where L is a lower triangular matrix and b is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: L real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp), dimension(size(L, 1)) public  function backward (U, y) result(x) backward algorithm,\nsolves the system where U is an upper triangular matrix and y is a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: U real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp), dimension(size(U, 1)) Subroutines public  subroutine LU_decomposition (A, L, U) LU decomposition of a matrix A This subroutine performs LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U public  subroutine LDU_decomposition (A, L, D, U) LDU decomposition of a matrix A This subroutine performs LDU decomposition of a given matrix A , where L is a lower triangular matrix, D is a diagonal matrix, and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: D real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U public  subroutine ILU_decomposition (A, L, U, level) Incomplete LU decomposition of a matrix A This subroutine performs incomplete LU decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: U integer, intent(in), optional :: level public  subroutine Cholesky_decomposition (A, L) Cholesky decomposition of a matrix A This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L public  subroutine LDL_Cholesky_decomposition (A, L, D) Alternative Cholesky decomposition of a matrix A This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix A , where L is a lower triangular matrix and D is a diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: D public  subroutine Incomplete_Cholesky_decomposition (A, L, level) Incomplete Cholesky decomposition of a matrix A This subroutine performs incomplete Cholesky decomposition of a given matrix A , where L is a lower triangular matrix and U is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: L integer, intent(in), optional :: level public  subroutine QR_decomposition (A, method, Q, R) QR decomposition of a matrix A using various methods This subroutine performs QR decomposition of a given matrix A using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt).\nThe output matrices Q is an orthogonal matrix and R is an upper triangular matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R public  subroutine QR_Householder_decomposition (A, Q, R) QR decomposition using Householder method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R public  subroutine QR_Givens_decomposition (A, Q, R) QR decomposition using Givens rotations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Classical_decomposition (A, Q, R) QR decomposition using Classical Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R public  subroutine QR_Gram_Schmidt_Modified_decomposition (A, Q, R) QR decomposition using Modified Gram-Schmidt method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: Q real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: R public  subroutine pivot_partial (A, P) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: P public  subroutine pivot_total (A, P, Q) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: P real(kind=dp), intent(out), dimension(size(A, 1), size(A, 1)) :: Q","tags":"","url":"module\\nafpack_matrix_decomposition.html"},{"title":"NAFPack_memory_management – NAFPack","text":"Uses NAFPack_kinds module~~nafpack_memory_management~~UsesGraph module~nafpack_memory_management NAFPack_memory_management module~nafpack_kinds NAFPack_kinds module~nafpack_memory_management->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_memory_management_complex NAFPack_memory_management_integer NAFPack_memory_management_real module~~nafpack_memory_management~~UsedByGraph module~nafpack_memory_management NAFPack_memory_management module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_memory_management_complex NAFPack_memory_management_complex module~nafpack_memory_management_complex->module~nafpack_memory_management module~nafpack_memory_management_integer NAFPack_memory_management_integer module~nafpack_memory_management_integer->module~nafpack_memory_management module~nafpack_memory_management_real NAFPack_memory_management_real module~nafpack_memory_management_real->module~nafpack_memory_management module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface realloc private  interface realloc_vec_integer_i8_1D() Arguments None private  interface realloc_vec_integer_i16_1D() Arguments None private  interface realloc_vec_integer_isp_1D() Arguments None private  interface realloc_vec_integer_idp_1D() Arguments None private  interface realloc_vec_integer_i8_2D() Arguments None private  interface realloc_vec_integer_i16_2D() Arguments None private  interface realloc_vec_integer_isp_2D() Arguments None private  interface realloc_vec_integer_idp_2D() Arguments None private  interface realloc_vec_integer_i8_3D() Arguments None private  interface realloc_vec_integer_i16_3D() Arguments None private  interface realloc_vec_integer_isp_3D() Arguments None private  interface realloc_vec_integer_idp_3D() Arguments None private  interface realloc_vec_real_sp_1D() Arguments None private  interface realloc_vec_real_dp_1D() Arguments None private  interface realloc_vec_real_qp_1D() Arguments None private  interface realloc_vec_real_sp_2D() Arguments None private  interface realloc_vec_real_dp_2D() Arguments None private  interface realloc_vec_real_qp_2D() Arguments None private  interface realloc_vec_real_sp_3D() Arguments None private  interface realloc_vec_real_dp_3D() Arguments None private  interface realloc_vec_real_qp_3D() Arguments None private  interface realloc_vec_complex_sp_1D() Arguments None private  interface realloc_vec_complex_dp_1D() Arguments None private  interface realloc_vec_complex_qp_1D() Arguments None private  interface realloc_vec_complex_sp_2D() Arguments None private  interface realloc_vec_complex_dp_2D() Arguments None private  interface realloc_vec_complex_qp_2D() Arguments None private  interface realloc_vec_complex_sp_3D() Arguments None private  interface realloc_vec_complex_dp_3D() Arguments None private  interface realloc_vec_complex_qp_3D() Arguments None","tags":"","url":"module\\nafpack_memory_management.html"},{"title":"NAFPack_constant – NAFPack","text":"Module for defining constants used in NAFPack This module includes mathematical constants,\nand other parameters that are used throughout the NAFPack library. Uses NAFPack_kinds module~~nafpack_constant~~UsesGraph module~nafpack_constant NAFPack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_constant~~UsedByGraph module~nafpack_constant NAFPack_constant module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_constant module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_fft NAFPack_fft module~nafpack_fft->module~nafpack_constant module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=sp), public, parameter :: pi_sp = acos(-1.0_sp) constant real(kind=dp), public, parameter :: pi_dp = acos(-1.0_dp) real(kind=qp), public, parameter :: pi_qp = acos(-1.0_qp) complex(kind=sp), public, parameter :: im_sp = (0.0_sp, 1.0_sp) Imaginary unit complex(kind=dp), public, parameter :: im_dp = (0.0_dp, 1.0_dp) complex(kind=qp), public, parameter :: im_qp = (0.0_qp, 1.0_qp) integer, public, parameter :: int_inf = huge(1) Integer infinity integer, public, parameter :: NAF_SUCCESS = 0 Error codes for better error handling integer, public, parameter :: NAF_ERROR_DIMENSION = 1 integer, public, parameter :: NAF_ERROR_SINGULAR = 2 integer, public, parameter :: NAF_ERROR_CONVERGENCE = 3 integer, public, parameter :: NAF_ERROR_MEMORY = 4 integer, public, parameter :: NAF_ERROR_INVALID_METHOD = 5 real(kind=sp), public, parameter :: TOL_PIVOT_sp = 1.0e-7_sp+epsilon(1.0_sp) real(kind=dp), public, parameter :: TOL_PIVOT_dp = 1.0e-14_dp+epsilon(1.0_dp) real(kind=qp), public, parameter :: TOL_PIVOT_qp = 1.0e-28_qp+epsilon(1.0_qp) real(kind=sp), public, parameter :: TOL_CONVERGENCE_sp = 1.0e-6_sp+epsilon(1.0_sp) real(kind=dp), public, parameter :: TOL_CONVERGENCE_dp = 1.0e-12_dp+epsilon(1.0_dp) real(kind=qp), public, parameter :: TOL_CONVERGENCE_qp = 1.0e-24_qp+epsilon(1.0_qp) real(kind=sp), public, parameter :: TOL_RESIDUAL_sp = 1.0e-5_sp+epsilon(1.0_sp) real(kind=dp), public, parameter :: TOL_RESIDUAL_dp = 1.0e-10_dp+epsilon(1.0_dp) real(kind=qp), public, parameter :: TOL_RESIDUAL_qp = 1.0e-20_qp+epsilon(1.0_qp) real(kind=sp), public, parameter :: TOL_TEST_sp = 1.0e-4_sp+epsilon(1.0_sp) real(kind=dp), public, parameter :: TOL_TEST_dp = 1.0e-12_dp+epsilon(1.0_dp) real(kind=qp), public, parameter :: TOL_TEST_qp = 1.0e-24_qp+epsilon(1.0_qp) integer, public, parameter :: MAX_ITERATION = 10000","tags":"","url":"module\\nafpack_constant.html"},{"title":"NAFPack_Logger_mod – NAFPack","text":"Uses NAFPack_kinds NAFPack_ANSI NAFPack_terminal module~~nafpack_logger_mod~~UsesGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_ansi NAFPack_ANSI module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_kinds NAFPack_kinds module~nafpack_logger_mod->module~nafpack_kinds module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_ansi->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_kinds->iso_fortran_env module~nafpack_terminal->module~nafpack_ansi module~nafpack_terminal->module~nafpack_kinds module~nafpack_io_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_logger_mod~~UsedByGraph module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( Format_file ), public, parameter :: FORMAT_FILE_BIN = Format_file(0, \"binary\", \"Binary file format\") type( Format_file ), public, parameter :: FORMAT_FILE_TXT = Format_file(1, \"txt\", \"Text file format\") type( Format_file ), public, parameter :: FORMAT_FILE_CSV = Format_file(2, \"csv\", \"Comma-separated values format\") type( Format_file ), public, parameter :: FORMAT_FILE_LOG = Format_file(3, \"log\", \"Log file format\") type( Format_file ), public, parameter :: FORMAT_FILE_TSV = Format_file(4, \"tsv\", \"Tab-separated values format\") type( Format_file ), public, parameter :: FORMAT_FILE_JSON = Format_file(5, \"json\", \"JSON file format\") type( Format_file ), public, parameter :: FORMAT_FILE_XML = Format_file(6, \"xml\", \"XML file format\") type( Format_file ), public, parameter :: FORMAT_FILE_YAML = Format_file(7, \"yaml\", \"YAML file format\") Interfaces public        interface log_field private  subroutine log_field_str(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(len=*), intent(in) :: value private  subroutine log_field_real(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label real(kind=dp), intent(in) :: value private  subroutine log_field_int(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label integer, intent(in) :: value private  subroutine log_field_ucs4(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label character(kind=ucs4, len=*), intent(in) :: value private  subroutine log_field_logical(verbose, label, value) Arguments Type Intent Optional Attributes Name type( Logger ), intent(inout) :: verbose character(len=*), intent(in) :: label logical, intent(in) :: value Derived Types type, public :: Format_file Components Type Visibility Attributes Name Initial integer, public :: id = 1 character(len=10), public :: format_name = \"txt\" character(len=100), public :: format_description = \"Text file format\" type, public :: Logger Components Type Visibility Attributes Name Initial integer, public :: verbosity_level = 1 logical, public :: to_terminal = .true. logical, public :: to_file = .false. integer, public :: frequency = 10 character(len=100), public :: filename = \"Log\" type( Format_file ), public :: file_format = FORMAT_FILE_LOG integer, public :: file_unit = 99 character(len=100), public :: message = \"Default log message\" logical, public :: show_Logger_initialization = .true. logical, public :: show_matrix_test = .true. logical, public :: show_info_solver = .true. logical, public :: show_iteration = .true. logical, public :: show_final = .true. Type-Bound Procedures procedure, public :: init => init_logger procedure, public :: log_info procedure, public :: log_detail procedure, public :: log_warning procedure, public :: log_error procedure, public :: log_time procedure, public :: write => write_output procedure, public :: close => close_logger Functions public  function center_with_fill (text, width, fill_char) result(centered_text) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text integer, intent(in) :: width character(len=1), intent(in), optional :: fill_char Return Value character(kind=ucs4, len=width)","tags":"","url":"module\\nafpack_logger_mod.html"},{"title":"NAFPack_Krylov_method – NAFPack","text":"Uses NAFPack_kinds NAFPack_matricielle module~~nafpack_krylov_method~~UsesGraph module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_kinds NAFPack_kinds module~nafpack_krylov_method->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_krylov_method->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_krylov_method.html"},{"title":"NAFPack_kinds – NAFPack","text":"Uses iso_fortran_env module~~nafpack_kinds~~UsesGraph module~nafpack_kinds NAFPack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_kinds~~UsedByGraph module~nafpack_kinds NAFPack_kinds module~nafpack_ansi NAFPack_ANSI module~nafpack_ansi->module~nafpack_kinds module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_constant NAFPack_constant module~nafpack_constant->module~nafpack_kinds module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_kinds module~nafpack_direct_method->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_direct_method->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_direct_method->module~nafpack_matrix_decomposition module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_eigen NAFPack_Eigen module~nafpack_eigen->module~nafpack_kinds module~nafpack_eigen->module~nafpack_constant module~nafpack_eigen->module~nafpack_matricielle module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_fft NAFPack_fft module~nafpack_fft->module~nafpack_kinds module~nafpack_fft->module~nafpack_constant module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_io_utils->module~nafpack_kinds module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_kinds module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_methods->module~nafpack_iterative_types module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_iterative_methods->module~nafpack_matrix_decomposition module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params->module~nafpack_kinds module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_kinds module~nafpack_krylov_method NAFPack_Krylov_method module~nafpack_krylov_method->module~nafpack_kinds module~nafpack_krylov_method->module~nafpack_matricielle module~nafpack_logger_mod->module~nafpack_kinds module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_math_utils->module~nafpack_kinds module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_matrix_market NAFPack_matrix_market module~nafpack_matrix_market->module~nafpack_kinds module~nafpack_matrix_properties->module~nafpack_kinds module~nafpack_matrix_properties->module~nafpack_constant module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_matrix_properties->module~nafpack_matricielle module~nafpack_matrix_tools->module~nafpack_kinds module~nafpack_matrix_tools->module~nafpack_matricielle module~nafpack_memory_management NAFPack_memory_management module~nafpack_memory_management->module~nafpack_kinds module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_terminal->module~nafpack_kinds module~nafpack_terminal->module~nafpack_ansi module~nafpack_ansi_ascii NAFPack_ANSI_ASCII module~nafpack_ansi_ascii->module~nafpack_ansi module~nafpack_ansi_ucs4 NAFPack_ANSI_ucs4 module~nafpack_ansi_ucs4->module~nafpack_ansi module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params module~nafpack_linalg->module~nafpack_iterative_types module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_memory_management_complex NAFPack_memory_management_complex module~nafpack_memory_management_complex->module~nafpack_memory_management module~nafpack_memory_management_integer NAFPack_memory_management_integer module~nafpack_memory_management_integer->module~nafpack_memory_management module~nafpack_memory_management_real NAFPack_memory_management_real module~nafpack_memory_management_real->module~nafpack_memory_management module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid_complex_2d->module~nafpack_meshgrid module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid_complex_3d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid_integer_2d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid_integer_3d->module~nafpack_meshgrid module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid_real_2d->module~nafpack_meshgrid module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid_real_3d->module~nafpack_meshgrid module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft module~nafpack_meshgrid_complex_2d_compute NAFPack_meshgrid_complex_2D_compute module~nafpack_meshgrid_complex_2d_compute->module~nafpack_meshgrid_complex_2d module~nafpack_meshgrid_complex_3d_compute NAFPack_meshgrid_complex_3D_compute module~nafpack_meshgrid_complex_3d_compute->module~nafpack_meshgrid_complex_3d module~nafpack_meshgrid_integer_2d_compute NAFPack_meshgrid_integer_2D_compute module~nafpack_meshgrid_integer_2d_compute->module~nafpack_meshgrid_integer_2d module~nafpack_meshgrid_integer_3d_compute NAFPack_meshgrid_integer_3D_compute module~nafpack_meshgrid_integer_3d_compute->module~nafpack_meshgrid_integer_3d module~nafpack_meshgrid_real_2d_compute NAFPack_meshgrid_real_2D_compute module~nafpack_meshgrid_real_2d_compute->module~nafpack_meshgrid_real_2d module~nafpack_meshgrid_real_3d_compute NAFPack_meshgrid_real_3D_compute module~nafpack_meshgrid_real_3d_compute->module~nafpack_meshgrid_real_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ascii = selected_char_kind('ascii') integer, public, parameter :: ucs4 = selected_char_kind('ISO_10646') integer, public, parameter :: sp = real32 integer, public, parameter :: dp = real64 integer, public, parameter :: qp = real128 integer, public, parameter :: i8 = int8 integer, public, parameter :: i16 = int16 integer, public, parameter :: isp = int32 integer, public, parameter :: idp = int64","tags":"","url":"module\\nafpack_kinds.html"},{"title":"NAFPack_Direct_types – NAFPack","text":"Used by module~~nafpack_direct_types~~UsedByGraph module~nafpack_direct_types NAFPack_Direct_types module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_direct_types module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_types module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodTypeDirect ), public, parameter :: METHOD_DIRECT_NONE = MethodTypeDirect(0, \"None\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss = MethodTypeDirect(1, \"Gauss\") type( MethodTypeDirect ), public, parameter :: METHOD_Gauss_JORDAN = MethodTypeDirect(2, \"Gauss-Jordan\") type( MethodTypeDirect ), public, parameter :: METHOD_LU = MethodTypeDirect(3, \"LU\") type( MethodTypeDirect ), public, parameter :: METHOD_LDU = MethodTypeDirect(4, \"LDU\") type( MethodTypeDirect ), public, parameter :: METHOD_CHOLESKY = MethodTypeDirect(5, \"Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_LDL_Cholesky = MethodTypeDirect(6, \"LDL-Cholesky\") type( MethodTypeDirect ), public, parameter :: METHOD_QR = MethodTypeDirect(7, \"QR\") type( MethodTypeDirect ), public, parameter :: METHOD_TDMA = MethodTypeDirect(8, \"TDMA\") type( MethodTypeDirect ), public, parameter :: METHOD_FADDEEV_LEVERRIER = MethodTypeDirect(9, \"Faddeev-Leverrier\") type( MethodQR ), public, parameter :: QR_HOUSEHOLDER = MethodQR(1, \"Householder\") type( MethodQR ), public, parameter :: QR_GIVENS = MethodQR(2, \"Givens\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT = MethodQR(3, \"Gram-Schmidt\") type( MethodQR ), public, parameter :: QR_GRAM_SCHMIDT_Modified = MethodQR(4, \"Gram-Schmidt_Modified\") Derived Types type, public :: MethodTypeDirect Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: MethodQR Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: DirectMethodRequirements Components Type Visibility Attributes Name Initial logical, public :: needs_SPD = .false. logical, public :: needs_non_zero_diag = .false. logical, public :: needs_square = .false. logical, public :: needs_tridiagonal = .false. logical, public :: needs_symmetric = .false.","tags":"","url":"module\\nafpack_direct_types.html"},{"title":"NAFPack_Eigen – NAFPack","text":"Module for eigenvalue and eigenvector computations in NAFPack Uses NAFPack_matricielle NAFPack_kinds NAFPack_matrix_decomposition NAFPack_constant module~~nafpack_eigen~~UsesGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_constant NAFPack_constant module~nafpack_eigen->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_eigen->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_eigen->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_eigen->module~nafpack_matrix_decomposition module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_eigen~~UsedByGraph module~nafpack_eigen NAFPack_Eigen module~nafpack_matrix_properties NAFPack_matrix_properties module~nafpack_matrix_properties->module~nafpack_eigen module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_properties module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_matrix_properties module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Eigen (A, lambda, vp, method, k) Computes the eigenvalues and eigenvectors of a matrix A with A a square matrix, λ the eigenvalue, and v the eigenvector.\nThis subroutine allows you to choose the method for computing eigenvalues and eigenvectors: Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:) :: lambda real(kind=dp), intent(out), optional, dimension(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"module\\nafpack_eigen.html"},{"title":"NAFPack_matrix_tools – NAFPack","text":"Uses NAFPack_kinds NAFPack_matricielle module~~nafpack_matrix_tools~~UsesGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_kinds NAFPack_kinds module~nafpack_matrix_tools->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_tools->module~nafpack_matricielle iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_matrix_tools~~UsedByGraph module~nafpack_matrix_tools NAFPack_matrix_tools module~nafpack_direct_method NAFPack_Direct_method module~nafpack_direct_method->module~nafpack_matrix_tools module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_direct_method Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine Faddeev_Leverrier (A, c, Ainv, success, check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:) :: c real(kind=dp), intent(out), optional, dimension(size(A, 1), size(A, 1)) :: Ainv logical, intent(out), optional :: success logical, intent(in), optional :: check","tags":"","url":"module\\nafpack_matrix_tools.html"},{"title":"NAFPack_meshgrid – NAFPack","text":"Module for creating a meshgrid from two vectors This module provides a subroutine to create a meshgrid. Uses NAFPack_kinds NAFPack_loop_method module~~nafpack_meshgrid~~UsesGraph module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_complex_2D NAFPack_meshgrid_complex_3D NAFPack_meshgrid_integer_2D NAFPack_meshgrid_integer_3D NAFPack_meshgrid_real_2D NAFPack_meshgrid_real_3D module~~nafpack_meshgrid~~UsedByGraph module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid_complex_2d->module~nafpack_meshgrid module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid_complex_3d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid_integer_2d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid_integer_3d->module~nafpack_meshgrid module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid_real_2d->module~nafpack_meshgrid module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid_real_3d->module~nafpack_meshgrid module~nafpack_meshgrid_complex_2d_compute NAFPack_meshgrid_complex_2D_compute module~nafpack_meshgrid_complex_2d_compute->module~nafpack_meshgrid_complex_2d module~nafpack_meshgrid_complex_3d_compute NAFPack_meshgrid_complex_3D_compute module~nafpack_meshgrid_complex_3d_compute->module~nafpack_meshgrid_complex_3d module~nafpack_meshgrid_integer_2d_compute NAFPack_meshgrid_integer_2D_compute module~nafpack_meshgrid_integer_2d_compute->module~nafpack_meshgrid_integer_2d module~nafpack_meshgrid_integer_3d_compute NAFPack_meshgrid_integer_3D_compute module~nafpack_meshgrid_integer_3d_compute->module~nafpack_meshgrid_integer_3d module~nafpack_meshgrid_real_2d_compute NAFPack_meshgrid_real_2D_compute module~nafpack_meshgrid_real_2d_compute->module~nafpack_meshgrid_real_2d module~nafpack_meshgrid_real_3d_compute NAFPack_meshgrid_real_3D_compute module~nafpack_meshgrid_real_3d_compute->module~nafpack_meshgrid_real_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(meshgrid_indexing), public, parameter :: INDEXING_XY = meshgrid_indexing(1, \"XY\") type(meshgrid_indexing), public, parameter :: INDEXING_IJ = meshgrid_indexing(2, \"IJ\") Interfaces public        interface meshgrid Make N-dimensional meshgrid from two vectors x_vector and y_vector private  interface meshgrid_real_sp_2D() Arguments None private  interface meshgrid_real_dp_2D() Arguments None private  interface meshgrid_real_qp_2D() Arguments None private  interface meshgrid_real_sp_3D() Arguments None private  interface meshgrid_real_dp_3D() Arguments None private  interface meshgrid_real_qp_3D() Arguments None private  interface meshgrid_integer_i8_2D() Arguments None private  interface meshgrid_integer_i16_2D() Arguments None private  interface meshgrid_integer_isp_2D() Arguments None private  interface meshgrid_integer_idp_2D() Arguments None private  interface meshgrid_integer_i8_3D() Arguments None private  interface meshgrid_integer_i16_3D() Arguments None private  interface meshgrid_integer_isp_3D() Arguments None private  interface meshgrid_integer_idp_3D() Arguments None private  interface meshgrid_cmplx_sp_2D() Arguments None private  interface meshgrid_cmplx_dp_2D() Arguments None private  interface meshgrid_cmplx_qp_2D() Arguments None private  interface meshgrid_cmplx_sp_3D() Arguments None private  interface meshgrid_cmplx_dp_3D() Arguments None private  interface meshgrid_cmplx_qp_3D() Arguments None Subroutines public  subroutine check_indexing (indexing, strict_mode, use_ij_indexing, use_xy_indexing) Arguments Type Intent Optional Attributes Name type(meshgrid_indexing), intent(in), optional :: indexing logical, intent(in), optional :: strict_mode logical, intent(out) :: use_ij_indexing logical, intent(out) :: use_xy_indexing","tags":"","url":"module\\nafpack_meshgrid.html"},{"title":"NAFPack_ANSI – NAFPack","text":"Uses NAFPack_kinds NAFPack_io_utils iso_fortran_env module~~nafpack_ansi~~UsesGraph module~nafpack_ansi NAFPack_ANSI iso_fortran_env iso_fortran_env module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_kinds NAFPack_kinds module~nafpack_ansi->module~nafpack_kinds module~nafpack_io_utils->module~nafpack_kinds module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_ANSI_ASCII NAFPack_ANSI_ucs4 module~~nafpack_ansi~~UsedByGraph module~nafpack_ansi NAFPack_ANSI module~nafpack_ansi_ascii NAFPack_ANSI_ASCII module~nafpack_ansi_ascii->module~nafpack_ansi module~nafpack_ansi_ucs4 NAFPack_ANSI_ucs4 module~nafpack_ansi_ucs4->module~nafpack_ansi module~nafpack_logger_mod NAFPack_Logger_mod module~nafpack_logger_mod->module~nafpack_ansi module~nafpack_terminal NAFPack_terminal module~nafpack_logger_mod->module~nafpack_terminal module~nafpack_terminal->module~nafpack_ansi module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_logger_mod module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(AnsiConstants), public, parameter :: Ansi_Constants = AnsiConstants() Interfaces interface public pure module function create_ansi_ascii(ansi_code) result(ansi_string) Arguments Type Intent Optional Attributes Name type( AnsiCode ), intent(in) :: ansi_code Return Value character(kind=ascii, len=:), allocatable interface public pure module function apply_style_ascii(text, style) result(styled_text) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: text type( AnsiCode ), intent(in) :: style Return Value character(kind=ascii, len=:), allocatable interface public pure module function colorize_text_ascii(text, color) result(colored_text) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: text integer(kind=i16), intent(in) :: color Return Value character(kind=ascii, len=:), allocatable interface public module subroutine cursor_position_ascii(row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: row integer, intent(in) :: col interface public module subroutine clear_screen_ascii() Arguments None interface public module subroutine clear_line_ascii() Arguments None interface public module subroutine save_cursor_ascii() Arguments None interface public module subroutine restore_cursor_ascii() Arguments None interface public pure module function create_ansi_ucs4(ansi_code) result(ansi_string) Arguments Type Intent Optional Attributes Name type( AnsiCode ), intent(in) :: ansi_code Return Value character(kind=ucs4, len=:), allocatable interface public pure module function apply_style_ucs4(text, style) result(styled_text) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: text type( AnsiCode ), intent(in) :: style Return Value character(kind=ucs4, len=:), allocatable interface public pure module function colorize_text_ucs4(text, color) result(colored_text) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: text integer(kind=i16), intent(in) :: color Return Value character(kind=ucs4, len=:), allocatable interface public module subroutine cursor_position_ucs4(row, col) Arguments Type Intent Optional Attributes Name integer, intent(in) :: row integer, intent(in) :: col interface public module subroutine clear_screen_ucs4() Arguments None interface public module subroutine clear_line_ucs4() Arguments None interface public module subroutine save_cursor_ucs4() Arguments None interface public module subroutine restore_cursor_ucs4() Arguments None Derived Types type, public :: AnsiCode type, public :: ColorsAscii Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: reset character(len=:), public, allocatable :: bold character(len=:), public, allocatable :: faint character(len=:), public, allocatable :: italic character(len=:), public, allocatable :: underline character(len=:), public, allocatable :: blink character(len=:), public, allocatable :: reverse character(len=:), public, allocatable :: hidden character(len=:), public, allocatable :: strikethrough character(len=:), public, allocatable :: red character(len=:), public, allocatable :: green character(len=:), public, allocatable :: yellow character(len=:), public, allocatable :: blue character(len=:), public, allocatable :: magenta character(len=:), public, allocatable :: cyan character(len=:), public, allocatable :: white character(len=:), public, allocatable :: bright_red character(len=:), public, allocatable :: bright_green character(len=:), public, allocatable :: bright_yellow character(len=:), public, allocatable :: bright_blue character(len=:), public, allocatable :: bright_magenta character(len=:), public, allocatable :: bright_cyan character(len=:), public, allocatable :: bright_white Type-Bound Procedures procedure, public :: init => init_colors_ascii type, public :: ColorsUcs4 Components Type Visibility Attributes Name Initial character(kind=ucs4, len=:), public, allocatable :: reset character(kind=ucs4, len=:), public, allocatable :: bold character(kind=ucs4, len=:), public, allocatable :: faint character(kind=ucs4, len=:), public, allocatable :: italic character(kind=ucs4, len=:), public, allocatable :: underline character(kind=ucs4, len=:), public, allocatable :: blink character(kind=ucs4, len=:), public, allocatable :: reverse character(kind=ucs4, len=:), public, allocatable :: hidden character(kind=ucs4, len=:), public, allocatable :: strikethrough character(kind=ucs4, len=:), public, allocatable :: red character(kind=ucs4, len=:), public, allocatable :: green character(kind=ucs4, len=:), public, allocatable :: yellow character(kind=ucs4, len=:), public, allocatable :: blue character(kind=ucs4, len=:), public, allocatable :: magenta character(kind=ucs4, len=:), public, allocatable :: cyan character(kind=ucs4, len=:), public, allocatable :: white character(kind=ucs4, len=:), public, allocatable :: bright_red character(kind=ucs4, len=:), public, allocatable :: bright_green character(kind=ucs4, len=:), public, allocatable :: bright_yellow character(kind=ucs4, len=:), public, allocatable :: bright_blue character(kind=ucs4, len=:), public, allocatable :: bright_magenta character(kind=ucs4, len=:), public, allocatable :: bright_cyan character(kind=ucs4, len=:), public, allocatable :: bright_white Type-Bound Procedures procedure, public :: init => init_colors_ucs4 Functions public pure module function set_ansi_code (style, fg_color, bg_color) result(ansi_code) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in), optional :: style integer(kind=i16), intent(in), optional :: fg_color integer(kind=i16), intent(in), optional :: bg_color Return Value type( AnsiCode ) public pure module function reset_ansi_code () result(ansi_code) Arguments None Return Value type( AnsiCode )","tags":"","url":"module\\nafpack_ansi.html"},{"title":"NAFPack_loop_method – NAFPack","text":"Used by module~~nafpack_loop_method~~UsedByGraph module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid->module~nafpack_loop_method module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid_complex_2d->module~nafpack_meshgrid module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid_complex_3d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid_integer_2d->module~nafpack_meshgrid module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid_integer_3d->module~nafpack_meshgrid module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid_real_2d->module~nafpack_meshgrid module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid_real_3d->module~nafpack_meshgrid module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft module~nafpack_meshgrid_complex_2d_compute NAFPack_meshgrid_complex_2D_compute module~nafpack_meshgrid_complex_2d_compute->module~nafpack_meshgrid_complex_2d module~nafpack_meshgrid_complex_3d_compute NAFPack_meshgrid_complex_3D_compute module~nafpack_meshgrid_complex_3d_compute->module~nafpack_meshgrid_complex_3d module~nafpack_meshgrid_integer_2d_compute NAFPack_meshgrid_integer_2D_compute module~nafpack_meshgrid_integer_2d_compute->module~nafpack_meshgrid_integer_2d module~nafpack_meshgrid_integer_3d_compute NAFPack_meshgrid_integer_3D_compute module~nafpack_meshgrid_integer_3d_compute->module~nafpack_meshgrid_integer_3d module~nafpack_meshgrid_real_2d_compute NAFPack_meshgrid_real_2D_compute module~nafpack_meshgrid_real_2d_compute->module~nafpack_meshgrid_real_2d module~nafpack_meshgrid_real_3d_compute NAFPack_meshgrid_real_3D_compute module~nafpack_meshgrid_real_3d_compute->module~nafpack_meshgrid_real_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( LoopMethod ), public, parameter :: default_loop_method = LoopMethod(use_do_classic=.true.) Derived Types type, public :: LoopMethod Components Type Visibility Attributes Name Initial logical, public :: use_do_classic = .false. logical, public :: use_vectorized = .false. logical, public :: use_do_concurrent = .false. type(ParallelMethod), public :: parallel Functions public pure function init_loop_method (use_do_classic, use_vectorized, use_do_concurrent, use_openmp, use_mpi, num_threads) result(loop_method) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: use_do_classic logical, intent(in), optional :: use_vectorized logical, intent(in), optional :: use_do_concurrent logical, intent(in), optional :: use_openmp logical, intent(in), optional :: use_mpi integer, intent(in), optional :: num_threads Return Value type( LoopMethod ) public pure function count_true_methods (loop_method) result(count_true) Arguments Type Intent Optional Attributes Name type( LoopMethod ), intent(in) :: loop_method Return Value integer public  function check_loop_method (loop_method) result(loop_method_used) Arguments Type Intent Optional Attributes Name type( LoopMethod ), intent(in) :: loop_method Return Value type( LoopMethod )","tags":"","url":"module\\nafpack_loop_method.html"},{"title":"NAFPack_Preconditioners – NAFPack","text":"Uses NAFPack_kinds NAFPack_matrix_decomposition NAFPack_matricielle NAFPack_constant module~~nafpack_preconditioners~~UsesGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_constant NAFPack_constant module~nafpack_preconditioners->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_preconditioners->module~nafpack_kinds module~nafpack_matricielle NAFPack_matricielle module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matricielle->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_matrix_decomposition->module~nafpack_matricielle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_preconditioners~~UsedByGraph module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_preconditioners module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_preconditioners module~nafpack_linalg->module~nafpack_iterative_methods module~nafpack_linalg->module~nafpack_iterative_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_NONE = MethodPreconditioner(0, \"None\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JACOBI = MethodPreconditioner(1, \"Jacobi\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_GS = MethodPreconditioner(2, \"Gauss-Seidel\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SOR = MethodPreconditioner(3, \"Successive Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_JOR = MethodPreconditioner(4, \"Jacobi Over-Relaxation\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ILU = MethodPreconditioner(5, \"ILU\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_ICF = MethodPreconditioner(6, \"ICF\") type( MethodPreconditioner ), public, parameter :: METHOD_PRECOND_SSOR = MethodPreconditioner(7, \"SSOR\") type( Fill_level_used ), public, parameter :: FILL_LEVEL_NONE = Fill_level_used(-1, \"None\", -huge(1)) type( Fill_level_used ), public, parameter :: FILL_LEVEL_0 = Fill_level_used(0, \"Level 0\", 0) type( Fill_level_used ), public, parameter :: FILL_LEVEL_1 = Fill_level_used(1, \"Level 1\", 1) type( Fill_level_used ), public, parameter :: FILL_LEVEL_2 = Fill_level_used(2, \"Level 2\", 2) type( Fill_level_used ), public, parameter :: FILL_LEVEL_3 = Fill_level_used(3, \"Level 3\", 3) type( Fill_level_used ), public :: FILL_LEVEL_N = Fill_level_used(3, \"Level N\", 0) Derived Types type, public :: MethodPreconditioner Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name type, public :: Fill_level_used Components Type Visibility Attributes Name Initial integer, public :: id character(len=64), public :: name integer, public :: value Functions public  function Calculate_Jacobi_preconditioner (A) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) public  function Calculate_Gauss_Seidel_preconditioner (A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) public  function Calculate_SOR_preconditioner (A, omega, alpha) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) public  function Calculate_JOR_preconditioner (A, omega, alpha) result(D) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) public  function Calculate_ICF_preconditioner (A, omega, alpha, fill_level) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level Return Value real(kind=dp), dimension(size(A, 1), size(A, 2)) Subroutines public  subroutine Calculate_ILU_preconditioner (A, L, U, omega, alpha, fill_level) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: U real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha integer, intent(in), optional :: fill_level public  subroutine Calculate_SSOR_preconditioner (A, L, D, omega, alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: L real(kind=dp), intent(out), dimension(size(A, 1), size(A, 2)) :: D real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: alpha","tags":"","url":"module\\nafpack_preconditioners.html"},{"title":"NAFPack_Iterative_Params – NAFPack","text":"Uses NAFPack_kinds NAFPack_matrix_decomposition NAFPack_Iterative_types NAFPack_Preconditioners module~~nafpack_iterative_params~~UsesGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_types NAFPack_Iterative_types module~nafpack_iterative_params->module~nafpack_iterative_types module~nafpack_kinds NAFPack_kinds module~nafpack_iterative_params->module~nafpack_kinds module~nafpack_matrix_decomposition NAFPack_matrix_decomposition module~nafpack_iterative_params->module~nafpack_matrix_decomposition module~nafpack_preconditioners NAFPack_Preconditioners module~nafpack_iterative_params->module~nafpack_preconditioners module~nafpack_iterative_types->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_matrix_decomposition->module~nafpack_kinds module~nafpack_constant NAFPack_constant module~nafpack_matrix_decomposition->module~nafpack_constant module~nafpack_matricielle NAFPack_matricielle module~nafpack_matrix_decomposition->module~nafpack_matricielle module~nafpack_preconditioners->module~nafpack_kinds module~nafpack_preconditioners->module~nafpack_matrix_decomposition module~nafpack_preconditioners->module~nafpack_constant module~nafpack_preconditioners->module~nafpack_matricielle module~nafpack_constant->module~nafpack_kinds module~nafpack_matricielle->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~nafpack_iterative_params~~UsedByGraph module~nafpack_iterative_params NAFPack_Iterative_Params module~nafpack_iterative_methods NAFPack_Iterative_methods module~nafpack_iterative_methods->module~nafpack_iterative_params module~nafpack_linalg NAFPack_linalg module~nafpack_linalg->module~nafpack_iterative_params module~nafpack_linalg->module~nafpack_iterative_methods Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: IterativeParams Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(:), allocatable :: x_init real(kind=dp), public, dimension(:, :), allocatable :: L real(kind=dp), public, dimension(:, :), allocatable :: U real(kind=dp), public, dimension(:, :), allocatable :: D real(kind=dp), public, dimension(:), allocatable :: p real(kind=dp), public, dimension(:), allocatable :: residual real(kind=dp), public :: norm_residual real(kind=dp), public :: norm_initial_residual = 1.d0 real(kind=dp), public :: tol = 1.0d-12 integer, public :: k = 0 integer, public :: max_iter = 1000 real(kind=dp), public :: omega = 1.d0 real(kind=dp), public :: alpha = 1.d0 real(kind=dp), public :: beta = 1.d0 type( Fill_level_used ), public :: fill_level = FILL_LEVEL_NONE logical, public :: is_stationary = .true. logical, public :: strict_mode = .false. real(kind=dp), public :: old_dot_product = 0.d0 type( Norm_used ), public :: norm = NORM_2 procedure( ApplyPreconditioner ), public, pass(params), pointer :: precond Type-Bound Procedures procedure, public :: norm_function Functions public  function ApplyPreconditioner (params, method, x) result(y) Arguments Type Intent Optional Attributes Name class( IterativeParams ), intent(in) :: params class( MethodPreconditioner ), intent(in) :: method real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp), dimension(size(params%x_init))","tags":"","url":"module\\nafpack_iterative_params.html"},{"title":"NAFPack_meshgrid_integer_3D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_integer_3d~~UsesGraph module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_integer_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_integer_3D_compute module~~nafpack_meshgrid_integer_3d~~UsedByGraph module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid_integer_3d_compute NAFPack_meshgrid_integer_3D_compute module~nafpack_meshgrid_integer_3d_compute->module~nafpack_meshgrid_integer_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_integer_3d.html"},{"title":"NAFPack_meshgrid_real_2D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_real_2d~~UsesGraph module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_real_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_real_2D_compute module~~nafpack_meshgrid_real_2d~~UsedByGraph module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid_real_2d_compute NAFPack_meshgrid_real_2D_compute module~nafpack_meshgrid_real_2d_compute->module~nafpack_meshgrid_real_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_real_2d.html"},{"title":"NAFPack_Fourier_Transform_dft_compute – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_dft module~~nafpack_fourier_transform_dft_compute~~UsesGraph module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_dft_compute.html"},{"title":"NAFPack_ANSI_ASCII – NAFPack","text":"Uses Ancestors: NAFPack_ANSI module~~nafpack_ansi_ascii~~UsesGraph module~nafpack_ansi_ascii NAFPack_ANSI_ASCII module~nafpack_ansi NAFPack_ANSI module~nafpack_ansi_ascii->module~nafpack_ansi iso_fortran_env iso_fortran_env module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_kinds NAFPack_kinds module~nafpack_ansi->module~nafpack_kinds module~nafpack_io_utils->module~nafpack_kinds module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_ansi_ascii.html"},{"title":"NAFPack_Fourier_Transform_fft – NAFPack","text":"Uses NAFPack_memory_management Ancestors: NAFPack_Fourier_Transform module~~nafpack_fourier_transform_fft~~UsesGraph module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_memory_management NAFPack_memory_management module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_memory_management->module~nafpack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_Fourier_Transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_split_radix module~~nafpack_fourier_transform_fft~~UsedByGraph module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_fft.html"},{"title":"NAFPack_Fourier_Transform_dft3 – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform module~~nafpack_fourier_transform_dft3~~UsesGraph module~nafpack_fourier_transform_dft3 NAFPack_Fourier_Transform_dft3 module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_dft3->module~nafpack_fourier_transform module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_dft3.html"},{"title":"NAFPack_Fourier_Transform_dft – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform module~~nafpack_fourier_transform_dft~~UsesGraph module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_dft->module~nafpack_fourier_transform module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_Fourier_Transform_dft_compute module~~nafpack_fourier_transform_dft~~UsedByGraph module~nafpack_fourier_transform_dft NAFPack_Fourier_Transform_dft module~nafpack_fourier_transform_dft_compute NAFPack_Fourier_Transform_dft_compute module~nafpack_fourier_transform_dft_compute->module~nafpack_fourier_transform_dft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_dft.html"},{"title":"NAFPack_meshgrid_complex_2D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_complex_2d~~UsesGraph module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_complex_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_complex_2D_compute module~~nafpack_meshgrid_complex_2d~~UsedByGraph module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid_complex_2d_compute NAFPack_meshgrid_complex_2D_compute module~nafpack_meshgrid_complex_2d_compute->module~nafpack_meshgrid_complex_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_complex_2d.html"},{"title":"NAFPack_meshgrid_real_3D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_real_3d~~UsesGraph module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_real_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_real_3D_compute module~~nafpack_meshgrid_real_3d~~UsedByGraph module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid_real_3d_compute NAFPack_meshgrid_real_3D_compute module~nafpack_meshgrid_real_3d_compute->module~nafpack_meshgrid_real_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_real_3d.html"},{"title":"NAFPack_ANSI_ucs4 – NAFPack","text":"Uses Ancestors: NAFPack_ANSI module~~nafpack_ansi_ucs4~~UsesGraph module~nafpack_ansi_ucs4 NAFPack_ANSI_ucs4 module~nafpack_ansi NAFPack_ANSI module~nafpack_ansi_ucs4->module~nafpack_ansi iso_fortran_env iso_fortran_env module~nafpack_ansi->iso_fortran_env module~nafpack_io_utils NAFPack_io_utils module~nafpack_ansi->module~nafpack_io_utils module~nafpack_kinds NAFPack_kinds module~nafpack_ansi->module~nafpack_kinds module~nafpack_io_utils->module~nafpack_kinds module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_ansi_ucs4.html"},{"title":"NAFPack_meshgrid_complex_3D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_complex_3d~~UsesGraph module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_complex_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_complex_3D_compute module~~nafpack_meshgrid_complex_3d~~UsedByGraph module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid_complex_3d_compute NAFPack_meshgrid_complex_3D_compute module~nafpack_meshgrid_complex_3d_compute->module~nafpack_meshgrid_complex_3d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_complex_3d.html"},{"title":"NAFPack_memory_management_integer – NAFPack","text":"Uses Ancestors: NAFPack_memory_management module~~nafpack_memory_management_integer~~UsesGraph module~nafpack_memory_management_integer NAFPack_memory_management_integer module~nafpack_memory_management NAFPack_memory_management module~nafpack_memory_management_integer->module~nafpack_memory_management module~nafpack_kinds NAFPack_kinds module~nafpack_memory_management->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_memory_management_integer.html"},{"title":"NAFPack_meshgrid_real_3D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_real_3D module~~nafpack_meshgrid_real_3d_compute~~UsesGraph module~nafpack_meshgrid_real_3d_compute NAFPack_meshgrid_real_3D_compute module~nafpack_meshgrid_real_3d NAFPack_meshgrid_real_3D module~nafpack_meshgrid_real_3d_compute->module~nafpack_meshgrid_real_3d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_real_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_real_3d_compute.html"},{"title":"NAFPack_meshgrid_integer_3D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_integer_3D module~~nafpack_meshgrid_integer_3d_compute~~UsesGraph module~nafpack_meshgrid_integer_3d_compute NAFPack_meshgrid_integer_3D_compute module~nafpack_meshgrid_integer_3d NAFPack_meshgrid_integer_3D module~nafpack_meshgrid_integer_3d_compute->module~nafpack_meshgrid_integer_3d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_integer_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_integer_3d_compute.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_split_radix – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft module~~nafpack_fourier_transform_fft_compute_split_radix~~UsesGraph module~nafpack_fourier_transform_fft_compute_split_radix NAFPack_Fourier_Transform_fft_compute_split_radix module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft_compute_split_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_memory_management NAFPack_memory_management module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_memory_management->module~nafpack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_fft_compute_split_radix.html"},{"title":"NAFPack_Fourier_Transform_dft2 – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform module~~nafpack_fourier_transform_dft2~~UsesGraph module~nafpack_fourier_transform_dft2 NAFPack_Fourier_Transform_dft2 module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_dft2->module~nafpack_fourier_transform module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_dft2.html"},{"title":"NAFPack_memory_management_real – NAFPack","text":"Uses Ancestors: NAFPack_memory_management module~~nafpack_memory_management_real~~UsesGraph module~nafpack_memory_management_real NAFPack_memory_management_real module~nafpack_memory_management NAFPack_memory_management module~nafpack_memory_management_real->module~nafpack_memory_management module~nafpack_kinds NAFPack_kinds module~nafpack_memory_management->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_memory_management_real.html"},{"title":"NAFPack_meshgrid_complex_2D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_complex_2D module~~nafpack_meshgrid_complex_2d_compute~~UsesGraph module~nafpack_meshgrid_complex_2d_compute NAFPack_meshgrid_complex_2D_compute module~nafpack_meshgrid_complex_2d NAFPack_meshgrid_complex_2D module~nafpack_meshgrid_complex_2d_compute->module~nafpack_meshgrid_complex_2d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_complex_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_complex_2d_compute.html"},{"title":"NAFPack_meshgrid_integer_2D – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid module~~nafpack_meshgrid_integer_2d~~UsesGraph module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_integer_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: NAFPack_meshgrid_integer_2D_compute module~~nafpack_meshgrid_integer_2d~~UsedByGraph module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid_integer_2d_compute NAFPack_meshgrid_integer_2D_compute module~nafpack_meshgrid_integer_2d_compute->module~nafpack_meshgrid_integer_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_integer_2d.html"},{"title":"NAFPack_meshgrid_integer_2D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_integer_2D module~~nafpack_meshgrid_integer_2d_compute~~UsesGraph module~nafpack_meshgrid_integer_2d_compute NAFPack_meshgrid_integer_2D_compute module~nafpack_meshgrid_integer_2d NAFPack_meshgrid_integer_2D module~nafpack_meshgrid_integer_2d_compute->module~nafpack_meshgrid_integer_2d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_integer_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_integer_2d_compute.html"},{"title":"NAFPack_meshgrid_complex_3D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_complex_3D module~~nafpack_meshgrid_complex_3d_compute~~UsesGraph module~nafpack_meshgrid_complex_3d_compute NAFPack_meshgrid_complex_3D_compute module~nafpack_meshgrid_complex_3d NAFPack_meshgrid_complex_3D module~nafpack_meshgrid_complex_3d_compute->module~nafpack_meshgrid_complex_3d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_complex_3d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_complex_3d_compute.html"},{"title":"NAFPack_memory_management_complex – NAFPack","text":"Uses Ancestors: NAFPack_memory_management module~~nafpack_memory_management_complex~~UsesGraph module~nafpack_memory_management_complex NAFPack_memory_management_complex module~nafpack_memory_management NAFPack_memory_management module~nafpack_memory_management_complex->module~nafpack_memory_management module~nafpack_kinds NAFPack_kinds module~nafpack_memory_management->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_memory_management_complex.html"},{"title":"NAFPack_meshgrid_real_2D_compute – NAFPack","text":"Uses Ancestors: NAFPack_meshgrid : NAFPack_meshgrid_real_2D module~~nafpack_meshgrid_real_2d_compute~~UsesGraph module~nafpack_meshgrid_real_2d_compute NAFPack_meshgrid_real_2D_compute module~nafpack_meshgrid_real_2d NAFPack_meshgrid_real_2D module~nafpack_meshgrid_real_2d_compute->module~nafpack_meshgrid_real_2d module~nafpack_meshgrid NAFPack_meshgrid module~nafpack_meshgrid_real_2d->module~nafpack_meshgrid module~nafpack_kinds NAFPack_kinds module~nafpack_meshgrid->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_meshgrid->module~nafpack_loop_method iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_meshgrid_real_2d_compute.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_radix2 – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft module~~nafpack_fourier_transform_fft_compute_radix2~~UsesGraph module~nafpack_fourier_transform_fft_compute_radix2 NAFPack_Fourier_Transform_fft_compute_radix2 module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft_compute_radix2->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_memory_management NAFPack_memory_management module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_memory_management->module~nafpack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_fft_compute_radix2.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_mixed_radix – NAFPack","text":"Uses Ancestors: NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft module~~nafpack_fourier_transform_fft_compute_mixed_radix~~UsesGraph module~nafpack_fourier_transform_fft_compute_mixed_radix NAFPack_Fourier_Transform_fft_compute_mixed_radix module~nafpack_fourier_transform_fft NAFPack_Fourier_Transform_fft module~nafpack_fourier_transform_fft_compute_mixed_radix->module~nafpack_fourier_transform_fft module~nafpack_fourier_transform NAFPack_Fourier_Transform module~nafpack_fourier_transform_fft->module~nafpack_fourier_transform module~nafpack_memory_management NAFPack_memory_management module~nafpack_fourier_transform_fft->module~nafpack_memory_management module~nafpack_constant NAFPack_constant module~nafpack_fourier_transform->module~nafpack_constant module~nafpack_kinds NAFPack_kinds module~nafpack_fourier_transform->module~nafpack_kinds module~nafpack_loop_method NAFPack_loop_method module~nafpack_fourier_transform->module~nafpack_loop_method module~nafpack_math_utils NAFPack_math_utils module~nafpack_fourier_transform->module~nafpack_math_utils module~nafpack_memory_management->module~nafpack_kinds module~nafpack_constant->module~nafpack_kinds iso_fortran_env iso_fortran_env module~nafpack_kinds->iso_fortran_env module~nafpack_math_utils->module~nafpack_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module\\nafpack_fourier_transform_fft_compute_mixed_radix.html"},{"title":"NAFPack_meshgrid_integer_3D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_integer_3d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_integer_3d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90 NAFPack_meshgrid_integer_3D_compute.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90->sourcefile~nafpack_meshgrid_integer_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_integer_3D implicit none ( type , external ) interface module subroutine compute_meshgrid_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i8 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_3D_i8 end interface interface module subroutine compute_meshgrid_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i16 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_3D_i16 end interface interface module subroutine compute_meshgrid_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_3D_isp end interface interface module subroutine compute_meshgrid_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( idp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_3D_idp end interface contains module subroutine meshgrid_integer_i8_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i8 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_3D_i8 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_3D_i8 ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_integer_i8_3D module subroutine meshgrid_integer_i16_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i16 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_3D_i16 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_3D_i16 ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_integer_i16_3D module subroutine meshgrid_integer_isp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_3D_isp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_3D_isp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_integer_isp_3D module subroutine meshgrid_integer_idp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( idp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_3D_idp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_3D_idp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_integer_idp_3D end submodule NAFPack_meshgrid_integer_3D","tags":"","url":"sourcefile\\nafpack_meshgrid_integer_3d.f90.html"},{"title":"NAFPack_memory_monitor.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_memory_monitor.f90~~AfferentGraph sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_memory_monitor implicit none ( type , external ) private public :: get_memory_kb interface function get_memory_usage () bind ( C , name = \"get_memory_usage\" ) result ( mem_usage ) use iso_c_binding , only : c_int implicit none ( type , external ) integer ( c_int ) :: mem_usage end function get_memory_usage end interface contains function get_memory_kb () result ( memory_kb ) integer :: memory_kb memory_kb = get_memory_usage () end function get_memory_kb end module NAFPack_memory_monitor","tags":"","url":"sourcefile\\nafpack_memory_monitor.f90.html"},{"title":"NAFPack_meshgrid_real_2D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_real_2d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_real_2d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90 NAFPack_meshgrid_real_2D_compute.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90->sourcefile~nafpack_meshgrid_real_2d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_real_2D implicit none ( type , external ) interface module subroutine compute_meshgrid_real_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_2D_sp end interface interface module subroutine compute_meshgrid_real_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_2D_dp end interface interface module subroutine compute_meshgrid_real_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_2D_qp end interface contains module subroutine meshgrid_real_sp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_2D_sp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_real_sp_2D module subroutine meshgrid_real_dp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_2D_dp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_real_dp_2D module subroutine meshgrid_real_qp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_2D_qp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_real_qp_2D end submodule NAFPack_meshgrid_real_2D","tags":"","url":"sourcefile\\nafpack_meshgrid_real_2d.f90.html"},{"title":"NAFPack_math_utils.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_math_utils.f90~~EfferentGraph sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_math_utils.f90~~AfferentGraph sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_math_utils use NAFPack_kinds , only : sp , isp implicit none ( type , external ) private public :: sieve_of_eratosthenes public :: is_power_of_two , power_of_p_exponent contains pure function sieve_of_eratosthenes ( N ) result ( primes ) integer ( isp ), intent ( in ) :: N integer ( isp ), dimension (:), allocatable :: primes logical , dimension (:), allocatable :: is_prime integer ( isp ) :: i , j , count_primes , limit , idx allocate ( is_prime ( 0 : N )) is_prime = . true . is_prime ( 0 : 1 ) = . false . limit = int ( sqrt ( real ( N , kind = sp ))) do i = 2 , limit if ( is_prime ( i )) then do j = i * i , N , i is_prime ( j ) = . false . end do end if end do count_primes = count ( is_prime ) allocate ( primes ( count_primes )) idx = 1 do i = 2 , N if ( is_prime ( i )) then primes ( idx ) = i idx = idx + 1 end if end do deallocate ( is_prime ) end function sieve_of_eratosthenes pure function is_power_of_two ( N ) result ( value ) integer ( isp ), intent ( in ) :: N logical :: value if ( N < 1 ) then value = . false . else value = ( iand ( N , N - 1 ) == 0 ) end if end function is_power_of_two pure function power_of_p_exponent ( N , p ) result ( exponent ) integer ( isp ), intent ( in ) :: N , p integer ( isp ) :: exponent integer ( isp ) :: tmp exponent = 0 tmp = N do while ( tmp > 1 ) tmp = tmp / p exponent = exponent + 1 end do end function power_of_p_exponent end module NAFPack_math_utils","tags":"","url":"sourcefile\\nafpack_math_utils.f90.html"},{"title":"NAFPack_Fourier_Transform_dft_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_dft_compute.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_dft ) NAFPack_Fourier_Transform_dft_compute implicit none ( type , external ) contains !================================================================================= ! Compute the discrete Fourier transform of a complex signal in simple precision !================================================================================= module function compute_dft_cmplx_sp ( signal , N , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( N ) :: result real ( sp ), dimension ( size ( signal )) :: n_vec complex ( sp ) :: omega integer ( isp ) :: i if ( N == 1 ) then result = signal else omega = exp ( - 2 * pi_sp * im_sp / real ( N , sp )) n_vec = [( real ( i - 1 , sp ), i = 1 , N )] if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_sp ( signal , n_vec , omega , N ) else if ( loop_method % use_vectorized ) then result = compute_do_vectorized_cmplx_sp ( signal , n_vec , omega , N ) else if ( loop_method % use_do_concurrent ) then result = compute_do_concurrent_cmplx_sp ( signal , n_vec , omega , N ) else if ( loop_method % parallel % use_openmp ) then result = compute_openmp_cmplx_sp ( signal , n_vec , omega , N , & loop_method % parallel % num_threads ) end if end if end function compute_dft_cmplx_sp pure function compute_do_classic_cmplx_sp ( signal , n_vector , omega , N ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal real ( sp ), dimension (:), intent ( in ) :: n_vector complex ( sp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( sp ), dimension ( N ) :: result integer ( isp ) :: i , k do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_classic_cmplx_sp pure function compute_do_vectorized_cmplx_sp ( signal , n_vector , omega , N ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal real ( sp ), dimension (:), intent ( in ) :: n_vector complex ( sp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( sp ), dimension ( N ) :: result real ( sp ), dimension ( N ) :: k_vector complex ( sp ), dimension ( N , N ) :: fourier_matrix k_vector = n_vector fourier_matrix = omega ** reshape ( spread ( k_vector , 2 , N ) * spread ( n_vector , 1 , N ), [ N , N ]) result = matmul ( fourier_matrix , signal ) end function compute_do_vectorized_cmplx_sp pure function compute_do_concurrent_cmplx_sp ( signal , n_vector , omega , N ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal real ( sp ), dimension (:), intent ( in ) :: n_vector complex ( sp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( sp ), dimension ( N ) :: result integer ( isp ) :: i , k do concurrent ( i = 1 : N ) k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_concurrent_cmplx_sp function compute_openmp_cmplx_sp ( signal , n_vector , omega , N , threads ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal real ( sp ), dimension (:), intent ( in ) :: n_vector complex ( sp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N , threads complex ( sp ), dimension ( N ) :: result integer ( isp ) :: i , k !$omp parallel do default(none) private(k, i) & !$omp& shared(signal, n_vector, omega, result, N) & !$omp& num_threads(threads) do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do !$omp end parallel do end function compute_openmp_cmplx_sp !================================================================================= ! Compute the discrete Fourier transform of a complex signal in double precision !================================================================================= module function compute_dft_cmplx_dp ( signal , N , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( dp ), dimension ( N ) :: result real ( dp ), dimension ( size ( signal )) :: n_vec complex ( dp ) :: omega integer ( isp ) :: i if ( N == 1 ) then result = signal else omega = exp ( - 2 * pi_dp * im_dp / real ( N , dp )) n_vec = [( real ( i - 1 , dp ), i = 1 , N )] if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_dp ( signal , n_vec , omega , N ) else if ( loop_method % use_vectorized ) then result = compute_do_vectorized_cmplx_dp ( signal , n_vec , omega , N ) else if ( loop_method % use_do_concurrent ) then result = compute_do_concurrent_cmplx_dp ( signal , n_vec , omega , N ) else if ( loop_method % parallel % use_openmp ) then result = compute_openmp_cmplx_dp ( signal , n_vec , omega , N , & loop_method % parallel % num_threads ) end if end if end function compute_dft_cmplx_dp module pure function compute_do_classic_cmplx_dp ( signal , n_vector , omega , N ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal real ( dp ), dimension (:), intent ( in ) :: n_vector complex ( dp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( dp ), dimension ( N ) :: result integer ( isp ) :: i , k do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_classic_cmplx_dp module pure function compute_do_vectorized_cmplx_dp ( signal , n_vector , omega , N ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal real ( dp ), dimension (:), intent ( in ) :: n_vector complex ( dp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( dp ), dimension ( N ) :: result real ( dp ), dimension ( N ) :: k_vector complex ( dp ), dimension ( N , N ) :: fourier_matrix k_vector = n_vector fourier_matrix = omega ** reshape ( spread ( k_vector , 2 , N ) * spread ( n_vector , 1 , N ), [ N , N ]) result = matmul ( fourier_matrix , signal ) end function compute_do_vectorized_cmplx_dp module pure function compute_do_concurrent_cmplx_dp ( signal , n_vector , omega , N ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal real ( dp ), dimension (:), intent ( in ) :: n_vector complex ( dp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( dp ), dimension ( N ) :: result integer ( isp ) :: i , k do concurrent ( i = 1 : N ) k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_concurrent_cmplx_dp module function compute_openmp_cmplx_dp ( signal , n_vector , omega , N , threads ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal real ( dp ), dimension (:), intent ( in ) :: n_vector complex ( dp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N , threads complex ( dp ), dimension ( N ) :: result integer ( isp ) :: i , k !$omp parallel do default(none) private(k, i) & !$omp& shared(signal, n_vector, omega, result, N) & !$omp& num_threads(threads) do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do !$omp end parallel do end function compute_openmp_cmplx_dp !================================================================================= ! Compute the discrete Fourier transform of a complex signal in quadruple precision !================================================================================= module function compute_dft_cmplx_qp ( signal , N , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( qp ), dimension ( N ) :: result real ( qp ), dimension ( size ( signal )) :: n_vec complex ( qp ) :: omega integer ( isp ) :: i if ( N == 1 ) then result = signal else omega = exp ( - 2 * pi_qp * im_qp / real ( N , qp )) n_vec = [( real ( i - 1 , qp ), i = 1 , N )] if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_qp ( signal , n_vec , omega , N ) else if ( loop_method % use_vectorized ) then result = compute_do_vectorized_cmplx_qp ( signal , n_vec , omega , N ) else if ( loop_method % use_do_concurrent ) then result = compute_do_concurrent_cmplx_qp ( signal , n_vec , omega , N ) else if ( loop_method % parallel % use_openmp ) then result = compute_openmp_cmplx_qp ( signal , n_vec , omega , N , & loop_method % parallel % num_threads ) end if end if end function compute_dft_cmplx_qp module pure function compute_do_classic_cmplx_qp ( signal , n_vector , omega , N ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal real ( qp ), dimension (:), intent ( in ) :: n_vector complex ( qp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( qp ), dimension ( N ) :: result integer ( isp ) :: i , k do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_classic_cmplx_qp module pure function compute_do_vectorized_cmplx_qp ( signal , n_vector , omega , N ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal real ( qp ), dimension (:), intent ( in ) :: n_vector complex ( qp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( qp ), dimension ( N ) :: result real ( qp ), dimension ( N ) :: k_vector complex ( qp ), dimension ( N , N ) :: fourier_matrix k_vector = n_vector fourier_matrix = omega ** reshape ( spread ( k_vector , 2 , N ) * spread ( n_vector , 1 , N ), [ N , N ]) result = matmul ( fourier_matrix , signal ) end function compute_do_vectorized_cmplx_qp module pure function compute_do_concurrent_cmplx_qp ( signal , n_vector , omega , N ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal real ( qp ), dimension (:), intent ( in ) :: n_vector complex ( qp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N complex ( qp ), dimension ( N ) :: result integer ( isp ) :: i , k do concurrent ( i = 1 : N ) k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do end function compute_do_concurrent_cmplx_qp module function compute_openmp_cmplx_qp ( signal , n_vector , omega , N , threads ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal real ( qp ), dimension (:), intent ( in ) :: n_vector complex ( qp ), intent ( in ) :: omega integer ( isp ), intent ( in ) :: N , threads complex ( qp ), dimension ( N ) :: result integer ( isp ) :: i , k !$omp parallel do default(none) private(k, i) & !$omp& shared(signal, n_vector, omega, result, N) & !$omp& num_threads(threads) do i = 1 , N k = i - 1 result ( i ) = sum ( signal * omega ** ( k * n_vector )) end do !$omp end parallel do end function compute_openmp_cmplx_qp end submodule NAFPack_Fourier_Transform_dft_compute","tags":"","url":"sourcefile\\nafpack_fourier_transform_dft_compute.f90.html"},{"title":"NAFPack_ANSI_ASCII.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_ansi_ascii.f90~~EfferentGraph sourcefile~nafpack_ansi_ascii.f90 NAFPack_ANSI_ASCII.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_ansi_ascii.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_ANSI ) NAFPack_ANSI_ASCII character ( len = 1 , kind = ascii ), parameter :: esc = char ( 27 ) character ( len = 2 , kind = ascii ), parameter :: CSI = esc // \"[\" character ( len = 1 , kind = ascii ), parameter :: final_character = \"m\" character ( len = 1 , kind = ascii ), parameter :: delimiter = \";\" contains module subroutine init_colors_ascii ( this ) class ( ColorsAscii ), intent ( out ) :: this this % reset = create_ansi_ascii ( Ansi_Constants % STYLE_RESET ) this % bold = create_ansi_ascii ( Ansi_Constants % STYLE_BOLD ) this % faint = create_ansi_ascii ( Ansi_Constants % STYLE_FAINT ) this % italic = create_ansi_ascii ( Ansi_Constants % STYLE_ITALIC ) this % underline = create_ansi_ascii ( Ansi_Constants % STYLE_UNDERLINE ) this % blink = create_ansi_ascii ( Ansi_Constants % STYLE_BLINK ) this % reverse = create_ansi_ascii ( Ansi_Constants % STYLE_REVERSE ) this % hidden = create_ansi_ascii ( Ansi_Constants % STYLE_HIDDEN ) this % strikethrough = create_ansi_ascii ( Ansi_Constants % STYLE_STRIKETHROUGH ) this % red = create_ansi_ascii ( Ansi_Constants % FG_RED ) this % green = create_ansi_ascii ( Ansi_Constants % FG_GREEN ) this % yellow = create_ansi_ascii ( Ansi_Constants % FG_YELLOW ) this % blue = create_ansi_ascii ( Ansi_Constants % FG_BLUE ) this % magenta = create_ansi_ascii ( Ansi_Constants % FG_MAGENTA ) this % cyan = create_ansi_ascii ( Ansi_Constants % FG_CYAN ) this % white = create_ansi_ascii ( Ansi_Constants % FG_WHITE ) this % bright_red = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_RED ) this % bright_green = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_GREEN ) this % bright_yellow = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_YELLOW ) this % bright_blue = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_BLUE ) this % bright_magenta = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_MAGENTA ) this % bright_cyan = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_CYAN ) this % bright_white = create_ansi_ascii ( Ansi_Constants % FG_BRIGHT_WHITE ) end subroutine init_colors_ascii pure module function create_ansi_ascii ( ansi_code ) result ( ansi_string ) type ( AnsiCode ), intent ( in ) :: ansi_code character ( len = :, kind = ascii ), allocatable :: ansi_string integer ( i8 ) :: style integer ( i16 ) :: fg , bg ansi_string = CSI // \"0\" !Always reset if ( ansi_code % use_style ) then style = ansi_code % style ansi_string = ansi_string // delimiter // to_str_ascii ( style ) end if if ( ansi_code % use_fg ) then fg = int ( ansi_code % fg , kind = i16 ) ansi_string = ansi_string // delimiter // \"38;5;\" // to_str_ascii ( fg ) end if if ( ansi_code % use_bg ) then bg = int ( ansi_code % bg , kind = i16 ) ansi_string = ansi_string // delimiter // \"48;5;\" // to_str_ascii ( bg ) end if if (. not . ( ansi_code % use_style . or . ansi_code % use_fg . or . ansi_code % use_bg )) then style = ansi_code % style ansi_string = ansi_string // delimiter // to_str_ascii ( style ) end if ansi_string = ansi_string // \"m\" end function create_ansi_ascii pure module function apply_style_ascii ( text , style ) result ( styled_text ) character ( * , kind = ascii ), intent ( in ) :: text type ( AnsiCode ), intent ( in ) :: style character (:, kind = ascii ), allocatable :: styled_text styled_text = create_ansi_ascii ( style ) // text // create_ansi_ascii ( Ansi_Constants % STYLE_RESET ) end function apply_style_ascii pure module function colorize_text_ascii ( text , color ) result ( colored_text ) character ( * , kind = ascii ), intent ( in ) :: text integer ( i16 ), intent ( in ) :: color character (:, kind = ascii ), allocatable :: colored_text colored_text = apply_style_ascii ( text , set_ansi_code ( fg_color = color )) end function colorize_text_ascii subroutine cursor_position_ascii ( row , col ) integer , intent ( in ) :: row , col character (:, kind = ascii ), allocatable :: sequence character (:, kind = ascii ), allocatable :: temp write ( temp , '(I0,A,I0)' ) row , delimiter , col sequence = CSI // temp // 'H' write ( output_unit , '(A)' , advance = 'no' ) sequence end subroutine cursor_position_ascii subroutine clear_screen_ascii () write ( * , '(A)' , advance = 'no' ) CSI // '2J' end subroutine clear_screen_ascii subroutine clear_line_ascii () write ( * , '(A)' , advance = 'no' ) CSI // '2K' end subroutine clear_line_ascii subroutine save_cursor_ascii () write ( * , '(A)' , advance = 'no' ) CSI // 's' end subroutine save_cursor_ascii subroutine restore_cursor_ascii () write ( * , '(A)' , advance = 'no' ) CSI // 'u' end subroutine restore_cursor_ascii end submodule NAFPack_ANSI_ASCII","tags":"","url":"sourcefile\\nafpack_ansi_ascii.f90.html"},{"title":"NAFPack_Fourier_Transform_fft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_fft.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_fourier_transform_fft.f90~~AfferentGraph sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform ) NAFPack_Fourier_Transform_fft use NAFPack_memory_management , only : realloc implicit none ( type , external ) type FFTStageParams integer ( isp ) :: stage integer ( isp ) :: current_block_size integer ( isp ) :: block_size integer ( isp ) :: nb_blocks end type FFTStageParams interface module function compute_fft_radix2_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result end function compute_fft_radix2_cmplx_sp module function compute_fft_mixed_radix_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result end function compute_fft_mixed_radix_cmplx_sp module function compute_fft_split_radix_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result end function compute_fft_split_radix_cmplx_sp end interface contains ! module function fft_plan_create(N) result(plan) !     integer(isp), intent(in) :: N !     complex(sp), dimension(:), allocatable :: plan !     integer(isp), dimension(:), allocatable :: radix_fft !     call get_radix(N, radix_fft) ! end function fft_plan_create module subroutine init_fft_plan_sp ( this , N , algorithm , decimation_method ) class ( Fourier_Transform ), intent ( inout ) :: this integer ( isp ), intent ( in ) :: N type ( FFTAlgorithm ), optional , intent ( in ) :: algorithm type ( DecimationMethod ), optional , intent ( in ) :: decimation_method integer ( isp ) :: N_radix this % fft_plan % N = N this % fft_plan % is_initialized = . true . if ( present ( algorithm )) then this % fft_plan % algorithm = algorithm else this % fft_plan % algorithm = ALG_AUTO end if select case ( this % fft_plan % algorithm % id ) case ( ALG_RADIX2_DIT % id , ALG_RADIX2_DIF % id ) if (. not . is_power_of_two ( N )) & error stop \"Error in init_fft_plan_sp: N must be a power of two for radix-2 DIT FFT.\" call get_radix_2 ( this % fft_plan ) this % fft_plan % use_pure_radix2 = . true . case ( ALG_SPLIT_DIF % id , ALG_SPLIT_DIT % id ) if (. not . is_power_of_two ( N )) & error stop \"Error in init_fft_plan_sp: N must be a power of two for split FFT.\" ! TODO implement get_radix_split_radix_sp call get_radix_2 ( this % fft_plan ) this % fft_plan % use_split_radix = . true . case ( ALG_MIXED_DIT % id , ALG_MIXED_DIF % id ) call get_mixed_radix ( N , this % fft_plan ) this % fft_plan % use_mixed_radix = . true . case ( ALG_AUTO % id ) if ( present ( decimation_method )) then this % fft_plan % algorithm % decimation_method = decimation_method else this % fft_plan % algorithm % decimation_method = DIT end if if ( is_power_of_two ( N )) then call get_radix_2 ( this % fft_plan ) this % fft_plan % use_pure_radix2 = . true . else call get_mixed_radix ( N , this % fft_plan ) this % fft_plan % use_mixed_radix = . true . end if case ( ALG_NONE % id ) print * , \"Error in init_fft_plan_sp: FFT algorithm must be specified.\" error stop case default print * , \"Error in init_fft_plan_sp: Unknown FFT algorithm.\" error stop end select N_radix = size ( this % fft_plan % radix_plan ) if ( this % fft_plan % algorithm % decimation_method % id == DIF % id ) then this % fft_plan % radix_plan = this % fft_plan % radix_plan ( N_radix : 1 : - 1 ) end if if ( this % fft_plan % use_split_radix ) then call generate_split_twiddles_sp ( this % fft_plan , N_radix ) else call generate_twiddles_sp ( this % fft_plan , N_radix ) end if if ( this % fft_plan % algorithm % decimation_method % id == DIF % id ) then if ( this % fft_plan % use_split_radix ) then this % fft_plan % split_radix_twiddles = this % fft_plan % split_radix_twiddles ( N_radix : 1 : - 1 ) else this % fft_plan % twiddles = this % fft_plan % twiddles ( N_radix : 1 : - 1 ) end if end if end subroutine init_fft_plan_sp pure subroutine get_radix_2 ( plan ) type ( FFTPlan ), intent ( inout ) :: plan integer ( isp ) :: N_radix N_radix = power_of_p_exponent ( plan % N , 2 ) allocate ( plan % radix_plan ( N_radix )) plan % radix_plan = 2 end subroutine get_radix_2 pure subroutine get_mixed_radix ( N , plan , group_radices ) integer ( isp ), intent ( in ) :: N logical , optional , intent ( in ) :: group_radices type ( FFTPlan ), intent ( inout ) :: plan integer ( isp ), dimension (:), allocatable :: radix_exponents integer ( isp ), dimension (:), allocatable :: prime_number integer ( isp ) :: N_prime , i , N_temp , N_radix , idx , idx_old logical :: group_radices_used group_radices_used = . false . if ( present ( group_radices )) group_radices_used = group_radices N_temp = N prime_number = sieve_of_eratosthenes ( N ) N_prime = size ( prime_number , 1 ) allocate ( radix_exponents ( N_prime )) radix_exponents = 0 do i = 1 , size ( prime_number ) do while ( mod ( N_temp , prime_number ( i )) == 0 ) radix_exponents ( i ) = radix_exponents ( i ) + 1 N_temp = N_temp / prime_number ( i ) end do end do if ( group_radices_used ) then N_radix = count ( radix_exponents /= 0 ) else N_radix = sum ( radix_exponents ) end if if ( N_temp > 1 ) N_radix = N_radix + 1 allocate ( plan % radix_plan ( N_radix )) idx = 0 idx_old = 0 do i = 1 , N_prime if ( radix_exponents ( i ) /= 0 ) then if ( group_radices_used ) then idx = idx + 1 plan % radix_plan ( idx ) = prime_number ( i ) ** radix_exponents ( i ) else idx = idx_old + radix_exponents ( i ) plan % radix_plan (( idx_old ) + 1 : idx ) = prime_number ( i ) idx_old = idx end if end if end do if ( N_temp > 1 ) plan % radix_plan ( N_radix ) = N_temp deallocate ( radix_exponents , prime_number ) end subroutine get_mixed_radix pure subroutine generate_twiddles_sp ( plan , N_radix ) type ( FFTPlan ), intent ( inout ) :: plan integer ( isp ), intent ( in ) :: N_radix integer ( isp ), dimension (:), allocatable :: k integer ( isp ) :: i , j , r , block_size , current_block_size real ( sp ) :: sign_factor if ( plan % algorithm % decimation_method % id == DIF % id ) then sign_factor = - 1.0_sp ! Pour DIF else sign_factor = - 1.0_sp ! Pour DIT (défaut) end if allocate ( plan % twiddles ( N_radix )) block_size = 1 do i = 1 , N_radix r = plan % radix_plan ( i ) current_block_size = block_size * r plan % twiddles ( i )% radix = r plan % twiddles ( i )% block_size = block_size plan % twiddles ( i )% current_block_size = current_block_size allocate ( plan % twiddles ( i )% twiddles_factor ( block_size )) allocate ( k ( 0 : block_size - 1 )) k = [( j , j = 0 , block_size - 1 )] plan % twiddles ( i )% twiddles_factor = exp ( sign_factor * 2.0_sp * im_sp * pi_sp * k / current_block_size ) deallocate ( k ) block_size = current_block_size end do end subroutine generate_twiddles_sp subroutine generate_split_twiddles_sp ( plan , N_radix ) type ( FFTPlan ), intent ( inout ) :: plan integer ( isp ), intent ( in ) :: N_radix integer ( isp ), parameter :: MAX_ITER = 20 integer ( isp ), dimension (:), allocatable :: tmp_start_indices , tmp_strides integer ( isp ), dimension (:), allocatable :: k integer ( isp ) :: i , j , r , block_size , current_block_size real ( sp ) :: sign_factor integer ( isp ) :: start_index , stride , num_stages , tmp_size if ( plan % algorithm % decimation_method % id == DIF % id ) then sign_factor = 1.0_sp else sign_factor = - 1.0_sp end if allocate ( plan % split_radix_twiddles ( N_radix )) current_block_size = 2 do i = 1 , N_radix r = plan % radix_plan ( i ) block_size = current_block_size / ( 2 * r ) ! Initialize stage parameters plan % split_radix_twiddles ( i )% radix = r plan % split_radix_twiddles ( i )% block_size = block_size plan % split_radix_twiddles ( i )% current_block_size = current_block_size ! Allocation and computation of twiddles_Wk and twiddles_W3k if ( block_size < 1 ) then allocate ( plan % split_radix_twiddles ( i )% twiddles_Wk ( 1 )) allocate ( plan % split_radix_twiddles ( i )% twiddles_W3k ( 1 )) plan % split_radix_twiddles ( i )% twiddles_Wk = ( 1._sp , 0._sp ) plan % split_radix_twiddles ( i )% twiddles_W3k = ( 1._sp , 0._sp ) else allocate ( plan % split_radix_twiddles ( i )% twiddles_Wk ( block_size )) allocate ( plan % split_radix_twiddles ( i )% twiddles_W3k ( block_size )) allocate ( k ( 0 : block_size - 1 )) k = [( j , j = 0 , block_size - 1 )] plan % split_radix_twiddles ( i )% twiddles_Wk = exp ( - 2.0_sp * im_sp * pi_sp * k / current_block_size ) plan % split_radix_twiddles ( i )% twiddles_W3k = exp ( - 2.0_sp * im_sp * pi_sp * 3 * k / current_block_size ) deallocate ( k ) end if ! Allocation and computation of stages split radix allocate ( plan % split_radix_twiddles ( i )% indices ( block_size )) do j = 1 , block_size allocate ( tmp_start_indices ( 0 : MAX_ITER ), tmp_strides ( 0 : MAX_ITER )) num_stages = 0 start_index = j stride = 2 * current_block_size tmp_start_indices ( num_stages ) = start_index tmp_strides ( num_stages ) = stride do while ( start_index < plan % N ) num_stages = num_stages + 1 tmp_size = size ( tmp_start_indices ) if ( num_stages > size ( tmp_start_indices )) then call realloc ( tmp_start_indices , 2 * tmp_size ) call realloc ( tmp_strides , 2 * tmp_size ) end if start_index = 2 * stride - current_block_size + j stride = 4 * stride tmp_start_indices ( num_stages ) = start_index tmp_strides ( num_stages ) = stride end do plan % split_radix_twiddles ( i )% indices ( j )% num_stages = num_stages allocate ( plan % split_radix_twiddles ( i )% indices ( j )% start_indices ( 0 : num_stages )) allocate ( plan % split_radix_twiddles ( i )% indices ( j )% strides ( 0 : num_stages )) plan % split_radix_twiddles ( i )% indices ( j )% start_indices = tmp_start_indices ( 0 : num_stages ) plan % split_radix_twiddles ( i )% indices ( j )% strides = tmp_strides ( 0 : num_stages ) deallocate ( tmp_start_indices , tmp_strides ) end do current_block_size = current_block_size * r end do end subroutine generate_split_twiddles_sp module function fft_cmplx_sp ( this , signal , loop_method ) result ( result ) class ( Fourier_Transform ), intent ( inout ) :: this complex ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result complex ( sp ), dimension (:), allocatable :: signal_reversed type ( LoopMethod ) :: loop_method_used integer ( isp ) :: N_radix N_radix = size ( this % fft_plan % radix_plan ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if if (. not . this % fft_plan % is_initialized ) then call init_fft_plan_sp ( this , size ( signal )) else if ( this % fft_plan % N /= size ( signal )) then print * , \"Error in fft_cmplx_sp: FFT plan size does not match signal size.\" error stop end if select case ( this % fft_plan % algorithm % decimation_method % id ) case ( DIT % id ) if ( this % fft_plan % use_pure_radix2 . or . this % fft_plan % use_split_radix ) then signal_reversed = bit_reverse ( signal , this % fft_plan % N ) else if ( this % fft_plan % use_mixed_radix ) then signal_reversed = digit_reverse ( signal , this % fft_plan % radix_plan ) else print * , \"Error in fft_cmplx_sp: Unknown FFT plan type.\" error stop end if result = compute_fft_sp ( signal_reversed , this % fft_plan , loop_method_used ) case ( DIF % id ) result = compute_fft_sp ( signal , this % fft_plan , loop_method_used ) if ( this % fft_plan % use_pure_radix2 . or . this % fft_plan % use_split_radix ) then result = bit_reverse ( result , this % fft_plan % N ) else if ( this % fft_plan % use_mixed_radix ) then result = digit_reverse ( result , this % fft_plan % radix_plan ( N_radix : 1 : - 1 )) else print * , \"Error in fft_cmplx_sp: Unknown FFT plan type.\" error stop end if end select end function fft_cmplx_sp pure function bit_reverse ( x , N ) result ( y ) complex ( sp ), dimension ( N ), intent ( in ) :: x integer ( isp ), intent ( in ) :: N complex ( sp ), dimension ( N ) :: y integer ( isp ) :: i , j , m complex ( sp ) :: tmp y = x j = 0 do i = 0 , N - 1 if ( i < j ) then tmp = y ( i + 1 ) y ( i + 1 ) = y ( j + 1 ) y ( j + 1 ) = tmp end if m = N / 2 do while ( m > 0 . and . j >= m ) j = j - m m = m / 2 end do j = j + m end do end function bit_reverse function digit_reverse ( x , radix_plan ) result ( y ) complex ( sp ), dimension (:), intent ( in ) :: x integer , dimension (:), intent ( in ) :: radix_plan ! [r1, r2, ..., rm] complex ( sp ), dimension ( size ( x )) :: y integer ( sp ), dimension ( size ( radix_plan )) :: d integer :: N , m , i , j , idx , rev , factor N = size ( x ) m = size ( radix_plan ) do i = 0 , N - 1 idx = i do j = m , 1 , - 1 d ( j ) = mod ( idx , radix_plan ( j )) idx = idx / radix_plan ( j ) end do rev = 0 factor = 1 do j = 1 , m rev = rev + d ( j ) * factor factor = factor * radix_plan ( j ) end do y ( rev + 1 ) = x ( i + 1 ) end do end function digit_reverse function compute_fft_sp ( signal , plan , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result integer ( isp ) :: N , num_stages , stage , r type ( FFTStageParams ) :: stage_params N = size ( signal ) num_stages = size ( plan % radix_plan ) allocate ( result ( N )) result = signal do stage = 1 , num_stages stage_params % stage = stage if ( allocated ( plan % twiddles )) then r = plan % twiddles ( stage )% radix stage_params % block_size = plan % twiddles ( stage )% block_size stage_params % current_block_size = plan % twiddles ( stage )% current_block_size stage_params % nb_blocks = N / stage_params % current_block_size else if ( allocated ( plan % split_radix_twiddles )) then r = plan % split_radix_twiddles ( stage )% radix stage_params % block_size = plan % split_radix_twiddles ( stage )% block_size stage_params % current_block_size = plan % split_radix_twiddles ( stage )% current_block_size stage_params % nb_blocks = - 1 else print * , \"Error in compute_fft_sp: Twiddles not allocated.\" error stop end if if ( plan % use_pure_radix2 ) then result = compute_fft_radix2_cmplx_sp ( & result , plan , stage_params , loop_method ) else if ( plan % use_mixed_radix ) then result = compute_fft_mixed_radix_cmplx_sp ( & result , plan , stage_params , loop_method ) else if ( plan % use_split_radix ) then ! TODO implement split-radix FFT ! error stop \"Split-radix FFT not yet implemented.\" result = compute_fft_split_radix_cmplx_sp ( & result , plan , stage_params , loop_method ) else print * , \"Error in compute_fft_sp: Unknown FFT plan type.\" error stop end if end do end function compute_fft_sp pure module subroutine destroy_fft_plan_sp ( this ) class ( Fourier_Transform ), intent ( inout ) :: this integer ( isp ) :: i if ( this % fft_plan % is_initialized ) then if ( allocated ( this % fft_plan % twiddles )) then do i = 1 , size ( this % fft_plan % twiddles ) if ( allocated ( this % fft_plan % twiddles ( i )% twiddles_factor )) then deallocate ( this % fft_plan % twiddles ( i )% twiddles_factor ) end if end do deallocate ( this % fft_plan % twiddles ) end if if ( allocated ( this % fft_plan % split_radix_twiddles )) then do i = 1 , size ( this % fft_plan % split_radix_twiddles ) if ( allocated ( this % fft_plan % split_radix_twiddles ( i )% twiddles_Wk )) then deallocate ( this % fft_plan % split_radix_twiddles ( i )% twiddles_Wk ) end if if ( allocated ( this % fft_plan % split_radix_twiddles ( i )% twiddles_W3k )) then deallocate ( this % fft_plan % split_radix_twiddles ( i )% twiddles_W3k ) end if end do deallocate ( this % fft_plan % split_radix_twiddles ) end if if ( allocated ( this % fft_plan % radix_plan )) then deallocate ( this % fft_plan % radix_plan ) end if this % fft_plan % N = 0 this % fft_plan % is_initialized = . false . this % fft_plan % use_pure_radix2 = . false . this % fft_plan % use_split_radix = . false . this % fft_plan % use_mixed_radix = . false . this % fft_plan % algorithm = ALG_NONE end if end subroutine destroy_fft_plan_sp end submodule NAFPack_Fourier_Transform_fft","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft.f90.html"},{"title":"NAFPack_matricielle.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matricielle.f90~~EfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matricielle.f90~~AfferentGraph sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Tensor operations in NAFPack module NAFPack_matricielle use NAFPack_kinds , only : dp implicit none ( type , external ) private public :: dot , cross public :: norm_2_real , norm_2_complex public :: normalise , normalise_complexe public :: Diagonally_Dominant_Matrix public :: Identity_n public :: rotation_matrix public :: Trace public :: Diag , Make_Tridiagonal contains !> function that calculates the dot product of two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\cdot \\vec{b}  function dot ( a , b ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a , b real ( dp ) :: result integer :: i if ( size ( a ) /= size ( b )) stop \"Error: Vectors must be of the same size.\" result = 0.0_dp do i = 1 , size ( a ) result = result + a ( i ) * b ( i ) end do end function dot !> function that calculates the cross product between two real 3-dimensional vectors  \\vec{a}  and  \\vec{b}  !>  \\vec{a} \\times \\vec{b} [&#94;1] !> [&#94;1]: the wedge notation  \\vec{a} \\wedge \\vec{b}  can sometimes be used to denote the vector product. function cross ( a , b ) result ( result ) real ( dp ), dimension ( 3 ), intent ( in ) :: a , b real ( dp ), dimension ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function cross !> function that calculates the Euclidean norm (L2 norm) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} a_i&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} a_i&#94;2 = \\vec{a} \\cdot \\vec{a}  !> where  n  is the dimension of the real vector  \\vec{a} . function norm_2_real ( a ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a real ( dp ) :: result result = sqrt ( dot_product ( a , a )) end function norm_2_real !> Optimized norm calculation avoiding overflow/underflow pure function norm_2_safe ( a ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a real ( dp ) :: result real ( dp ) :: scale , sum_of_squares scale = maxval ( abs ( a )) if ( scale == 0.0_dp ) then result = 0.0_dp else sum_of_squares = sum (( a / scale ) ** 2 ) result = scale * sqrt ( sum_of_squares ) end if end function norm_2_safe !> function that calculates the Euclidean norm (L2 norm or modulus) of a vector  \\vec{a} , !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  ||\\vec{a}||_2 = \\sqrt{\\sum_{i=1}&#94;{n} |a_i|&#94;2} \\quad \\text{ with } \\quad \\sum_{i=1}&#94;{n} |a_i|&#94;2 = \\vec{a} \\cdot \\overline{\\vec{a}}  !> where  n  is the dimension of the complex vector  \\vec{a} . function norm_2_complex ( a ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: a real ( dp ) :: result result = sqrt ( real ( dot_product ( a , conjg ( a )))) end function norm_2_complex !> function that normalises a real vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{R}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  function normalise ( a ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: a real ( dp ), dimension ( size ( a )) :: result result = a / norm_2_real ( a ) end function normalise !> function that normalises a complex vector a to make it a unit vector, !> where  \\vec{a} \\in \\mathbb{C}&#94;n  !>  \\hat{a} = \\frac{\\vec{a}}{||\\vec{a}||_2}  function normalise_complexe ( a ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: a complex ( dp ), dimension ( size ( a )) :: result result = a / norm_2_complex ( a ) end function normalise_complexe !> function that calculates the trace of a square matrix  A  !>  \\text{Tr}(A) = \\sum_{i=1}&#94;{n} A(i,i)  function Trace ( A ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ) :: result integer :: i , N N = size ( A , 1 ) if ( size ( A , 2 ) /= N ) stop \"Error: Matrix must be square.\" result = sum ([( A ( i , i ), i = 1 , N )]) end function Trace !> function which checks if **A** is diagonally dominant !>  \\forall i, |A(i,i)| \\geq \\sum_{j \\neq i} |A(i,j)|  function Diagonally_Dominant_Matrix ( A ) result ( diagonally_dominant ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: diagonally_dominant real ( dp ) :: summation integer :: i , N N = size ( A , 1 ) diagonally_dominant = . true . do i = 1 , N summation = sum ( abs ( A ( i , :) - A ( i , i ))) if ( abs ( A ( i , i )) < summation ) then diagonally_dominant = . false . exit end if end do end function Diagonally_Dominant_Matrix !> function that returns the identity matrix for a given size N !>  I_N = \\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{pmatrix}  function Identity_n ( N , use_concurrent ) result ( Identity ) integer , intent ( in ) :: N logical , intent ( in ), optional :: use_concurrent real ( dp ), dimension ( N , N ) :: Identity integer :: i logical :: concurrent_mode concurrent_mode = . false . if ( present ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 if ( concurrent_mode ) then do concurrent ( i = 1 : N ) Identity ( i , i ) = 1.0_dp end do else forall ( i = 1 : N ) Identity ( i , i ) = 1.0_dp end if end function Identity_n !> function that extracts the diagonal of a matrix !>  D = \\begin{pmatrix} A(1,1) & 0 & \\cdots & 0 \\\\ 0 & A(2,2) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & A(n,n) \\end{pmatrix}  !> where  D  is a vector containing the diagonal elements of the matrix  A . function Diag ( A ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 )) :: D integer :: i , N N = size ( A , 1 ) forall ( i = 1 : N ) D ( i ) = A ( i , i ) end function Diag function Make_Tridiagonal ( d_minus , d , d_plus ) result ( T ) real ( dp ), dimension (:), intent ( in ) :: d_minus , d , d_plus real ( dp ), dimension ( size ( d , 1 ), size ( d , 1 )) :: T integer :: i , N N = size ( d , 1 ) T = 0.d0 do i = 1 , N T ( i , i ) = d ( i ) if ( i > 1 ) T ( i , i - 1 ) = d_minus ( i ) if ( i < N ) T ( i , i + 1 ) = d_plus ( i ) end do end function Make_Tridiagonal !> Function to create a rotation matrix !> !> This function generates a rotation matrix **G** based on the input matrix **A** and the specified rotation indices. function rotation_matrix ( A , rotation ) result ( G ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , dimension ( 2 ), intent ( in ) :: rotation real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: G real ( dp ) :: frac , val_1 , val_2 integer :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( size ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = sqrt ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac end function rotation_matrix end module NAFPack_matricielle","tags":"","url":"sourcefile\\nafpack_matricielle.f90.html"},{"title":"NAFPack_Fourier_Transform_dft3.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_dft3.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform ) NAFPack_Fourier_Transform_dft3 implicit none ( type , external ) contains module function dft3_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result complex ( sp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = dft_cmplx_sp ( signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = dft_cmplx_sp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = dft_cmplx_sp ( tmp (:, j , i ), loop_method_used ) end do end do end function dft3_cmplx_sp module function idft3_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result complex ( sp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = idft_cmplx_sp ( f_signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = idft_cmplx_sp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = idft_cmplx_sp ( tmp (:, j , i ), loop_method_used ) end do end do end function idft3_cmplx_sp module function dft3_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result complex ( dp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = dft_cmplx_dp ( signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = dft_cmplx_dp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = dft_cmplx_dp ( tmp (:, j , i ), loop_method_used ) end do end do end function dft3_cmplx_dp module function idft3_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result complex ( dp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = idft_cmplx_dp ( f_signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = idft_cmplx_dp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = idft_cmplx_dp ( tmp (:, j , i ), loop_method_used ) end do end do end function idft3_cmplx_dp module function dft3_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result complex ( qp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = dft_cmplx_qp ( signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = dft_cmplx_qp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = dft_cmplx_qp ( tmp (:, j , i ), loop_method_used ) end do end do end function dft3_cmplx_qp module function idft3_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result complex ( qp ), dimension (:, :, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , j , Nx , Ny , Nz if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) allocate ( tmp ( Nx , Ny , Nz )) do i = 1 , Nx do j = 1 , Ny tmp ( i , j , :) = idft_cmplx_qp ( f_signal ( i , j , :), loop_method_used ) end do end do do i = 1 , Nx do j = 1 , Nz result ( i , :, j ) = idft_cmplx_qp ( tmp ( i , :, j ), loop_method_used ) end do end do tmp = result do j = 1 , Ny do i = 1 , Nz result (:, j , i ) = idft_cmplx_qp ( tmp (:, j , i ), loop_method_used ) end do end do end function idft3_cmplx_qp module function dft3_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result complex ( sp ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = sp ) if ( present ( loop_method )) then result = dft3_cmplx_sp ( signal_cmplx , loop_method ) else result = dft3_cmplx_sp ( signal_cmplx ) end if end function dft3_real_sp module function idft3_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result complex ( sp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 ), & size ( f_signal , 3 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = sp ) if ( present ( loop_method )) then result = idft3_cmplx_sp ( f_signal_cmplx , loop_method ) else result = idft3_cmplx_sp ( f_signal_cmplx ) end if end function idft3_real_sp module function dft3_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result complex ( dp ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = dp ) if ( present ( loop_method )) then result = dft3_cmplx_dp ( signal_cmplx , loop_method ) else result = dft3_cmplx_dp ( signal_cmplx ) end if end function dft3_real_dp module function idft3_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result complex ( dp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 ), & size ( f_signal , 3 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = dp ) if ( present ( loop_method )) then result = idft3_cmplx_dp ( f_signal_cmplx , loop_method ) else result = idft3_cmplx_dp ( f_signal_cmplx ) end if end function idft3_real_dp module function dft3_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result complex ( qp ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) Nz = size ( signal , 3 ) allocate ( result ( Nx , Ny , Nz )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = qp ) if ( present ( loop_method )) then result = dft3_cmplx_qp ( signal_cmplx , loop_method ) else result = dft3_cmplx_qp ( signal_cmplx ) end if end function dft3_real_qp module function idft3_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result complex ( qp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 ), & size ( f_signal , 3 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny , Nz Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) Nz = size ( f_signal , 3 ) allocate ( result ( Nx , Ny , Nz )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = qp ) if ( present ( loop_method )) then result = idft3_cmplx_qp ( f_signal_cmplx , loop_method ) else result = idft3_cmplx_qp ( f_signal_cmplx ) end if end function idft3_real_qp end submodule NAFPack_Fourier_Transform_dft3","tags":"","url":"sourcefile\\nafpack_fourier_transform_dft3.f90.html"},{"title":"NAFPack_Fourier_Transform_dft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_dft.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_fourier_transform_dft.f90~~AfferentGraph sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform ) NAFPack_Fourier_Transform_dft implicit none ( type , external ) interface module function compute_dft_cmplx_sp ( signal , N , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( N ) :: result end function compute_dft_cmplx_sp end interface interface module function compute_dft_cmplx_dp ( signal , N , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( dp ), dimension ( N ) :: result end function compute_dft_cmplx_dp end interface interface module function compute_dft_cmplx_qp ( signal , N , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal integer ( isp ), intent ( in ) :: N type ( LoopMethod ), intent ( in ) :: loop_method complex ( qp ), dimension ( N ) :: result end function compute_dft_cmplx_qp end interface contains module function dft_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result type ( LoopMethod ) :: loop_method_used integer ( isp ) :: N if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if N = size ( signal ) allocate ( result ( N )) result = compute_dft_cmplx_sp ( signal , N , loop_method_used ) end function dft_cmplx_sp module function idft_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) result = conjg ( dft_cmplx_sp ( conjg ( f_signal ), loop_method )) / N end function idft_cmplx_sp module function dft_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result type ( LoopMethod ) :: loop_method_used integer ( isp ) :: N if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if N = size ( signal ) allocate ( result ( N )) result = compute_dft_cmplx_dp ( signal , N , loop_method_used ) end function dft_cmplx_dp module function idft_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) result = conjg ( dft_cmplx_dp ( conjg ( f_signal ), loop_method )) / N end function idft_cmplx_dp module function dft_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result type ( LoopMethod ) :: loop_method_used integer ( isp ) :: N if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if N = size ( signal ) allocate ( result ( N )) result = compute_dft_cmplx_qp ( signal , N , loop_method_used ) end function dft_cmplx_qp module function idft_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) result = conjg ( dft_cmplx_qp ( conjg ( f_signal ), loop_method )) / N end function idft_cmplx_qp module function dft_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result complex ( sp ), dimension ( size ( signal )) :: signal_cmplx integer ( isp ) :: N N = size ( signal ) allocate ( result ( N )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = sp ) if ( present ( loop_method )) then result = dft_cmplx_sp ( signal_cmplx , loop_method ) else result = dft_cmplx_sp ( signal_cmplx ) end if end function dft_real_sp module function idft_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result complex ( sp ), dimension ( size ( f_signal )) :: f_signal_cmplx integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) f_signal_cmplx = cmplx ( f_signal , 0.0_sp , kind = sp ) result = conjg ( dft_cmplx_sp ( conjg ( f_signal_cmplx ), loop_method )) / N end function idft_real_sp module function dft_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result complex ( dp ), dimension ( size ( signal )) :: signal_cmplx integer ( isp ) :: N N = size ( signal ) allocate ( result ( N )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = dp ) if ( present ( loop_method )) then result = dft_cmplx_dp ( signal_cmplx , loop_method ) else result = dft_cmplx_dp ( signal_cmplx ) end if end function dft_real_dp module function idft_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result complex ( dp ), dimension ( size ( f_signal )) :: f_signal_cmplx integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = dp ) result = conjg ( dft_cmplx_dp ( conjg ( f_signal_cmplx ), loop_method )) / N end function idft_real_dp module function dft_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result complex ( qp ), dimension ( size ( signal )) :: signal_cmplx integer ( isp ) :: N N = size ( signal ) allocate ( result ( N )) signal_cmplx = cmplx ( signal , 0.0_qp , kind = qp ) if ( present ( loop_method )) then result = dft_cmplx_qp ( signal_cmplx , loop_method ) else result = dft_cmplx_qp ( signal_cmplx ) end if end function dft_real_qp module function idft_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result complex ( qp ), dimension ( size ( f_signal )) :: f_signal_cmplx integer ( isp ) :: N N = size ( f_signal ) allocate ( result ( N )) f_signal_cmplx = cmplx ( f_signal , 0.0_qp , kind = qp ) result = conjg ( dft_cmplx_qp ( conjg ( f_signal_cmplx ), loop_method )) / N end function idft_real_qp end submodule NAFPack_Fourier_Transform_dft","tags":"","url":"sourcefile\\nafpack_fourier_transform_dft.f90.html"},{"title":"NAFPack_meshgrid_complex_2D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_complex_2d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_complex_2d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90 NAFPack_meshgrid_complex_2D_compute.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90->sourcefile~nafpack_meshgrid_complex_2d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_complex_2D implicit none ( type , external ) interface module subroutine compute_meshgrid_cmplx_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_2D_sp end interface interface module subroutine compute_meshgrid_cmplx_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_2D_dp end interface interface module subroutine compute_meshgrid_cmplx_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_2D_qp end interface contains module subroutine meshgrid_cmplx_sp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_2D_sp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_cmplx_sp_2D module subroutine meshgrid_cmplx_dp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_2D_dp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_cmplx_dp_2D module subroutine meshgrid_cmplx_qp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_2D_qp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_cmplx_qp_2D end submodule NAFPack_meshgrid_complex_2D","tags":"","url":"sourcefile\\nafpack_meshgrid_complex_2d.f90.html"},{"title":"NAFPack_meshgrid_real_3D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_real_3d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_real_3d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90 NAFPack_meshgrid_real_3D_compute.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90->sourcefile~nafpack_meshgrid_real_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_real_3D implicit none ( type , external ) interface module subroutine compute_meshgrid_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_3D_sp end interface interface module subroutine compute_meshgrid_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_3D_dp end interface interface module subroutine compute_meshgrid_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_real_3D_qp end interface contains module subroutine meshgrid_real_sp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_3D_sp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_real_sp_3D module subroutine meshgrid_real_dp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_3D_dp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_real_dp_3D module subroutine meshgrid_real_qp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_real_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_real_3D_qp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_real_qp_3D end submodule NAFPack_meshgrid_real_3D","tags":"","url":"sourcefile\\nafpack_meshgrid_real_3d.f90.html"},{"title":"NAFPack_ANSI_ucs4.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_ansi_ucs4.f90~~EfferentGraph sourcefile~nafpack_ansi_ucs4.f90 NAFPack_ANSI_ucs4.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_ansi_ucs4.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_ANSI ) NAFPack_ANSI_ucs4 character ( len = 1 , kind = ucs4 ), parameter :: esc = char ( 27 ) character ( len = 2 , kind = ucs4 ), parameter :: CSI = esc // ucs4_ \"[\" character ( len = 1 , kind = ucs4 ), parameter :: final_character = ucs4_ \"m\" character ( len = 1 , kind = ucs4 ), parameter :: delimiter = ucs4_ \";\" contains module subroutine init_colors_ucs4 ( this ) class ( ColorsUcs4 ), intent ( out ) :: this this % reset = create_ansi_ucs4 ( Ansi_Constants % STYLE_RESET ) this % bold = create_ansi_ucs4 ( Ansi_Constants % STYLE_BOLD ) this % faint = create_ansi_ucs4 ( Ansi_Constants % STYLE_FAINT ) this % italic = create_ansi_ucs4 ( Ansi_Constants % STYLE_ITALIC ) this % underline = create_ansi_ucs4 ( Ansi_Constants % STYLE_UNDERLINE ) this % blink = create_ansi_ucs4 ( Ansi_Constants % STYLE_BLINK ) this % reverse = create_ansi_ucs4 ( Ansi_Constants % STYLE_REVERSE ) this % hidden = create_ansi_ucs4 ( Ansi_Constants % STYLE_HIDDEN ) this % strikethrough = create_ansi_ucs4 ( Ansi_Constants % STYLE_STRIKETHROUGH ) this % red = create_ansi_ucs4 ( Ansi_Constants % FG_RED ) this % green = create_ansi_ucs4 ( Ansi_Constants % FG_GREEN ) this % yellow = create_ansi_ucs4 ( Ansi_Constants % FG_YELLOW ) this % blue = create_ansi_ucs4 ( Ansi_Constants % FG_BLUE ) this % magenta = create_ansi_ucs4 ( Ansi_Constants % FG_MAGENTA ) this % cyan = create_ansi_ucs4 ( Ansi_Constants % FG_CYAN ) this % white = create_ansi_ucs4 ( Ansi_Constants % FG_WHITE ) this % bright_red = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_RED ) this % bright_green = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_GREEN ) this % bright_yellow = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_YELLOW ) this % bright_blue = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_BLUE ) this % bright_magenta = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_MAGENTA ) this % bright_cyan = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_CYAN ) this % bright_white = create_ansi_ucs4 ( Ansi_Constants % FG_BRIGHT_WHITE ) end subroutine init_colors_ucs4 pure module function create_ansi_ucs4 ( ansi_code ) result ( ansi_string ) type ( AnsiCode ), intent ( in ) :: ansi_code character ( len = :, kind = ucs4 ), allocatable :: ansi_string integer ( i8 ) :: style integer ( i16 ) :: fg , bg ansi_string = CSI // ucs4_ \"0\" !Always reset if ( ansi_code % use_style ) then style = ansi_code % style ansi_string = ansi_string // delimiter // to_str_ucs4 ( style ) end if if ( ansi_code % use_fg ) then fg = int ( ansi_code % fg , kind = i16 ) ansi_string = ansi_string // delimiter // ucs4_ \"38;5;\" // to_str_ucs4 ( fg ) end if if ( ansi_code % use_bg ) then bg = int ( ansi_code % bg , kind = i16 ) ansi_string = ansi_string // delimiter // ucs4_ \"48;5;\" // to_str_ucs4 ( bg ) end if if (. not . ( ansi_code % use_style . or . ansi_code % use_fg . or . ansi_code % use_bg )) then style = ansi_code % style ansi_string = ansi_string // delimiter // to_str_ucs4 ( style ) end if ansi_string = ansi_string // ucs4_ \"m\" end function create_ansi_ucs4 pure module function apply_style_ucs4 ( text , style ) result ( styled_text ) character ( * , kind = ucs4 ), intent ( in ) :: text type ( AnsiCode ), intent ( in ) :: style character (:, kind = ucs4 ), allocatable :: styled_text styled_text = create_ansi_ucs4 ( style ) // text // create_ansi_ucs4 ( Ansi_Constants % STYLE_RESET ) end function apply_style_ucs4 pure module function colorize_text_ucs4 ( text , color ) result ( colored_text ) character ( * , kind = ucs4 ), intent ( in ) :: text integer ( i16 ), intent ( in ) :: color character (:, kind = ucs4 ), allocatable :: colored_text colored_text = apply_style_ucs4 ( text , set_ansi_code ( fg_color = color )) end function colorize_text_ucs4 subroutine cursor_position_ucs4 ( row , col ) integer , intent ( in ) :: row , col character (:, kind = ucs4 ), allocatable :: sequence character (:, kind = ucs4 ), allocatable :: temp write ( temp , '(I0,A,I0)' ) row , delimiter , col sequence = CSI // temp // ucs4_ 'H' write ( output_unit , '(A)' , advance = 'no' ) sequence end subroutine cursor_position_ucs4 subroutine clear_screen_ucs4 () write ( * , '(A)' , advance = 'no' ) CSI // ucs4_ '2J' end subroutine clear_screen_ucs4 subroutine clear_line_ucs4 () write ( * , '(A)' , advance = 'no' ) CSI // ucs4_ '2K' end subroutine clear_line_ucs4 subroutine save_cursor_ucs4 () write ( * , '(A)' , advance = 'no' ) CSI // ucs4_ 's' end subroutine save_cursor_ucs4 subroutine restore_cursor_ucs4 () write ( * , '(A)' , advance = 'no' ) CSI // ucs4_ 'u' end subroutine restore_cursor_ucs4 end submodule NAFPack_ANSI_ucs4","tags":"","url":"sourcefile\\nafpack_ansi_ucs4.f90.html"},{"title":"NAFPack_meshgrid_complex_3D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_complex_3d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_complex_3d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90 NAFPack_meshgrid_complex_3D_compute.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90->sourcefile~nafpack_meshgrid_complex_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_complex_3D implicit none ( type , external ) interface module subroutine compute_meshgrid_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_3D_sp end interface interface module subroutine compute_meshgrid_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_3D_dp end interface interface module subroutine compute_meshgrid_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_cmplx_3D_qp end interface contains module subroutine meshgrid_cmplx_sp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_3D_sp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_cmplx_sp_3D module subroutine meshgrid_cmplx_dp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_3D_dp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_cmplx_dp_3D module subroutine meshgrid_cmplx_qp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny , Nz call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) Nz = size ( z_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_cmplx_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_cmplx_3D_qp ( y_vector , x_vector , z_vector , Y , X , Z , Ny , Nx , Nz , loop_method_used ) end if end subroutine meshgrid_cmplx_qp_3D end submodule NAFPack_meshgrid_complex_3D","tags":"","url":"sourcefile\\nafpack_meshgrid_complex_3d.f90.html"},{"title":"NAFPack_memory_management_integer.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_memory_management_integer.f90~~EfferentGraph sourcefile~nafpack_memory_management_integer.f90 NAFPack_memory_management_integer.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_memory_management_integer.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_memory_management ) NAFPack_memory_management_integer implicit none ( type , external ) contains module subroutine realloc_vec_integer_i8_1D ( vec , new_size ) integer ( i8 ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size integer ( i8 ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i8_1D module subroutine realloc_vec_integer_i16_1D ( vec , new_size ) integer ( i16 ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size integer ( i16 ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i16_1D module subroutine realloc_vec_integer_isp_1D ( vec , new_size ) integer ( isp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size integer ( isp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_isp_1D module subroutine realloc_vec_integer_idp_1D ( vec , new_size ) integer ( idp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size integer ( idp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_idp_1D module subroutine realloc_vec_integer_i8_2D ( vec , new_size ) integer ( i8 ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size integer ( i8 ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i8_2D module subroutine realloc_vec_integer_i16_2D ( vec , new_size ) integer ( i16 ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size integer ( i16 ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i16_2D module subroutine realloc_vec_integer_isp_2D ( vec , new_size ) integer ( isp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size integer ( isp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_isp_2D module subroutine realloc_vec_integer_idp_2D ( vec , new_size ) integer ( idp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size integer ( idp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_idp_2D module subroutine realloc_vec_integer_i8_3D ( vec , new_size ) integer ( i8 ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size integer ( i8 ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i8_3D module subroutine realloc_vec_integer_i16_3D ( vec , new_size ) integer ( i16 ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size integer ( i16 ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_i16_3D module subroutine realloc_vec_integer_isp_3D ( vec , new_size ) integer ( isp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size integer ( isp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_isp_3D module subroutine realloc_vec_integer_idp_3D ( vec , new_size ) integer ( idp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size integer ( idp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_integer_idp_3D end submodule NAFPack_memory_management_integer","tags":"","url":"sourcefile\\nafpack_memory_management_integer.f90.html"},{"title":"NAFPack_Direct_methode.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_direct_methode.f90~~EfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_direct_methode.f90~~AfferentGraph sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for direct methods in NAFPack module NAFPack_Direct_method use NAFPack_kinds , only : dp use NAFPack_constant , only : TOL_PIVOT_dp use NAFPack_Direct_types , only : MethodTypeDirect , METHOD_DIRECT_NONE , & METHOD_CHOLESKY , METHOD_LDL_Cholesky , & METHOD_FADDEEV_LEVERRIER , & METHOD_Gauss , METHOD_Gauss_JORDAN , & METHOD_LU , METHOD_LDU , & METHOD_QR , METHOD_TDMA , & DirectMethodRequirements , MethodQR , & QR_HOUSEHOLDER , QR_GIVENS , & QR_GRAM_SCHMIDT , QR_GRAM_SCHMIDT_Modified use NAFPack_matrix_decomposition , only : pivot_partial , pivot_total , & backward , forward , & LU_decomposition , LDU_decomposition , & Cholesky_decomposition , LDL_Cholesky_decomposition , & QR_Gram_Schmidt_Classical_decomposition , & QR_Gram_Schmidt_Modified_decomposition , & QR_Givens_decomposition , QR_Householder_decomposition use NAFPack_matrix_properties , only : is_non_zero_diagonal , is_SPD , is_square_matrix , & is_symmetric , is_tridiagonal use NAFPack_matrix_tools , only : Faddeev_Leverrier use NAFPack_matricielle , only : Identity_n implicit none ( type , external ) private public :: DirectMethod public :: METHOD_Gauss , METHOD_Gauss_JORDAN public :: METHOD_LU , METHOD_LDU public :: METHOD_CHOLESKY , METHOD_LDL_Cholesky public :: METHOD_QR public :: METHOD_TDMA public :: METHOD_FADDEEV_LEVERRIER public :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT , QR_GRAM_SCHMIDT_Modified type :: DirectMethod private type ( MethodTypeDirect ) :: method_type = METHOD_DIRECT_NONE type ( MethodQR ) :: qr_method = QR_GRAM_SCHMIDT logical :: use_partial_pivot = . false . logical :: use_total_pivot = . false . type ( DirectMethodRequirements ) :: requirements procedure ( solve_interface_Direct ), pass ( this ), pointer :: solve_method => null () contains procedure :: set_method => set_method procedure :: set_qr_method => set_qr_method procedure :: solve => DirectMethod_solve procedure :: test_matrix => test_matrix end type DirectMethod abstract interface function solve_interface_Direct ( this , A , b ) result ( x ) import :: dp import :: DirectMethod implicit none ( type , external ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x end function solve_interface_Direct end interface contains subroutine set_method ( this , method , set_pivot_partial , set_pivot_total ) class ( DirectMethod ), intent ( inout ) :: this type ( MethodTypeDirect ), intent ( in ) :: method logical , optional , intent ( in ) :: set_pivot_partial , set_pivot_total this % use_total_pivot = . false . this % use_partial_pivot = . false . this % requirements = DirectMethodRequirements () select case ( method % id ) case ( METHOD_Gauss % id ) this % solve_method => solve_Gauss this % method_type = METHOD_Gauss this % requirements % needs_square = . true . case ( METHOD_Gauss_JORDAN % id ) this % solve_method => solve_GaussJordan this % method_type = METHOD_Gauss_JORDAN this % requirements % needs_square = . true . case ( METHOD_LU % id ) this % solve_method => solve_LU this % method_type = METHOD_LU this % requirements % needs_square = . true . case ( METHOD_LDU % id ) this % solve_method => solve_LDU this % method_type = METHOD_LDU this % requirements % needs_square = . true . this % requirements % needs_non_zero_diag = . true . case ( METHOD_CHOLESKY % id ) this % solve_method => solve_Cholesky this % method_type = METHOD_CHOLESKY this % requirements % needs_square = . true . this % requirements % needs_SPD = . true . case ( METHOD_LDL_Cholesky % id ) this % solve_method => solve_LDL_Cholesky this % method_type = METHOD_LDL_Cholesky this % requirements % needs_square = . true . this % requirements % needs_symmetric = . true . case ( METHOD_QR % id ) this % solve_method => solve_QR this % method_type = METHOD_QR this % requirements % needs_square = . true . case ( METHOD_TDMA % id ) this % solve_method => solve_TDMA this % method_type = METHOD_TDMA this % requirements % needs_square = . true . this % requirements % needs_tridiagonal = . true . this % requirements % needs_non_zero_diag = . true . case ( METHOD_FADDEEV_LEVERRIER % id ) this % solve_method => solve_Faddeev_Leverrier this % method_type = METHOD_FADDEEV_LEVERRIER this % requirements % needs_square = . true . case DEFAULT stop \"ERROR :: Unknown method direct\" end select if ( present ( set_pivot_partial )) then if ( set_pivot_partial ) this % use_partial_pivot = . true . else if ( present ( set_pivot_total )) then if ( set_pivot_total ) this % use_total_pivot = . true . end if end subroutine set_method subroutine set_qr_method ( this , qr_method ) class ( DirectMethod ), intent ( inout ) :: this type ( MethodQR ), intent ( in ) :: qr_method this % qr_method = qr_method end subroutine set_qr_method subroutine test_matrix ( this , A , strict_mode ) class ( DirectMethod ), intent ( inout ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A logical , optional , intent ( in ) :: strict_mode logical :: strict strict = . false . if ( present ( strict_mode )) strict = strict_mode if ( this % requirements % needs_square ) then print * , \"Checking if the matrix is square...\" if (. not . is_square_matrix ( A )) then if ( strict ) then print * , \"ERROR :: \" , trim ( this % method_type % name ), & \" method requires a square matrix.\" stop else print * , \"WARNING :: \" , trim ( this % method_type % name ), & \" method requires a square matrix.\" end if end if end if if ( this % requirements % needs_SPD ) then print * , \"Checking if the matrix is symmetric positive definite (SPD)...\" if (. not . is_SPD ( A )) then if ( strict ) then print * , \"ERROR :: \" , trim ( this % method_type % name ), & \" method requires a symmetric positive definite matrix.\" stop else print * , \"WARNING :: \" , trim ( this % method_type % name ), & \" method requires a symmetric positive definite matrix.\" end if end if end if if ( this % requirements % needs_non_zero_diag ) then print * , \"Checking if the matrix has a non-zero diagonal...\" if (. not . is_non_zero_diagonal ( A )) then if ( strict ) then print * , \"ERROR :: \" , trim ( this % method_type % name ), & \" method requires a non-zero diagonal matrix.\" stop else print * , \"WARNING :: \" , trim ( this % method_type % name ), & \" method requires a non-zero diagonal matrix.\" end if end if end if if ( this % requirements % needs_tridiagonal ) then print * , \"Checking if the matrix is tridiagonal...\" if (. not . is_tridiagonal ( A )) then if ( strict ) then print * , \"ERROR :: \" , trim ( this % method_type % name ), & \" method requires a tridiagonal matrix.\" stop else print * , \"WARNING :: \" , trim ( this % method_type % name ), & \" method requires a tridiagonal matrix.\" end if end if end if if ( this % requirements % needs_symmetric ) then print * , \"Checking if the matrix is symmetric...\" if (. not . is_symmetric ( A )) then if ( strict ) then print * , \"ERROR :: \" , trim ( this % method_type % name ), & \" method requires a symmetric matrix.\" stop else print * , \"WARNING :: \" , trim ( this % method_type % name ), & \" method requires a symmetric matrix.\" end if end if end if end subroutine test_matrix function DirectMethod_solve ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x if (. not . associated ( this % solve_method )) then stop \"ERROR :: No solution method has been set. Call set_method first.\" end if x = this % solve_method ( A , b ) end function DirectMethod_solve function solve_Gauss ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: A_tmp real ( dp ), dimension (:, :), allocatable :: P real ( dp ), dimension (:, :), allocatable :: Q real ( dp ), dimension ( size ( b )) :: b_tmp integer :: i , k , N , M , allocate_status real ( dp ) :: pivot , multiplier N = size ( A , 1 ) M = size ( A , 2 ) if ( this % use_partial_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" call pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) else if ( this % use_total_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) allocate ( Q ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) call pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) else A_tmp = A b_tmp = b end if do k = 1 , N - 1 pivot = A_tmp ( k , k ) if ( abs ( pivot ) < TOL_PIVOT_dp ) stop \"ERROR :: Near-zero pivot – matrix may be singular\" do i = k + 1 , N multiplier = A_tmp ( i , k ) / pivot A_tmp ( i , k ) = 0 ! Vectorized operation A_tmp ( i , k + 1 : N ) = A_tmp ( i , k + 1 : N ) - multiplier * A_tmp ( k , k + 1 : N ) b_tmp ( i ) = b_tmp ( i ) - multiplier * b_tmp ( k ) end do end do x = backward ( A_tmp , b_tmp ) if ( this % use_total_pivot ) x = matmul ( Q , x ) end function solve_Gauss function solve_GaussJordan ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: A_tmp real ( dp ), dimension (:, :), allocatable :: P real ( dp ), dimension (:, :), allocatable :: Q real ( dp ), dimension ( size ( b )) :: b_tmp integer :: i , k , N , M , allocate_status real ( dp ) :: pivot , factor N = size ( A_tmp , 1 ) M = size ( A_tmp , 2 ) if ( this % use_partial_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" call pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) else if ( this % use_total_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) allocate ( Q ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) call pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) else A_tmp = A b_tmp = b end if do k = 1 , N pivot = A_tmp ( k , k ) if ( abs ( pivot ) < TOL_PIVOT_dp ) stop \"ERROR :: Near-zero pivot – matrix may be singular\" ! Normalisation du pivot A_tmp ( k , :) = A_tmp ( k , :) / pivot b_tmp ( k ) = b_tmp ( k ) / pivot ! Élimination dans toutes les autres lignes do i = 1 , N if ( i /= k ) then factor = A_tmp ( i , k ) A_tmp ( i , :) = A_tmp ( i , :) - factor * A_tmp ( k , :) b_tmp ( i ) = b_tmp ( i ) - factor * b_tmp ( k ) end if end do end do x = b_tmp if ( this % use_total_pivot ) x = matmul ( Q , x ) end function solve_GaussJordan function solve_LU ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: L , U real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: A_tmp real ( dp ), dimension (:, :), allocatable :: P real ( dp ), dimension (:, :), allocatable :: Q real ( dp ), dimension ( size ( b )) :: b_tmp integer :: N , M , allocate_status N = size ( A , 1 ) M = size ( A_tmp , 2 ) if ( this % use_partial_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" call pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) else if ( this % use_total_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) allocate ( Q ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) call pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) else A_tmp = A b_tmp = b end if call LU_decomposition ( A_tmp , L , U ) x = forward ( L , b_tmp ) x = backward ( U , x ) if ( this % use_total_pivot ) x = matmul ( Q , x ) end function solve_LU function solve_LDU ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: L , D , U real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: A_tmp real ( dp ), dimension (:, :), allocatable :: P real ( dp ), dimension (:, :), allocatable :: Q real ( dp ), dimension ( size ( b )) :: b_tmp integer :: N , M , allocate_status N = size ( A , 1 ) M = size ( A , 2 ) if ( this % use_partial_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" call pivot_partial ( A , P ) A_tmp = matmul ( P , A ) b_tmp = matmul ( P , b ) else if ( this % use_total_pivot ) then allocate ( P ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate P\" P = Identity_n ( N ) allocate ( Q ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate Q\" Q = Identity_n ( N ) call pivot_total ( A , P , Q ) A_tmp = matmul ( P , A ) A_tmp = matmul ( A , Q ) b_tmp = matmul ( P , b ) else A_tmp = A b_tmp = b end if call LDU_decomposition ( A_tmp , L , D , U ) x = forward ( L , b_tmp ) x = forward ( D , x ) x = backward ( U , x ) if ( this % use_total_pivot ) x = matmul ( Q , x ) end function solve_LDU function solve_Cholesky ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: L call Cholesky_decomposition ( A , L ) x = forward ( L , b ) x = backward ( transpose ( L ), x ) end function solve_Cholesky function solve_LDL_Cholesky ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: L , D call LDL_Cholesky_decomposition ( A , L , D ) x = forward ( L , b ) x = forward ( D , x ) x = backward ( transpose ( L ), x ) end function solve_LDL_Cholesky function solve_QR ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: Q , R select case ( this % qr_method % id ) case ( QR_HOUSEHOLDER % id ) call QR_Householder_decomposition ( A , Q , R ) case ( QR_GIVENS % id ) call QR_Givens_decomposition ( A , Q , R ) case ( QR_GRAM_SCHMIDT % id ) call QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) case ( QR_GRAM_SCHMIDT_Modified % id ) call QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) case DEFAULT stop \"ERROR :: Unknown QR method\" end select x = backward ( R , matmul ( transpose ( Q ), b )) end function solve_QR function solve_TDMA ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: alpha , beta real ( dp ) :: denom integer :: n , i N = size ( A , 1 ) alpha = 0.0_dp beta = 0.0_dp alpha ( 1 ) = A ( 1 , 2 ) / A ( 1 , 1 ) beta ( 1 ) = b ( 1 ) / A ( 1 , 1 ) do i = 2 , N denom = A ( i , i ) - A ( i , i - 1 ) * alpha ( i - 1 ) if ( i < N ) alpha ( i ) = A ( i , i + 1 ) / denom beta ( i ) = ( b ( i ) - A ( i , i - 1 ) * beta ( i - 1 )) / denom end do x ( n ) = beta ( n ) do i = n - 1 , 1 , - 1 x ( i ) = beta ( i ) - alpha ( i ) * x ( i + 1 ) end do end function solve_TDMA function solve_Faddeev_Leverrier ( this , A , b ) result ( x ) class ( DirectMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: Ainv real ( dp ), dimension ( size ( A , 1 ) + 1 ) :: c logical :: success call Faddeev_Leverrier ( A , c , Ainv = Ainv , success = success , check = . false .) if (. not . success ) then print * , \"WARNING :: Faddeev-Leverrier method failed, using LU decomposition instead\" x = solve_LU ( this , A , b ) else x = matmul ( Ainv , b ) end if end function solve_Faddeev_Leverrier end module NAFPack_Direct_method","tags":"","url":"sourcefile\\nafpack_direct_methode.f90.html"},{"title":"NAFPack_meshgrid_real_3D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_real_3d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_real_3d_compute.f90 NAFPack_meshgrid_real_3D_compute.f90 sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90->sourcefile~nafpack_meshgrid_real_3d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_real_3D ) NAFPack_meshgrid_real_3D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of three real vectors in 32-bit (single precision) !================================================================================= module subroutine compute_meshgrid_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_3D_sp pure subroutine compute_do_classic_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_real_3D_sp pure subroutine compute_do_vectorized_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_real_3D_sp pure subroutine compute_do_concurrent_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_real_3D_sp subroutine compute_openmp_real_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads real ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_3D_sp !================================================================================= ! Compute the meshgrid of three real vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_3D_dp pure subroutine compute_do_classic_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_real_3D_dp pure subroutine compute_do_vectorized_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_real_3D_dp pure subroutine compute_do_concurrent_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_real_3D_dp subroutine compute_openmp_real_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads real ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_3D_dp !================================================================================= ! Compute the meshgrid of three real vectors in 128-bit (quadruple precision) !================================================================================= module subroutine compute_meshgrid_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_3D_qp pure subroutine compute_do_classic_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_real_3D_qp pure subroutine compute_do_vectorized_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_real_3D_qp pure subroutine compute_do_concurrent_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz real ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_real_3D_qp subroutine compute_openmp_real_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads real ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_3D_qp end submodule NAFPack_meshgrid_real_3D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_real_3d_compute.f90.html"},{"title":"NAFPack_Iterative_types.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_types.f90~~EfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_types.f90~~AfferentGraph sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Iterative_types use NAFPack_kinds , only : dp , ucs4 implicit none ( type , external ) private public :: MethodTypeIterative public :: METHOD_ITERATIVE_NONE public :: METHOD_Jacobi , METHOD_JOR public :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR public :: METHOD_SIP_ILU , METHOD_SIP_ICF public :: METHOD_RICHARDSON public :: METHOD_CONJUGATE_GRADIENT public :: METHOD_CONJUGATE_RESIDUAL public :: METHOD_CGNE , METHOD_CGNR public :: METHOD_GMRES public :: IterativeMethodRequirements public :: Norm_used public :: NORM_2 , NORM_1 , NORM_INF public :: relaxation_factor_used public :: RELAXATION_FACTOR_NONE , RELAXATION_FACTOR_OMEGA , RELAXATION_FACTOR_ALPHA integer , parameter :: CK = selected_char_kind ( 'ISO_10646' ) character ( KIND = ucs4 , LEN = 4 ), parameter :: none = \"None\" character ( KIND = ucs4 , LEN = 1 ), parameter :: omega = char ( int ( z '03C9' ), ucs4 ) character ( KIND = ucs4 , LEN = 1 ), parameter :: alpha = char ( int ( z '03B1' ), ucs4 ) type :: MethodTypeIterative integer :: id character ( LEN = 64 ) :: name character ( LEN = 64 ) :: name2 = \"\" end type MethodTypeIterative type :: IterativeMethodRequirements logical :: needs_SPD = . false . logical :: needs_diag_dom = . false . logical :: needs_square = . false . logical :: needs_symetric = . false . end type IterativeMethodRequirements type :: Norm_used integer :: id character ( LEN = 64 ) :: name end type Norm_used type :: relaxation_factor_used integer :: id character ( KIND = ucs4 , LEN = 64 ) :: name end type relaxation_factor_used type ( MethodTypeIterative ), parameter :: METHOD_ITERATIVE_NONE = & MethodTypeIterative ( 0 , & \"None\" ) type ( MethodTypeIterative ), parameter :: METHOD_Jacobi = & MethodTypeIterative ( 1 , & \"Jacobi\" ) type ( MethodTypeIterative ), parameter :: METHOD_GAUSS_SEIDEL = & MethodTypeIterative ( 2 , & \"Gauss-Seidel\" ) type ( MethodTypeIterative ), parameter :: METHOD_SOR = & MethodTypeIterative ( 3 , & \"Successive Over-Relaxation\" ) type ( MethodTypeIterative ), parameter :: METHOD_JOR = & MethodTypeIterative ( 4 , & \"Jacobi Over-Relaxation\" ) type ( MethodTypeIterative ), parameter :: METHOD_SIP_ILU = & MethodTypeIterative ( 5 , & \"Strongly Implicit Procedure\" , & \"ILU\" ) type ( MethodTypeIterative ), parameter :: METHOD_SIP_ICF = & MethodTypeIterative ( 6 , & \"Strongly Implicit Procedure\" , & \"ICF\" ) type ( MethodTypeIterative ), parameter :: METHOD_SSOR = & MethodTypeIterative ( 7 , & \"Symmetric Successive & &Over-Relaxation\" ) type ( MethodTypeIterative ), parameter :: METHOD_RICHARDSON = & MethodTypeIterative ( 8 , & \"Richardson\" ) type ( MethodTypeIterative ), parameter :: METHOD_CONJUGATE_GRADIENT = & MethodTypeIterative ( 9 , & \"Conjugate Gradient\" ) type ( MethodTypeIterative ), parameter :: METHOD_CONJUGATE_RESIDUAL = & MethodTypeIterative ( 10 , & \"Conjugate Residual\" ) type ( MethodTypeIterative ), parameter :: METHOD_CGNE = & MethodTypeIterative ( 11 , & \"Conjugate Gradient on & &Normal Equations\" ) type ( MethodTypeIterative ), parameter :: METHOD_CGNR = & MethodTypeIterative ( 12 , & \"Conjugate Gradient on & &Normal Residual\" ) type ( MethodTypeIterative ), parameter :: METHOD_GMRES = & MethodTypeIterative ( 13 , & \"Generalized Minimal Residual\" ) type ( Norm_used ), parameter :: NORM_2 = Norm_used ( 1 , \"Norm L2 or Euclidean\" ) type ( Norm_used ), parameter :: NORM_1 = Norm_used ( 2 , \"Norm L1 or Manhattan\" ) type ( Norm_used ), parameter :: NORM_INF = Norm_used ( 3 , \"Norm LInfini or Maximum\" ) type ( relaxation_factor_used ), parameter :: RELAXATION_FACTOR_NONE = & relaxation_factor_used ( 0 , none ) type ( relaxation_factor_used ), parameter :: RELAXATION_FACTOR_OMEGA = & relaxation_factor_used ( 1 , omega ) type ( relaxation_factor_used ), parameter :: RELAXATION_FACTOR_ALPHA = & relaxation_factor_used ( 2 , alpha ) end module NAFPack_Iterative_types","tags":"","url":"sourcefile\\nafpack_iterative_types.f90.html"},{"title":"NAFPack_matrix_properties.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_properties.f90~~EfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_properties.f90~~AfferentGraph sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_matrix_properties use NAFPack_kinds , only : dp use NAFPack_constant , only : TOL_TEST_dp use NAFPack_matricielle , only : Identity_n , Diag use NAFPack_Eigen , only : Eigen implicit none ( type , external ) private public :: is_square_matrix , is_symmetric , is_orthogonal , is_SPD , is_tridiagonal , & is_diagonally_dominant , is_non_zero_diagonal contains function is_square_matrix ( A ) result ( is_square ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_square is_square = ( size ( A , 1 ) == size ( A , 2 )) end function is_square_matrix function is_symmetric ( A ) result ( is_sym ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_sym is_sym = all ( A == transpose ( A )) end function is_symmetric function is_orthogonal ( A ) result ( is_orth ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_orth is_orth = all ( abs ( matmul ( A , transpose ( A )) - Identity_n ( size ( A , 1 ))) < TOL_TEST_dp ) end function is_orthogonal function is_SPD ( A , is_sym ) result ( is_spd_matrix ) real ( dp ), dimension (:, :), intent ( in ) :: A logical , optional , intent ( in ) :: is_sym real ( dp ), dimension ( size ( A , 1 )) :: lambda logical :: is_spd_matrix if ( present ( is_sym )) then if (. not . is_sym ) then is_spd_matrix = . false . return end if else if (. not . is_symmetric ( A )) then is_spd_matrix = . false . return end if call Eigen ( A , lambda , method = \"Power_iteration\" ) if ( minval ( lambda ) < 0 ) then is_spd_matrix = . false . else is_spd_matrix = . true . end if end function is_SPD function is_tridiagonal ( A ) result ( is_tridiag ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_tridiag integer :: i , j , N N = size ( A , 1 ) is_tridiag = . true . do i = 1 , N do j = 1 , N if ( abs ( i - j ) > 1 ) then if ( abs ( A ( i , j )) > TOL_TEST_dp ) then is_tridiag = . false . return end if end if end do end do end function is_tridiagonal function is_diagonally_dominant ( A ) result ( is_diag_dom ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_diag_dom integer :: i , N real ( dp ) :: row_sum N = size ( A , 1 ) is_diag_dom = . true . do i = 1 , N row_sum = sum ( abs ( A ( i , :))) - abs ( A ( i , i )) if ( abs ( A ( i , i )) < row_sum ) then is_diag_dom = . false . return end if end do end function is_diagonally_dominant function is_non_zero_diagonal ( A ) result ( is_non_zero_diag ) real ( dp ), dimension (:, :), intent ( in ) :: A logical :: is_non_zero_diag is_non_zero_diag = . true . if ( any ( abs ( Diag ( A )) < TOL_TEST_dp )) is_non_zero_diag = . false . end function is_non_zero_diagonal end module NAFPack_matrix_properties","tags":"","url":"sourcefile\\nafpack_matrix_properties.f90.html"},{"title":"NAFPack_Fourier_Transform_fft3.f90 – NAFPack","text":"Source Code","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft3.f90.html"},{"title":"NAFPack_io_utils.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_io_utils.f90~~EfferentGraph sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_io_utils.f90~~AfferentGraph sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_ansi_ascii.f90 NAFPack_ANSI_ASCII.f90 sourcefile~nafpack_ansi_ascii.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_ansi_ucs4.f90 NAFPack_ANSI_ucs4.f90 sourcefile~nafpack_ansi_ucs4.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_io_utils use NAFPack_kinds , only : ascii , ucs4 , & sp , dp , qp , & i8 , i16 , isp , idp implicit none ( type , external ) private public :: to_str_ascii , to_str_ucs4 interface to_str_ascii module procedure int8_to_str_ascii module procedure int16_to_str_ascii end interface to_str_ascii interface to_str_ucs4 module procedure int8_to_str_ucs4 module procedure int16_to_str_ucs4 end interface to_str_ucs4 contains pure function int8_to_str_ascii ( value ) result ( str ) integer ( i8 ), intent ( in ) :: value character ( len = :, kind = ascii ), allocatable :: str character ( len = 64 , kind = ascii ) :: buffer integer :: nlen write ( buffer , '(I0)' ) value nlen = len_trim ( buffer ) allocate ( character ( len = nlen , kind = ascii ) :: str ) str = buffer ( 1 : nlen ) end function int8_to_str_ascii pure function int16_to_str_ascii ( value ) result ( str ) integer ( i16 ), intent ( in ) :: value character ( len = :, kind = ascii ), allocatable :: str character ( len = 64 , kind = ascii ) :: buffer integer :: nlen write ( buffer , '(I0)' ) value nlen = len_trim ( buffer ) allocate ( character ( len = nlen , kind = ascii ) :: str ) str = buffer ( 1 : nlen ) end function int16_to_str_ascii pure function int8_to_str_ucs4 ( value ) result ( str ) integer ( i8 ), intent ( in ) :: value character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 64 , kind = ucs4 ) :: buffer integer :: nlen write ( buffer , '(I0)' ) value nlen = len_trim ( buffer ) allocate ( character ( len = nlen , kind = ucs4 ) :: str ) str = buffer ( 1 : nlen ) end function int8_to_str_ucs4 pure function int16_to_str_ucs4 ( value ) result ( str ) integer ( i16 ), intent ( in ) :: value character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 64 , kind = ucs4 ) :: buffer integer :: nlen write ( buffer , '(I0)' ) value nlen = len_trim ( buffer ) allocate ( character ( len = nlen , kind = ucs4 ) :: str ) str = buffer ( 1 : nlen ) end function int16_to_str_ucs4 end module NAFPack_io_utils","tags":"","url":"sourcefile\\nafpack_io_utils.f90.html"},{"title":"NAFPack_terminal.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_terminal.f90~~EfferentGraph sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_terminal.f90~~AfferentGraph sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_terminal use NAFPack_kinds , only : ascii , ucs4 ! ASCII colors for the terminal ! use NAFPack_terminal_colors, only: & !     red_color, green_color, yellow_color, blue_color, & !     white_color, cyan_color, purple_color, reset_color ! ! UCS4 colors for the terminal (Unicode) ! use NAFPack_terminal_colors, only: & !     red_color_ucs4, green_color_ucs4, yellow_color_ucs4, blue_color_ucs4, & !     white_color_ucs4, cyan_color_ucs4, purple_color_ucs4, reset_color_ucs4 use NAFPack_ANSI , only : output_unit , ColorsAscii , ColorsUcs4 implicit none ( type , external ) interface print_colored_message module procedure print_colored_message_ucs4 module procedure print_colored_message_ascii end interface print_colored_message private public :: output_unit , print_colored_message contains subroutine print_colored_message_ascii ( color , message ) character ( kind = ascii , len =* ), intent ( in ) :: message character ( kind = ascii , len =* ), intent ( in ) :: color type ( ColorsAscii ) :: ansii_colors CALL ansii_colors % init () open ( output_unit , encoding = 'DEFAULT' ) write ( output_unit , '(A)' , advance = 'no' ) trim ( color ) write ( output_unit , '(A)' , advance = 'no' ) trim ( message ) write ( output_unit , '(A)' , advance = 'yes' ) trim ( ansii_colors % reset ) close ( output_unit ) end subroutine print_colored_message_ascii subroutine print_colored_message_ucs4 ( color , message ) character ( kind = ucs4 , len =* ), intent ( in ) :: message character ( kind = ucs4 , len =* ), intent ( in ) :: color type ( ColorsUcs4 ) :: ucs4_colors CALL ucs4_colors % init () open ( output_unit , encoding = 'UTF-8' ) write ( output_unit , '(A)' , advance = 'no' ) trim ( color ) write ( output_unit , '(A)' , advance = 'no' ) trim ( message ) write ( output_unit , '(A)' , advance = 'yes' ) trim ( ucs4_colors % reset ) close ( output_unit ) end subroutine print_colored_message_ucs4 end module NAFPack_terminal","tags":"","url":"sourcefile\\nafpack_terminal.f90.html"},{"title":"NAFPack_meshgrid_integer_3D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_integer_3d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_integer_3d_compute.f90 NAFPack_meshgrid_integer_3D_compute.f90 sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90->sourcefile~nafpack_meshgrid_integer_3d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_integer_3D ) NAFPack_meshgrid_integer_3D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of three integer vectors in 8-bit !================================================================================= module subroutine compute_meshgrid_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i8 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_3D_i8 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_3D_i8 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_3D_i8 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_3D_i8 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_3D_i8 pure subroutine compute_do_classic_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i8 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_integer_3D_i8 pure subroutine compute_do_vectorized_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i8 ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_integer_3D_i8 pure subroutine compute_do_concurrent_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i8 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_integer_3D_i8 subroutine compute_openmp_integer_3D_i8 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads integer ( i8 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_3D_i8 !================================================================================= ! Compute the meshgrid of three integer vectors in 16-bit !================================================================================= module subroutine compute_meshgrid_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i16 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_3D_i16 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_3D_i16 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_3D_i16 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_3D_i16 ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_3D_i16 pure subroutine compute_do_classic_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i16 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_integer_3D_i16 pure subroutine compute_do_vectorized_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i16 ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_integer_3D_i16 pure subroutine compute_do_concurrent_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( i16 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_integer_3D_i16 subroutine compute_openmp_integer_3D_i16 ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads integer ( i16 ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_3D_i16 !================================================================================= ! Compute the meshgrid of three integer vectors in 32-bit (single precision) !================================================================================= module subroutine compute_meshgrid_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_3D_isp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_3D_isp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_3D_isp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_3D_isp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_3D_isp pure subroutine compute_do_classic_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( isp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_integer_3D_isp pure subroutine compute_do_vectorized_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( isp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_integer_3D_isp pure subroutine compute_do_concurrent_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( isp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_integer_3D_isp subroutine compute_openmp_integer_3D_isp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads integer ( isp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_3D_isp !================================================================================= ! Compute the meshgrid of three integer vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( idp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_3D_idp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_3D_idp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_3D_idp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_3D_idp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_3D_idp pure subroutine compute_do_classic_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( idp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_integer_3D_idp pure subroutine compute_do_vectorized_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( idp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_integer_3D_idp pure subroutine compute_do_concurrent_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz integer ( idp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_integer_3D_idp subroutine compute_openmp_integer_3D_idp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads integer ( idp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_3D_idp end submodule NAFPack_meshgrid_integer_3D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_integer_3d_compute.f90.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_split_radix.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_fft_compute_split_radix.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft ) NAFPack_Fourier_Transform_fft_compute_split_radix implicit none ( type , external ) contains module function compute_fft_split_radix_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) ! else if (loop_method%use_vectorized) then !     result = compute_vectorized_cmplx_sp( & !              signal, plan, stage_params) ! else if (loop_method%use_do_concurrent) then !     result = compute_do_concurrent_cmplx_sp( & !              signal, plan, stage_params) ! else if (loop_method%parallel%use_openmp) then !     result = compute_openmp_cmplx_sp( & !              signal, plan, stage_params, & !              loop_method%parallel%num_threads) end if end function compute_fft_split_radix_cmplx_sp pure function compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result result = signal if ( stage_params % block_size < 1 ) then call apply_radix2_stage ( result , plan % N ) else call apply_split_radix_stage ( result , plan , stage_params ) end if end function compute_do_classic_cmplx_sp pure subroutine apply_radix2_stage ( result , N ) complex ( sp ), dimension (:), intent ( inout ) :: result integer ( isp ), intent ( in ) :: N integer ( isp ) :: max_iter_radix2 , j , start_index , stride max_iter_radix2 = nint ( log ( real ( N )) / log ( 4.0 )) stride = 4 start_index = 1 do j = 1 , max_iter_radix2 call process_radix2_butterflies ( result , start_index , stride , N ) start_index = 2 * stride - 1 stride = 4 * stride end do end subroutine apply_radix2_stage pure subroutine process_radix2_butterflies ( result , start_index , stride , N ) complex ( sp ), dimension (:), intent ( inout ) :: result integer ( isp ), intent ( in ) :: start_index , stride , N integer ( isp ) :: i0 , i1 complex ( sp ) :: even , odd do i0 = start_index , N , stride i1 = i0 + 1 if ( i1 > N ) cycle even = result ( i0 ) odd = result ( i1 ) result ( i0 ) = even + odd result ( i1 ) = even - odd end do end subroutine process_radix2_butterflies pure subroutine apply_split_radix_stage ( result , plan , stage_params ) complex ( sp ), dimension (:), intent ( inout ) :: result type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params integer ( isp ) :: j complex ( sp ) :: twiddles_wk , twiddles_w3k do j = 1 , stage_params % block_size ! load twiddle factors for this j twiddles_wk = plan % split_radix_twiddles ( stage_params % stage )% twiddles_wk ( j ) twiddles_w3k = plan % split_radix_twiddles ( stage_params % stage )% twiddles_w3k ( j ) ! process all internal stages for this j call process_split_radix_stages_for_j ( result , plan , stage_params , j , & twiddles_wk , twiddles_w3k ) end do end subroutine apply_split_radix_stage pure subroutine process_split_radix_stages_for_j ( result , plan , stage_params , j , & twiddles_wk , twiddles_w3k ) complex ( sp ), dimension (:), intent ( inout ) :: result type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params integer ( isp ), intent ( in ) :: j complex ( sp ), intent ( in ) :: twiddles_wk , twiddles_w3k integer ( isp ) :: inner_stage , start_index , stride do inner_stage = 0 , plan % split_radix_twiddles ( stage_params % stage )% indices ( j )% num_stages ! Get start index and stride for this inner stage start_index = plan % split_radix_twiddles ( stage_params % stage )% indices ( j )% start_indices ( inner_stage ) stride = plan % split_radix_twiddles ( stage_params % stage )% indices ( j )% strides ( inner_stage ) ! Process split-radix butterflies (L shaped) for this stage call process_L_butterflies ( result , plan , stage_params , & start_index , stride , & twiddles_wk , twiddles_w3k ) end do end subroutine process_split_radix_stages_for_j pure subroutine process_L_butterflies ( result , plan , stage_params , & start_index , stride , & twiddles_wk , twiddles_w3k ) complex ( sp ), dimension (:), intent ( inout ) :: result type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params integer ( isp ), intent ( in ) :: start_index , stride complex ( sp ), intent ( in ) :: twiddles_wk , twiddles_w3k integer ( isp ) :: i1 , i2 , i3 complex ( sp ) :: even1 , even2 , odd1 , odd2 complex ( sp ) :: temp_radix2 , temp_radix4 complex ( sp ) :: temp_diff_even , temp_diff_odd integer ( isp ) :: i0 do i0 = start_index , plan % N - 1 , stride i1 = i0 + stage_params % block_size i2 = i1 + stage_params % block_size i3 = i2 + stage_params % block_size if ( i3 > plan % N ) return even1 = result ( i0 ) odd1 = result ( i1 ) even2 = result ( i2 ) odd2 = result ( i3 ) select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) ! radix-2 temp_radix2 = even2 * twiddles_wk + odd2 * twiddles_w3k result ( i0 ) = even1 + temp_radix2 result ( i2 ) = even1 - temp_radix2 ! radix-4 temp_radix4 = even2 * twiddles_wk - odd2 * twiddles_w3k result ( i1 ) = odd1 - im_sp * temp_radix4 result ( i3 ) = odd1 + im_sp * temp_radix4 case ( DIF % id ) ! radix-2 result ( i0 ) = even1 + even2 result ( i1 ) = odd1 + odd2 ! radix-4 temp_diff_even = even1 - even2 temp_diff_odd = odd1 - odd2 result ( i2 ) = temp_diff_even - im_sp * temp_diff_odd * twiddles_wk result ( i3 ) = temp_diff_even + im_sp * temp_diff_odd * twiddles_w3k end select end do end subroutine process_L_butterflies end submodule NAFPack_Fourier_Transform_fft_compute_split_radix","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft_compute_split_radix.f90.html"},{"title":"NAFPack_fft.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fft.f90~~EfferentGraph sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for Fourier Transform !>  F(\\omega) = \\int_{-\\infty}&#94;{\\infty} f(t) e&#94;{-i \\omega t} dt  !> This module provides an interface for performing Fourier Transforms (FFT or DFT, IFFT) on 1D, 2D, and 3D signals. !> It supports both forward and inverse transforms. !> It allows users to choose between different methods for the Fourier Transform, such as NAFPack and FFTW. module NAFPack_fft use FFTW3 , only : c_double_complex , c_ptr , fftw_plan_dft_1d , fftw_plan_dft_2d , & fftw_plan_dft_3d , fftw_execute_dft , fftw_destroy_plan , & fftw_cleanup , fftw_init_threads , fftw_cleanup_threads , & fftw_plan_with_nthreads , FFTW_FORWARD , FFTW_BACKWARD , FFTW_ESTIMATE use NAFPack_kinds , only : dp use NAFPack_constant , only : pi => pi_dp , im => im_dp implicit none ( type , external ) private public :: FFT_1D , FFT_2D , FFT_3D public :: IFFT_1D , IFFT_2D , IFFT_3D contains !> Perform a 1D Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_DFT\": Direct Discrete Fourier Transform !> - \"NAFPack_FFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading function FFT_1D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal )) :: result if ( method == \"NAFPack_DFT\" ) then result = NAFPack_DFT_1D ( signal ) else if ( method == \"NAFPack_FFT_1D\" ) then result = NAFPack_FFT_1D ( signal ) else if ( method == \"FFTW_FFT_1D\" . and . . not . present ( threads )) then result = FFTW_FFT_1D ( signal ) else if ( method == \"FFTW_FFT_1D\" . and . present ( threads )) then result = FFTW_FFT_1D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_1D\" end if end function FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_1D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_1D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_1D\" + threads: Fast Fourier Transform using FFTW with multithreading function IFFT_1D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal )) :: result if ( method == \"NAFPack_IFFT_1D\" ) then result = NAFPack_IFFT_1D ( signal ) else if ( method == \"FFTW_IFFT_1D\" . and . . not . present ( threads )) then result = FFTW_IFFT_1D ( signal ) else if ( method == \"FFTW_IFFT_1D\" . and . present ( threads )) then result = FFTW_IFFT_1D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_FFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_FFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading function FFT_2D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result if ( method == \"NAFPack_FFT_2D\" ) then result = NAFPack_FFT_2D ( signal ) else if ( method == \"FFTW_FFT_2D\" . and . . not . present ( threads )) then result = FFTW_FFT_2D ( signal ) else if ( method == \"FFTW_FFT_2D\" . and . present ( threads )) then result = FFTW_FFT_2D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_2D\" end if end function FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"NAFPack_IFFT_2D\": Fast Fourier Transform using NAFPack !> - \"FFTW_IFFT_2D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_2D\" + threads: Fast Fourier Transform using FFTW with multithreading function IFFT_2D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result if ( method == \"NAFPack_IFFT_2D\" ) then result = NAFPack_IFFT_2D ( signal ) else if ( method == \"FFTW_IFFT_2D\" . and . . not . present ( threads )) then result = FFTW_IFFT_2D ( signal ) else if ( method == \"FFTW_IFFT_2D\" . and . present ( threads )) then result = FFTW_IFFT_2D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_2D !> Perform a 3D Fast Fourier Transform on a signal !> !> This function takes a signal and performs a Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_FFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_FFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading function FFT_3D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: result if ( method == \"FFTW_FFT_3D\" . and . . not . present ( threads )) then result = FFTW_FFT_3D ( signal ) else if ( method == \"FFTW_FFT_3D\" . and . present ( threads )) then result = FFTW_FFT_3D_threads ( signal , threads ) else stop \"ERROR : Wrong method for FFT_2D\" end if end function FFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal !> !> This function takes a signal and performs a  inverse fast Fourier Transform using the specified method. !> The available methods are: !> !> - \"FFTW_IFFT_3D\": Fast Fourier Transform using FFTW !> - \"FFTW_IFFT_3D\" + threads: Fast Fourier Transform using FFTW with multithreading function IFFT_3D ( signal , method , threads ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( inout ) :: signal character ( * ), intent ( in ) :: method integer , optional , intent ( in ) :: threads complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 ), size ( signal , 3 )) :: result if ( method == \"FFTW_IFFT_3D\" . and . . not . present ( threads )) then result = FFTW_IFFT_3D ( signal ) else if ( method == \"IFFTW_IFFT_3D\" . and . present ( threads )) then result = FFTW_IFFT_3D_threads ( signal , threads ) else stop \"ERROR : Wrong method for IFFT_1D\" end if end function IFFT_3D !################### FFTW ########################################## !> Perform a 1D Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_FFT_1D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal )) :: result integer :: error_init_thread , N type ( c_ptr ) :: plan N = size ( signal ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( N , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_FFT_1D_threads !> Perform a 1D Fast Fourier Transform on a signal using FFTW function FFTW_FFT_1D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal )) :: result type ( c_ptr ) :: plan integer :: N N = size ( signal ) plan = fftw_plan_dft_1d ( N , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW function FFTW_IFFT_1D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal )) :: result type ( c_ptr ) :: plan integer :: N N = size ( signal ) plan = fftw_plan_dft_1d ( N , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / N call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_IFFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_IFFT_1D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal )) :: result integer :: error_init_thread , N type ( c_ptr ) :: plan N = size ( signal ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( N , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / N call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_IFFT_1D_threads !> Perform a 2D Fast Fourier Transform on a signal using FFTW function FFTW_FFT_2D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:, :), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result type ( c_ptr ) :: plan integer :: N , M N = size ( signal , 1 ) M = size ( signal , 2 ) plan = fftw_plan_dft_2d ( M , N , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_FFT_2D !> Perform a 2D Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_FFT_2D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:, :), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result integer :: error_init_thread , N , M type ( c_ptr ) :: plan N = size ( signal , 1 ) M = size ( signal , 2 ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( M , N , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_FFT_2D_threads !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW function FFTW_IFFT_2D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:, :), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result type ( c_ptr ) :: plan integer :: N , M N = size ( signal , 1 ) M = size ( signal , 2 ) plan = fftw_plan_dft_2d ( M , N , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / ( N * M ) call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_IFFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_IFFT_2D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:, :), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result integer :: error_init_thread , N , M type ( c_ptr ) :: plan N = size ( signal , 1 ) M = size ( signal , 2 ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( M , N , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / ( N * M ) call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_IFFT_2D_threads !> Perform a 3D Fast Fourier Transform on a signal using FFTW function FFTW_FFT_3D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:, :, :), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: result type ( c_ptr ) :: plan integer :: N , M , P N = size ( signal , 1 ) M = size ( signal , 2 ) P = size ( signal , 3 ) plan = fftw_plan_dft_3d ( M , N , P , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_FFT_3D !> Perform a 3D Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_FFT_3D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:, :, :), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: result integer :: error_init_thread , N , M , P type ( c_ptr ) :: plan N = size ( signal , 1 ) M = size ( signal , 2 ) P = size ( signal , 3 ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( M , N , P , signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_FFT_3D_threads !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW function FFTW_IFFT_3D ( signal ) result ( result ) complex ( c_double_complex ), dimension (:, :, :), intent ( inout ) :: signal complex ( c_double_complex ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: result type ( c_ptr ) :: plan integer :: N , M , P N = size ( signal , 1 ) M = size ( signal , 2 ) P = size ( signal , 3 ) plan = fftw_plan_dft_3d ( M , N , P , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / ( N * M * P ) call fftw_destroy_plan ( plan ) call fftw_cleanup () end function FFTW_IFFT_3D !> Perform a 3D inverse Fast Fourier Transform on a signal using FFTW with multithreading function FFTW_IFFT_3D_threads ( signal , threads ) result ( result ) complex ( c_double_complex ), dimension (:, :, :), intent ( inout ) :: signal integer , intent ( in ) :: threads complex ( c_double_complex ), dimension ( size ( signal , 1 ), & size ( signal , 2 ), & size ( signal , 3 )) :: result integer :: error_init_thread , N , M , P type ( c_ptr ) :: plan N = size ( signal , 1 ) M = size ( signal , 2 ) P = size ( signal , 3 ) error_init_thread = fftw_init_threads () if ( error_init_thread == 0 ) stop \"ERROR : Thread FFTW initialization problem\" call fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( M , N , P , signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) call fftw_execute_dft ( plan , signal , result ) result = result / ( N * M * P ) call fftw_destroy_plan ( plan ) call fftw_cleanup_threads () end function FFTW_IFFT_3D_threads !################### NAFPack ########################################## !> Perform a 1D Discrete Fourier Transform on a signal function NAFPack_DFT_1D ( signal ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal complex ( dp ), dimension ( size ( signal )) :: result complex ( dp ) :: S integer :: N , i , k , j N = size ( signal ) if ( N == 1 ) then result = signal else do i = 1 , N k = i - 1 S = ( 0.d0 , 0.d0 ) do j = 1 , N S = S + signal ( j ) * exp (( - 2 * pi * im * k * ( j - 1 )) / N ) end do result ( i ) = S end do end if end function NAFPack_DFT_1D !> Compute the complex exponential factors for the FFT function fun_omega ( N ) result ( result ) integer , intent ( in ) :: N complex ( dp ), dimension ( N / 2 ) :: result integer :: i do i = 1 , N / 2 result ( i ) = exp ( - 2 * Im * pi * ( i - 1 ) / N ) end do end function fun_omega !> Perform a 1D Fast Fourier Transform (Cooley-Tukey) on a signal recursive function NAFPack_FFT_1D ( signal ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal complex ( dp ), dimension ( size ( signal )) :: result complex ( dp ), dimension ( size ( signal ) / 2 ) :: f_pair , f_impair , omega integer :: N N = size ( signal ) if ( mod ( N , 2 ) == 0 ) then f_pair = NAFPack_FFT_1D ( signal ( 1 :: 2 )) f_impair = NAFPack_FFT_1D ( signal ( 2 :: 2 )) omega = fun_omega ( N ) result ( 1 : N / 2 ) = f_pair + f_impair * omega result ( N / 2 + 1 :) = f_pair - f_impair * omega else result = NAFPack_DFT_1D ( signal ) end if end function NAFPack_FFT_1D !> Perform a 1D inverse Fast Fourier Transform on a signal function NAFPack_IFFT_1D ( f_signal ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: f_signal complex ( dp ), dimension ( size ( f_signal )) :: result complex ( dp ), dimension ( size ( f_signal )) :: f_conjugate integer :: N N = size ( f_signal ) f_conjugate = conjg ( f_signal ) result = NAFPack_FFT_1D ( f_conjugate ) result = conjg ( result ) result = result / N end function NAFPack_IFFT_1D !> Perform a 2D Fast Fourier Transform on a signal function NAFPack_FFT_2D ( signal ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: signal complex ( dp ), dimension ( size ( signal , 1 ), size ( signal , 2 )) :: result integer :: Nx , Ny , i Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) do i = 1 , Nx result ( i , :) = NAFPack_FFT_1D ( signal ( i , :)) end do do i = 1 , Ny result (:, i ) = NAFPack_FFT_1D ( result (:, i )) end do end function NAFPack_FFT_2D !> Perform a 2D inverse Fast Fourier Transform on a signal function NAFPack_IFFT_2D ( f_signal ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: f_signal complex ( dp ), dimension ( size ( f_signal , 1 ), size ( f_signal , 2 )) :: result integer :: Nx , Ny , i Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) do i = 1 , Nx result ( i , :) = NAFPack_IFFT_1D ( f_signal ( i , :)) end do do i = 1 , Ny result (:, i ) = NAFPack_IFFT_1D ( result (:, i )) end do end function NAFPack_IFFT_2D end module NAFPack_fft","tags":"","url":"sourcefile\\nafpack_fft.f90.html"},{"title":"NAFPack_Fourier_Transform.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform.f90~~EfferentGraph sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_fourier_transform.f90~~AfferentGraph sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Fourier_Transform use NAFPack_kinds , only : dp , sp , qp , i8 , i16 , isp , idp use NAFPack_constant , only : pi_sp , pi_dp , pi_qp , im_sp , im_dp , im_qp use NAFPack_loop_method , only : LoopMethod , default_loop_method , check_loop_method use NAFPack_math_utils , only : sieve_of_eratosthenes , is_power_of_two , power_of_p_exponent implicit none ( type , external ) private public :: Fourier_Transform public :: dft , idft public :: dft2 , idft2 public :: dft3 , idft3 public :: DecimationMethod , DIT , DIF public :: FFTAlgorithm , ALG_AUTO , & ALG_RADIX2_DIT , ALG_RADIX2_DIF , & ALG_MIXED_DIT , ALG_MIXED_DIF , & ALG_SPLIT_DIT , ALG_SPLIT_DIF type :: DecimationMethod integer ( isp ) :: id character ( len = 20 ) :: name end type DecimationMethod type ( DecimationMethod ), parameter :: DIT = DecimationMethod ( 1 , \"DIT\" ), & DIF = DecimationMethod ( 2 , \"DIF\" ) type :: FFTAlgorithm integer ( isp ) :: id character ( len = 20 ) :: name type ( DecimationMethod ) :: decimation_method end type FFTAlgorithm type ( FFTAlgorithm ), parameter :: & ALG_NONE = FFTAlgorithm ( - 1 , \"None\" , DIT ), & ALG_AUTO = FFTAlgorithm ( 0 , \"Auto\" , DIT ), & ALG_RADIX2_DIT = FFTAlgorithm ( 1 , \"Radix-2 DIT\" , DIT ), & ALG_RADIX2_DIF = FFTAlgorithm ( 2 , \"Radix-2 DIF\" , DIF ), & ALG_MIXED_DIT = FFTAlgorithm ( 3 , \"Mixed Radix DIT\" , DIT ), & ALG_MIXED_DIF = FFTAlgorithm ( 4 , \"Mixed Radix DIF\" , DIF ), & ALG_SPLIT_DIT = FFTAlgorithm ( 5 , \"Split Radix DIT\" , DIT ), & ALG_SPLIT_DIF = FFTAlgorithm ( 6 , \"Split Radix DIF\" , DIF ) type :: Twiddles_sp integer ( isp ) :: block_size = 0 integer ( isp ) :: current_block_size = 0 integer ( isp ) :: radix = 0 complex ( sp ), dimension (:), allocatable :: twiddles_factor end type Twiddles_sp type :: SplitRadixindices integer ( isp ) :: num_stages integer ( isp ), dimension (:), allocatable :: start_indices integer ( isp ), dimension (:), allocatable :: strides end type SplitRadixindices type :: SplitRadixTwiddles integer ( isp ) :: block_size = 0 integer ( isp ) :: current_block_size = 0 integer ( isp ) :: radix = 0 type ( SplitRadixindices ), dimension (:), allocatable :: indices complex ( sp ), dimension (:), allocatable :: twiddles_Wk complex ( sp ), dimension (:), allocatable :: twiddles_W3k end type SplitRadixTwiddles type :: FFTPlan integer ( isp ) :: N = 0 integer ( isp ), dimension (:), allocatable :: radix_plan type ( Twiddles_sp ), dimension (:), allocatable :: twiddles type ( SplitRadixTwiddles ), dimension (:), allocatable :: split_radix_twiddles logical :: is_initialized = . false . logical :: use_pure_radix2 = . false . logical :: use_split_radix = . false . logical :: use_mixed_radix = . false . type ( FFTAlgorithm ) :: algorithm = ALG_NONE end type FFTPlan type :: Fourier_Transform type ( FFTPlan ) :: fft_plan contains procedure , nopass , private :: dft_cmplx_sp , dft_cmplx_dp , dft_cmplx_qp generic :: dft => dft_cmplx_sp , dft_cmplx_dp , dft_cmplx_qp procedure , nopass , private :: dft_real_sp , dft_real_dp , dft_real_qp generic :: dft => dft_real_sp , dft_real_dp , dft_real_qp procedure , nopass , private :: dft2_cmplx_sp , dft2_cmplx_dp , dft2_cmplx_qp generic :: dft => dft2_cmplx_sp , dft2_cmplx_dp , dft2_cmplx_qp procedure , nopass , private :: dft2_real_sp , dft2_real_dp , dft2_real_qp generic :: dft => dft2_real_sp , dft2_real_dp , dft2_real_qp procedure , nopass , private :: dft3_cmplx_sp , dft3_cmplx_dp , dft3_cmplx_qp generic :: dft => dft3_cmplx_sp , dft3_cmplx_dp , dft3_cmplx_qp procedure , nopass , private :: dft3_real_sp , dft3_real_dp , dft3_real_qp generic :: dft => dft3_real_sp , dft3_real_dp , dft3_real_qp procedure , nopass , private :: idft_cmplx_sp , idft_cmplx_dp , idft_cmplx_qp generic :: idft => idft_cmplx_sp , idft_cmplx_dp , idft_cmplx_qp procedure , nopass , private :: idft_real_sp , idft_real_dp , idft_real_qp generic :: idft => idft_real_sp , idft_real_dp , idft_real_qp procedure , nopass , private :: idft2_cmplx_sp , idft2_cmplx_dp , idft2_cmplx_qp generic :: idft => idft2_cmplx_sp , idft2_cmplx_dp , idft2_cmplx_qp procedure , nopass , private :: idft2_real_sp , idft2_real_dp , idft2_real_qp generic :: idft => idft2_real_sp , idft2_real_dp , idft2_real_qp procedure , nopass , private :: idft3_cmplx_sp , idft3_cmplx_dp , idft3_cmplx_qp generic :: idft => idft3_cmplx_sp , idft3_cmplx_dp , idft3_cmplx_qp procedure , nopass , private :: idft3_real_sp , idft3_real_dp , idft3_real_qp generic :: idft => idft3_real_sp , idft3_real_dp , idft3_real_qp procedure , private :: init_fft_plan_sp generic :: init_fft_plan => init_fft_plan_sp procedure , private :: fft_cmplx_sp generic :: fft => fft_cmplx_sp procedure , private :: destroy_fft_plan_sp generic :: destroy_fft_plan => destroy_fft_plan_sp end type Fourier_Transform interface dft module procedure dft_cmplx_sp , dft_cmplx_dp , dft_cmplx_qp module procedure dft_real_sp , dft_real_dp , dft_real_qp end interface dft interface idft module procedure idft_cmplx_sp , idft_cmplx_dp , idft_cmplx_qp module procedure idft_real_sp , idft_real_dp , idft_real_qp end interface idft interface dft2 module procedure dft2_cmplx_sp , dft2_cmplx_dp , dft2_cmplx_qp module procedure dft2_real_sp , dft2_real_dp , dft2_real_qp end interface dft2 interface idft2 module procedure idft2_cmplx_sp , idft2_cmplx_dp , idft2_cmplx_qp module procedure idft2_real_sp , idft2_real_dp , idft2_real_qp end interface idft2 interface dft3 module procedure dft3_cmplx_sp , dft3_cmplx_dp , dft3_cmplx_qp module procedure dft3_real_sp , dft3_real_dp , dft3_real_qp end interface dft3 interface idft3 module procedure idft3_cmplx_sp , idft3_cmplx_dp , idft3_cmplx_qp module procedure idft3_real_sp , idft3_real_dp , idft3_real_qp end interface idft3 !==================================================================================== ! FFT plan creation and initialization !==================================================================================== interface module subroutine init_fft_plan_sp ( this , N , algorithm , decimation_method ) class ( Fourier_Transform ), intent ( inout ) :: this type ( FFTAlgorithm ), optional , intent ( in ) :: algorithm type ( DecimationMethod ), optional , intent ( in ) :: decimation_method integer ( isp ), intent ( in ) :: N end subroutine init_fft_plan_sp end interface !==================================================================================== ! compute FFT !==================================================================================== interface module function fft_cmplx_sp ( this , signal , loop_method ) result ( result ) class ( Fourier_Transform ), intent ( inout ) :: this complex ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result end function fft_cmplx_sp end interface !==================================================================================== ! destr interface pure module subroutine destroy_fft_plan_sp ( this ) class ( Fourier_Transform ), intent ( inout ) :: this end subroutine destroy_fft_plan_sp end interface !==================================================================================== ! DFT and IDFT for 1D, 2D, and 3D signals !==================================================================================== interface module function dft_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result end function dft_cmplx_sp module function dft_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result end function dft_cmplx_dp module function dft_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result end function dft_cmplx_qp end interface interface module function idft_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result end function idft_cmplx_sp module function idft_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result end function idft_cmplx_dp module function idft_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result end function idft_cmplx_qp end interface interface module function dft_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result end function dft_real_sp module function dft_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result end function dft_real_dp module function dft_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result end function dft_real_qp end interface interface module function idft_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:), allocatable :: result end function idft_real_sp module function idft_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:), allocatable :: result end function idft_real_dp module function idft_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:), allocatable :: result end function idft_real_qp end interface interface module function dft2_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result end function dft2_cmplx_sp module function dft2_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result end function dft2_cmplx_dp module function dft2_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result end function dft2_cmplx_qp end interface interface module function idft2_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result end function idft2_cmplx_sp module function idft2_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result end function idft2_cmplx_dp module function idft2_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result end function idft2_cmplx_qp end interface interface module function dft2_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result end function dft2_real_sp module function dft2_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result end function dft2_real_dp module function dft2_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result end function dft2_real_qp end interface interface module function idft2_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result end function idft2_real_sp module function idft2_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result end function idft2_real_dp module function idft2_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result end function idft2_real_qp end interface interface module function dft3_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result end function dft3_cmplx_sp module function dft3_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result end function dft3_cmplx_dp module function dft3_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result end function dft3_cmplx_qp end interface interface module function idft3_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result end function idft3_cmplx_sp module function idft3_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result end function idft3_cmplx_dp module function idft3_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result end function idft3_cmplx_qp end interface interface module function dft3_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result end function dft3_real_sp module function dft3_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result end function dft3_real_dp module function dft3_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:, :, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result end function dft3_real_qp end interface interface module function idft3_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :, :), allocatable :: result end function idft3_real_sp module function idft3_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :, :), allocatable :: result end function idft3_real_dp module function idft3_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:, :, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :, :), allocatable :: result end function idft3_real_qp end interface !==================================================================================== ! FFT and IFFT for 1D, 2D, and 3D signals !==================================================================================== end module NAFPack_Fourier_Transform","tags":"","url":"sourcefile\\nafpack_fourier_transform.f90.html"},{"title":"NAFPack_matrix_market.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_market.f90~~EfferentGraph sourcefile~nafpack_matrix_market.f90 NAFPack_matrix_market.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_matrix_market.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_matrix_market use NAFPack_kinds , only : dp implicit none ( type , external ) private public :: readMatrixMarket contains subroutine readMatrixMarket ( filename , A ) character ( LEN =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), allocatable , intent ( out ) :: A integer :: i , j , nrows , ncols , nnz , ios , k , row_idx , col_idx character ( LEN = 256 ) :: line , header character ( LEN = 50 ) :: object , format_type , field , symmetry integer :: unit real ( dp ) :: val unit = 10 ! Open the file open ( NEWUNIT = unit , FILE = filename , STATUS = 'old' , ACTION = 'read' , IOSTAT = ios ) if ( ios /= 0 ) then print * , 'Error: opening file: ' , filename stop end if ! read the header read ( unit , '(A)' , IOSTAT = ios ) header if ( ios /= 0 ) then print * , 'Error: reading header Matrix Market' close ( unit ) stop end if ! Check Matrix Market format if ( index ( header , '%%MatrixMarket' ) == 0 ) then print * , 'Error: file is not in Matrix Market format' close ( unit ) return end if ! Parse the header to extract information read ( header , * , iostat = ios ) object , object , format_type , field , symmetry if ( ios /= 0 ) then print * , 'Error reading Matrix Market header' close ( unit ) stop end if ! Skip comment lines and find the size line do read ( unit , '(A)' , IOSTAT = ios ) line if ( ios /= 0 ) then print * , 'Error: malformed file' close ( unit ) stop end if if ( line ( 1 : 1 ) /= '%' ) then exit end if end do ! Read matrix dimensions read ( line , * , iostat = ios ) nrows , ncols , nnz if ( ios /= 0 ) then print * , 'Error: unable to read dimensions' close ( unit ) return end if allocate ( A ( nrows , ncols )) A = 0.0_dp ! Read matrix entries if ( trim ( format_type ) == 'coordinate' ) then ! Coordinate format (sparse) do k = 1 , nnz read ( unit , * , iostat = ios ) row_idx , col_idx , val if ( ios /= 0 ) then print * , 'Error: reading entry' , k exit end if A ( row_idx , col_idx ) = val ! If the matrix is symmetric, also fill A(j,i) if ( trim ( symmetry ) == 'symmetric' . and . row_idx /= col_idx ) then A ( col_idx , row_idx ) = val end if end do else if ( trim ( format_type ) == 'array' ) then ! Dense format (array) do j = 1 , ncols do i = 1 , nrows read ( unit , * , iostat = ios ) val if ( ios /= 0 ) then print * , 'Error: reading element (' , i , ',' , j , ')' close ( unit ) return end if A ( i , j ) = val end do end do else print * , 'Error: unsupported format: ' , trim ( format_type ) close ( unit ) return end if close ( unit ) end subroutine readMatrixMarket end module NAFPack_matrix_market","tags":"","url":"sourcefile\\nafpack_matrix_market.f90.html"},{"title":"NAFPack_linalg.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_linalg.f90~~EfferentGraph sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_linalg use NAFPack_Direct_types , only : MethodTypeDirect , METHOD_DIRECT_NONE , & METHOD_CHOLESKY , METHOD_LDL_Cholesky , & METHOD_FADDEEV_LEVERRIER , & METHOD_Gauss , METHOD_Gauss_JORDAN , & METHOD_LU , METHOD_LDU , & METHOD_QR , METHOD_TDMA , & DirectMethodRequirements , MethodQR , & QR_HOUSEHOLDER , QR_GIVENS , & QR_GRAM_SCHMIDT , QR_GRAM_SCHMIDT_Modified use NAFPack_Direct_method , only : DirectMethod use NAFPack_Iterative_types , only : MethodTypeIterative , METHOD_ITERATIVE_NONE , & METHOD_Jacobi , METHOD_JOR , & METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR , & METHOD_SIP_ILU , METHOD_SIP_ICF , & METHOD_RICHARDSON , & METHOD_CONJUGATE_GRADIENT , METHOD_CONJUGATE_RESIDUAL , & METHOD_CGNE , METHOD_CGNR , & METHOD_GMRES , & IterativeMethodRequirements , & Norm_used , NORM_2 , NORM_1 , NORM_INF , & relaxation_factor_used , RELAXATION_FACTOR_NONE , & RELAXATION_FACTOR_OMEGA , RELAXATION_FACTOR_ALPHA use NAFPack_Iterative_Params , only : IterativeParams use NAFPack_Preconditioners , only : FILL_LEVEL_USED , FILL_LEVEL_NONE , & FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 , & FILL_LEVEL_N , & MethodPreconditioner , METHOD_PRECOND_NONE , & METHOD_PRECOND_JACOBI , METHOD_PRECOND_GS , & METHOD_PRECOND_SOR , METHOD_PRECOND_JOR , & METHOD_PRECOND_ILU , METHOD_PRECOND_ICF , & METHOD_PRECOND_SSOR , & Calculate_Gauss_Seidel_preconditioner , & Calculate_ICF_preconditioner , & Calculate_ILU_preconditioner , & Calculate_Jacobi_preconditioner , & Calculate_JOR_preconditioner , & Calculate_SOR_preconditioner , & Calculate_SSOR_preconditioner use NAFPack_Iterative_methods , only : IterativeMethod implicit none ( type , external ) private public :: linalg , DirectMethod , IterativeMethod public :: MethodTypeDirect , MethodQR public :: METHOD_DIRECT_NONE public :: METHOD_Gauss , METHOD_Gauss_JORDAN public :: METHOD_LU , METHOD_LDU public :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR public :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER public :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT public :: QR_GRAM_SCHMIDT_Modified public :: IterativeParams public :: METHOD_ITERATIVE_NONE public :: METHOD_Jacobi , METHOD_JOR public :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR public :: METHOD_SIP_ILU , METHOD_SIP_ICF public :: METHOD_RICHARDSON public :: METHOD_CONJUGATE_GRADIENT public :: METHOD_CONJUGATE_RESIDUAL public :: METHOD_CGNE , METHOD_CGNR public :: METHOD_GMRES public :: MethodPreconditioner public :: METHOD_PRECOND_NONE public :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR public :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR public :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF public :: Norm_used public :: NORM_2 , NORM_1 , NORM_INF public :: FILL_LEVEL_USED public :: FILL_LEVEL_NONE public :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 public :: FILL_LEVEL_N type :: linalg type ( DirectMethod ) :: direct type ( IterativeMethod ) :: iterative end type linalg contains end module NAFPack_linalg","tags":"","url":"sourcefile\\nafpack_linalg.f90.html"},{"title":"NAFPack_Iterative_methods.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_methods.f90~~EfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_memory_monitor.f90 NAFPack_memory_monitor.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_memory_monitor.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_methods.f90~~AfferentGraph sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !========================================================== ! NAFPack_Iterative_methods.f90 ! Module for iterative methods in NAFPack !========================================================== !> Module for iterative methods in NAFPack module NAFPack_Iterative_methods use NAFPack_kinds , only : dp , ucs4 use NAFPack_matrix_decomposition , only : forward , backward , & Incomplete_Cholesky_decomposition , ILU_decomposition use NAFPack_Iterative_types , only : MethodTypeIterative , METHOD_ITERATIVE_NONE , & METHOD_Jacobi , METHOD_JOR , & METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR , & METHOD_SIP_ILU , METHOD_SIP_ICF , & METHOD_RICHARDSON , & METHOD_CONJUGATE_GRADIENT , METHOD_CONJUGATE_RESIDUAL , & METHOD_CGNE , METHOD_CGNR , & METHOD_GMRES , & IterativeMethodRequirements , & Norm_used , NORM_2 , NORM_1 , NORM_INF , & relaxation_factor_used , RELAXATION_FACTOR_NONE , & RELAXATION_FACTOR_OMEGA , RELAXATION_FACTOR_ALPHA use NAFPack_Logger_mod , only : Logger , center_with_fill , log_field use NAFPack_Preconditioners , only : FILL_LEVEL_USED , FILL_LEVEL_NONE , & FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 , & FILL_LEVEL_N , & MethodPreconditioner , METHOD_PRECOND_NONE , & METHOD_PRECOND_JACOBI , METHOD_PRECOND_GS , & METHOD_PRECOND_SOR , METHOD_PRECOND_JOR , & METHOD_PRECOND_ILU , METHOD_PRECOND_ICF , & METHOD_PRECOND_SSOR , & Calculate_Gauss_Seidel_preconditioner , & Calculate_ICF_preconditioner , & Calculate_ILU_preconditioner , & Calculate_Jacobi_preconditioner , & Calculate_JOR_preconditioner , & Calculate_SOR_preconditioner , & Calculate_SSOR_preconditioner use NAFPack_Iterative_Params , only : IterativeParams , ApplyPreconditioner use NAFPack_matrix_properties , only : is_square_matrix , is_SPD , & is_diagonally_dominant , is_symmetric use NAFPack_memory_monitor , only : get_memory_kb implicit none ( type , external ) private public :: IterativeMethod public :: IterativeParams public :: MethodTypeIterative public :: METHOD_ITERATIVE_NONE public :: METHOD_Jacobi , METHOD_JOR public :: METHOD_GAUSS_SEIDEL , METHOD_SOR , METHOD_SSOR public :: METHOD_SIP_ILU , METHOD_SIP_ICF public :: METHOD_RICHARDSON public :: METHOD_CONJUGATE_GRADIENT public :: METHOD_CONJUGATE_RESIDUAL public :: METHOD_CGNR , METHOD_CGNE public :: METHOD_GMRES public :: MethodPreconditioner public :: METHOD_PRECOND_NONE public :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR public :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR public :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF public :: Norm_used public :: NORM_2 , NORM_1 , NORM_INF public :: FILL_LEVEL_USED public :: FILL_LEVEL_NONE public :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 public :: FILL_LEVEL_N !====================== ! Type definitions !====================== type :: IterativeMethod private type ( MethodTypeIterative ) :: method_type = METHOD_ITERATIVE_NONE type ( MethodPreconditioner ) :: preconditioner_type = METHOD_PRECOND_NONE type ( IterativeMethodRequirements ) :: requirements type ( relaxation_factor_used ) :: relaxation_factor = RELAXATION_FACTOR_NONE type ( relaxation_factor_used ) :: relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE procedure ( solve_interface_Iterative ), pass ( this ), pointer :: solve_method => null () contains procedure :: set_method => set_method procedure :: solve => IterativeMethod_solve procedure :: Init_IterativeParams => Init_IterativeParams procedure :: Dealocate_IterativeParams => Dealocate_IterativeParams procedure :: test_matrix => test_matrix end type IterativeMethod !====================== ! Interface !====================== abstract interface function solve_interface_Iterative ( this , A , b , x0 , params ) result ( x ) import :: dp import :: IterativeParams import :: IterativeMethod implicit none ( type , external ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x end function solve_interface_Iterative end interface contains !====================== ! Management of iterative methods !====================== subroutine set_method ( this , method ) class ( IterativeMethod ), intent ( inout ) :: this type ( MethodTypeIterative ), intent ( in ) :: method this % requirements = IterativeMethodRequirements () select case ( method % id ) case ( METHOD_Jacobi % id ) this % solve_method => solve_Jacobi this % method_type = METHOD_Jacobi this % requirements % needs_square = . true . this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . case ( METHOD_GAUSS_SEIDEL % id ) this % solve_method => solve_Gauss_Seidel this % method_type = METHOD_GAUSS_SEIDEL this % requirements % needs_square = . true . this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . case ( METHOD_SOR % id ) this % solve_method => solve_SOR this % method_type = METHOD_SOR this % requirements % needs_square = . true . this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . this % relaxation_factor = RELAXATION_FACTOR_OMEGA case ( METHOD_JOR % id ) this % solve_method => solve_JOR this % method_type = METHOD_JOR this % requirements % needs_square = . true . this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . this % relaxation_factor = RELAXATION_FACTOR_OMEGA case ( METHOD_SIP_ILU % id ) this % solve_method => solve_SIP_ILU this % method_type = METHOD_SIP_ILU this % requirements % needs_square = . true . this % relaxation_factor = RELAXATION_FACTOR_OMEGA case ( METHOD_SIP_ICF % id ) this % solve_method => solve_SIP_ICF this % method_type = METHOD_SIP_ICF this % requirements % needs_square = . true . this % requirements % needs_SPD = . true . this % relaxation_factor = RELAXATION_FACTOR_OMEGA case ( METHOD_SSOR % id ) this % solve_method => solve_SSOR this % method_type = METHOD_SSOR this % requirements % needs_square = . true . this % requirements % needs_SPD = . true . this % relaxation_factor = RELAXATION_FACTOR_OMEGA case ( METHOD_RICHARDSON % id ) this % solve_method => solve_Richardson this % method_type = METHOD_RICHARDSON this % requirements % needs_square = . true . this % requirements % needs_SPD = . true . this % relaxation_factor = RELAXATION_FACTOR_ALPHA case ( METHOD_CONJUGATE_GRADIENT % id ) this % solve_method => solve_ConjugateGradient this % method_type = METHOD_CONJUGATE_GRADIENT this % requirements % needs_square = . true . this % requirements % needs_SPD = . true . case ( METHOD_CONJUGATE_RESIDUAL % id ) this % solve_method => solve_ConjugateResidual this % method_type = METHOD_CONJUGATE_RESIDUAL this % requirements % needs_square = . true . this % requirements % needs_symetric = . true . case ( METHOD_CGNR % id ) this % solve_method => solve_CGNR this % method_type = METHOD_CGNR case ( METHOD_CGNE % id ) this % solve_method => solve_CGNE this % method_type = METHOD_CGNE case ( METHOD_GMRES % id ) this % solve_method => solve_GMRES this % method_type = METHOD_GMRES this % requirements % needs_square = . true . case DEFAULT stop \"ERROR :: Unknown method iterative\" end select end subroutine set_method function Init_IterativeParams ( this , N , A , x0 , max_iter_choice , epsi_tol , omega , Norm_choice , & fill_level , method_preconditioner , alpha , is_stationary , & is_strict_mode ) result ( params ) class ( IterativeMethod ), intent ( inout ) :: this integer , intent ( in ) :: N real ( dp ), dimension (:, :), optional , intent ( in ) :: A real ( dp ), dimension (:), optional , intent ( in ) :: x0 integer , optional , intent ( in ) :: max_iter_choice real ( dp ), optional , intent ( in ) :: epsi_tol real ( dp ), optional , intent ( in ) :: omega real ( dp ), optional , intent ( in ) :: alpha type ( Norm_used ), optional , intent ( in ) :: Norm_choice type ( MethodPreconditioner ), optional , intent ( in ) :: method_preconditioner logical , optional , intent ( in ) :: is_stationary logical , optional , intent ( in ) :: is_strict_mode type ( FILL_LEVEL_USED ), optional , intent ( in ) :: fill_level type ( IterativeParams ) :: params integer :: allocate_status allocate ( params % x_init ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate x_init\" if ( present ( x0 )) then params % x_init = x0 else params % x_init = 0.0_dp end if if ( present ( max_iter_choice )) params % max_iter = 1000 if ( present ( epsi_tol )) params % tol = 1.0e-6_dp if ( present ( omega )) params % omega = omega if ( present ( alpha )) params % alpha = alpha if ( present ( Norm_choice )) params % norm = Norm_choice if ( present ( fill_level )) params % fill_level = fill_level allocate ( params % residual ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate residual\" select case ( this % method_type % id ) case ( METHOD_SIP_ILU % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" allocate ( params % U ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate U\" call ILU_decomposition ( A , params % L , params % U ) case ( METHOD_SIP_ICF % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" call Incomplete_Cholesky_decomposition ( A , params % L ) case ( METHOD_CONJUGATE_GRADIENT % id ) allocate ( params % p ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) then stop \"ERROR :: Unable to allocate optimal descent direction p\" end if case ( METHOD_CONJUGATE_RESIDUAL % id ) allocate ( params % p ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) then stop \"ERROR :: Unable to allocate optimal descent direction p\" end if case ( METHOD_CGNR % id ) allocate ( params % p ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) then stop \"ERROR :: Unable to allocate optimal descent direction p\" end if case ( METHOD_CGNE % id ) allocate ( params % p ( N ), STAT = allocate_status ) if ( allocate_status /= 0 ) then stop \"ERROR :: Unable to allocate optimal descent direction p\" end if end select if ( present ( method_preconditioner )) then params % precond => ApplyPreconditioner select case ( method_preconditioner % id ) case ( METHOD_PRECOND_JACOBI % id ) allocate ( params % D ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate D\" params % D = Calculate_Jacobi_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_JACOBI this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . case ( METHOD_PRECOND_GS % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" params % L = Calculate_Gauss_Seidel_preconditioner ( A ) this % preconditioner_type = METHOD_PRECOND_GS this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . case ( METHOD_PRECOND_SOR % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" params % L = Calculate_SOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SOR this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA case ( METHOD_PRECOND_JOR % id ) allocate ( params % D ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate D\" params % D = Calculate_JOR_preconditioner ( A , params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_JOR this % requirements % needs_diag_dom = . true . this % requirements % needs_SPD = . true . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA case ( METHOD_PRECOND_ILU % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" allocate ( params % U ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate U\" if ( params % fill_level % id /= FILL_LEVEL_NONE % id ) then call Calculate_ILU_preconditioner ( A , params % L , params % U , & params % omega , params % alpha , & params % fill_level % id ) else call Calculate_ILU_preconditioner ( A , params % L , params % U , & params % omega , params % alpha ) end if this % preconditioner_type = METHOD_PRECOND_ILU this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA case ( METHOD_PRECOND_ICF % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" if ( params % fill_level % id /= FILL_LEVEL_NONE % id ) then params % L = Calculate_ICF_preconditioner ( A , & params % omega , params % alpha , & params % fill_level % id ) else params % L = Calculate_ICF_preconditioner ( A , & params % omega , params % alpha ) end if this % preconditioner_type = METHOD_PRECOND_ICF this % requirements % needs_SPD = . true . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA case ( METHOD_PRECOND_SSOR % id ) allocate ( params % L ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate L\" allocate ( params % D ( N , N ), STAT = allocate_status ) if ( allocate_status /= 0 ) stop \"ERROR :: Unable to allocate D\" call Calculate_SSOR_preconditioner ( A , params % L , params % D , & params % omega , params % alpha ) this % preconditioner_type = METHOD_PRECOND_SSOR this % requirements % needs_SPD = . true . this % relaxation_factor_preconditioner = RELAXATION_FACTOR_OMEGA case DEFAULT stop \"ERROR :: Unknown method \" end select end if if ( present ( is_stationary )) then if ( is_stationary ) then params % is_stationary = . true . this % requirements % needs_SPD = . false . else params % is_stationary = . false . end if end if if ( present ( is_strict_mode )) then if ( is_strict_mode ) then params % strict_mode = . true . else params % strict_mode = . false . end if end if end function Init_IterativeParams subroutine test_matrix ( this , A , params , verbose ) class ( IterativeMethod ), intent ( inout ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A type ( IterativeParams ), intent ( in ) :: params type ( Logger ), optional , intent ( inout ) :: verbose character ( KIND = ucs4 , LEN = 100 ) :: msg logical :: show_matrix_test show_matrix_test = . false . if ( present ( verbose )) then if ( verbose % show_matrix_test ) show_matrix_test = . true . end if if ( show_matrix_test ) then call verbose % write ( center_with_fill ( \"Testing matrix properties for method:\" // & trim ( this % method_type % name ), & 100 , fill_char = \"=\" ), box_style = \"top\" ) call verbose % write ( ucs4_ \"\" , box_style = \"middle\" ) end if if ( this % requirements % needs_square ) then if ( show_matrix_test ) then msg = ucs4_ \"Checking if the matrix is square...\" call verbose % log_info ( msg ) end if if (. not . is_square_matrix ( A )) then write ( msg , '(2A)' ) trim ( this % method_type % name ), \" requires a square matrix\" if ( params % strict_mode ) then if ( show_matrix_test ) call verbose % log_error ( msg ) stop else if ( show_matrix_test ) call verbose % log_warning ( msg ) end if end if end if if ( this % requirements % needs_SPD ) then if ( show_matrix_test ) then msg = ucs4_ \"Checking if the matrix is symmetric positive definite (SPD)...\" call verbose % log_info ( msg ) end if if (. not . is_SPD ( A )) then write ( msg , '(2A)' ) trim ( this % method_type % name ), & \" method requires a symmetric positive definite matrix.\" if ( params % strict_mode ) then if ( show_matrix_test ) call verbose % log_error ( msg ) stop else if ( show_matrix_test ) call verbose % log_warning ( msg ) end if end if end if if ( this % requirements % needs_diag_dom ) then if ( show_matrix_test ) then msg = ucs4_ \"Checking if the matrix is diagonally dominant...\" call verbose % log_info ( msg ) end if if (. not . is_diagonally_dominant ( A )) then write ( msg , '(2A)' ) trim ( this % method_type % name ), & \" method requires a diagonally dominant matrix.\" if ( params % strict_mode ) then if ( show_matrix_test ) call verbose % log_error ( msg ) stop else if ( show_matrix_test ) call verbose % log_warning ( msg ) end if end if end if if ( this % requirements % needs_symetric ) then if ( show_matrix_test ) then msg = ucs4_ \"Checking if the matrix is symmetric...\" call verbose % log_info ( msg ) end if if (. not . is_symmetric ( A )) then write ( msg , '(2A)' ) trim ( this % method_type % name ), & \" method requires a symmetric matrix.\" if ( params % strict_mode ) then if ( show_matrix_test ) call verbose % log_error ( msg ) stop else if ( show_matrix_test ) call verbose % log_warning ( msg ) end if end if end if if ( show_matrix_test ) then call verbose % write ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) call verbose % write ( ucs4_ \"\" ) end if end subroutine test_matrix subroutine Dealocate_IterativeParams ( this , params , success ) class ( IterativeMethod ), intent ( inout ) :: this type ( IterativeParams ), intent ( inout ) :: params logical , optional , intent ( out ) :: success integer :: deallocate_status if ( present ( success )) success = . true . if ( allocated ( params % x_init )) deallocate ( params % x_init , STAT = deallocate_status ) if ( allocated ( params % L )) deallocate ( params % L , STAT = deallocate_status ) if ( allocated ( params % U )) deallocate ( params % U , STAT = deallocate_status ) if ( allocated ( params % D )) deallocate ( params % D , STAT = deallocate_status ) if ( allocated ( params % residual )) deallocate ( params % residual , STAT = deallocate_status ) if ( allocated ( params % p )) deallocate ( params % p , STAT = deallocate_status ) params % norm = NORM_2 params % fill_level = FILL_LEVEL_NONE if ( deallocate_status /= 0 . and . present ( success )) success = . false . this % preconditioner_type = METHOD_PRECOND_NONE this % method_type = METHOD_ITERATIVE_NONE this % relaxation_factor = RELAXATION_FACTOR_NONE this % relaxation_factor_preconditioner = RELAXATION_FACTOR_NONE this % requirements = IterativeMethodRequirements () end subroutine Dealocate_IterativeParams !====================== ! Solve the system !====================== function IterativeMethod_solve ( this , A , b , params , verbose ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b type ( IterativeParams ), intent ( inout ) :: params type ( Logger ), optional , intent ( inout ) :: verbose real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: x0 , x_new integer :: k , N , frequency integer :: start_system_clock , end_system_clock , rate real ( dp ) :: elapsed_time logical :: show_info_solver logical :: show_iteration logical :: show_final N = size ( A , 1 ) x0 = params % x_init params % residual = b - matmul ( A , x0 ) params % norm_initial_residual = params % norm_function ( params % residual ) show_info_solver = . false . show_iteration = . false . show_final = . false . frequency = 1 if ( present ( verbose )) then if ( verbose % show_info_solver ) show_info_solver = . true . if ( verbose % show_iteration ) show_iteration = . true . if ( verbose % show_final ) show_final = . true . frequency = verbose % frequency end if if ( show_info_solver ) call log_solver_info ( this , params , verbose , N ) if ( show_iteration ) call log_iteration_header ( verbose ) call system_clock ( start_system_clock , count_rate = rate ) do k = 1 , params % max_iter params % k = k if ( k == params % max_iter ) then exit end if x_new = this % solve_method ( A , b , x0 , params ) params % residual = b - matmul ( A , x_new ) params % norm_residual = params % norm_function ( params % residual ) if ( show_iteration . and . mod ( k , frequency ) == 0 ) then call system_clock ( end_system_clock ) elapsed_time = real ( end_system_clock - start_system_clock , dp ) / real ( rate , dp ) call log_iteration_step ( verbose , k , params , elapsed_time ) end if if ( params % norm_residual < params % tol ) exit x0 = x_new end do if ( show_iteration ) then call verbose % write ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) end if if ( show_final ) then call system_clock ( end_system_clock ) elapsed_time = real ( end_system_clock - start_system_clock , dp ) / real ( rate , dp ) call log_final_result ( verbose , k , params , x_new , elapsed_time , N ) end if x = x_new end function IterativeMethod_solve !====================== ! Log solver information !====================== subroutine log_solver_info ( solver , params , verbose , N ) type ( IterativeMethod ), intent ( in ) :: solver type ( IterativeParams ), intent ( in ) :: params type ( Logger ), intent ( inout ) :: verbose integer , intent ( in ) :: N character ( 10 ) :: date , time character ( KIND = ucs4 , LEN = 100 ) :: msg call verbose % write ( ucs4_ \"\" ) call verbose % write ( center_with_fill ( \"Starting system solver\" , width = 100 , fill_char = \"=\" ), & box_style = \"top\" ) call verbose % write ( ucs4_ \"\" , box_style = \"middle\" ) ! call date_and_time(date,time,zone,values) call date_and_time ( DATE = date , TIME = time ) write ( date , '(A)' ) date (: 4 ) // \"-\" // date ( 5 : 6 ) // \"-\" // date ( 7 : 8 ) write ( time , '(A)' ) time (: 2 ) // \":\" // time ( 3 : 4 ) // \":\" // time ( 5 : 6 ) call log_field ( verbose , \"Date and time\" , trim ( date ) // \" \" // trim ( time )) if ( solver % relaxation_factor % id == RELAXATION_FACTOR_OMEGA % id ) then call log_field ( verbose , & \"Method used\" , & trim ( solver % method_type % name ) // \" \" // trim ( solver % method_type % name2 )) write ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , & \": \" , & trim ( solver % relaxation_factor % name ), & \" = \" , params % omega call verbose % log_info ( msg ) else if ( solver % relaxation_factor % id == RELAXATION_FACTOR_ALPHA % id ) then call log_field ( verbose , \"Method used\" , trim ( solver % method_type % name )) write ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , & \": \" , & trim ( solver % relaxation_factor % name ), & \" = \" , params % alpha call verbose % log_info ( msg ) else call log_field ( verbose , \"Method used\" , trim ( solver % method_type % name )) end if if ( solver % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then if ( solver % relaxation_factor_preconditioner % id == RELAXATION_FACTOR_OMEGA % id ) then call log_field ( verbose , & \"Preconditioner used\" , & trim ( solver % preconditioner_type % name )) write ( msg , '(A, T40, 3A, ES0.4)' ) \"Relaxation factor used\" , \": \" , & trim ( solver % relaxation_factor_preconditioner % name ), \" = \" , params % omega call verbose % log_info ( msg ) else call log_field ( verbose , & \"Preconditioner used\" , & trim ( solver % preconditioner_type % name )) end if end if if ( solver % preconditioner_type % id == METHOD_PRECOND_ILU % id . or . & solver % preconditioner_type % id == METHOD_PRECOND_ICF % id ) then if ( params % fill_level % id /= FILL_LEVEL_NONE % id ) then call log_field ( verbose , \"Fill level used\" , trim ( params % fill_level % name )) else call log_field ( verbose , & \"Fill level used\" , & \"basic \" // trim ( solver % preconditioner_type % name )) end if else if ( solver % method_type % id == METHOD_SIP_ILU % id . or . & solver % method_type % id == METHOD_SIP_ICF % id ) then if ( params % fill_level % id /= FILL_LEVEL_NONE % id ) then call log_field ( verbose , \"Fill level used\" , trim ( params % fill_level % name )) else call log_field ( verbose , & \"Fill level used\" , & \"basic \" // trim ( solver % method_type % name2 )) end if end if write ( msg , '(A,T40,A,I0,A,I0)' ) \"System size\" , \": \" , N , \" x \" , N call verbose % log_info ( msg ) write ( msg , '(A,T40,A,I0,A)' ) \"Memory used\" , \": \" , get_memory_kb (), \" KB\" call verbose % log_info ( msg ) call log_field ( verbose , \"Norme used\" , trim ( params % norm % name )) write ( msg , '(A,T40,A, ES0.2)' ) \"Convergence criterion (Tolerance)\" , & \": ||r|| < \" , & params % tol call verbose % log_info ( msg ) call log_field ( verbose , \"Max iterations\" , params % max_iter ) write ( msg , '(A,T36,A,ES0.7)' ) \"Initial residual norm\" , & \": ||r0|| = \" , & params % norm_initial_residual call verbose % log_detail ( msg ) call verbose % write ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) call verbose % write ( ucs4_ \"\" ) end subroutine log_solver_info subroutine log_iteration_header ( verbose ) class ( Logger ), intent ( inout ) :: verbose character ( KIND = ucs4 , LEN = 100 ) :: msg call verbose % write ( center_with_fill ( \"Iterations\" , width = 100 , fill_char = \"=\" ), & box_style = \"top\" ) call verbose % write ( ucs4_ \"\" , box_style = \"middle\" ) write ( msg , '(A,5X,A,5X,A,5X,A)' ) \"Iter\" , & \"Residual norm (||r||)\" , & \"Relative residual norm (||r||/||r0||)\" , & \"Time (s)\" call verbose % log_info ( msg ) call verbose % write ( repeat ( ucs4_ \"-\" , 100 ), box_style = \"middle\" ) end subroutine log_iteration_header subroutine log_iteration_step ( verbose , k , params , elapsed_time ) class ( Logger ), intent ( inout ) :: verbose integer , intent ( in ) :: k real ( dp ), intent ( in ) :: elapsed_time type ( IterativeParams ), intent ( in ) :: params character ( KIND = ucs4 , LEN = 100 ) :: msg integer :: end_system_clock call system_clock ( end_system_clock ) write ( msg , '(T2,I0,T15,ES0.7,T48,ES0.7,T79,ES0.7)' ) k , & params % norm_residual , & params % norm_residual / params % norm_initial_residual , & elapsed_time call verbose % log_time ( msg ) end subroutine log_iteration_step subroutine log_final_result ( verbose , k , params , x_new , elapsed_time , N ) class ( Logger ), intent ( inout ) :: verbose integer , intent ( in ) :: N integer , intent ( in ) :: k real ( dp ), intent ( in ) :: elapsed_time type ( IterativeParams ), intent ( in ) :: params real ( dp ), dimension (:), intent ( in ) :: x_new character ( KIND = ucs4 , LEN = 100 ) :: msg integer :: end_system_clock integer :: i call verbose % write ( ucs4_ \"\" ) call verbose % write ( center_with_fill ( \"Results\" , width = 100 , fill_char = \"=\" ), box_style = \"top\" ) call verbose % write ( ucs4_ \" \" , box_style = \"middle\" ) if ( k < params % max_iter ) then call log_field ( verbose , \"Status\" , \"CONVERGED\" ) write ( msg , '(A,T40,A,ES0.7,A,ES0.1,A)' ) \"Final residual\" , & \": ||r|| = \" , & params % norm_residual , & \" < \" , & params % tol , & \" (convergence achieved)\" call verbose % log_info ( msg ) write ( msg , '(A,T36,A,ES0.7)' ) \"Relative residual norm\" , \": ||r||/||r0|| = \" , & params % norm_residual / params % norm_initial_residual call verbose % log_detail ( msg ) call log_field ( verbose , \"Total iterations\" , k ) write ( msg , '(A,T40,A,ES0.7)' ) \"Solution\" , \": x = [\" if ( N < 6 ) then do i = 1 , size ( x_new ) write ( msg , '(2A,ES0.7)' ) trim ( msg ), \" \" , x_new ( i ) end do else write ( msg , '(2A,ES0.7,3X,ES0.7,3X,ES0.7,3X,A,ES0.7,3X,ES0.7,3X,ES0.7,A)' ) & trim ( msg ), & \" \" , & x_new ( 1 ), & x_new ( 2 ), & x_new ( 3 ), & x_new ( N - 3 ), & x_new ( N - 2 ), & x_new ( N - 1 ) end if write ( msg , '(2A,ES0.7)' ) trim ( msg ), \"]\" call verbose % log_info ( msg ) call system_clock ( end_system_clock ) write ( msg , '(A,T40,A,ES0.7,A,I0)' ) \"Solver completed in \" , \": \" , & elapsed_time , \" seconds\" call verbose % log_info ( msg ) write ( msg , '(A,T40,A,I0,A)' ) \"Memory used\" , \": \" , get_memory_kb (), \" KB\" call verbose % log_info ( msg ) else call log_field ( verbose , \"Status\" , \"NOT CONVERGED\" ) write ( msg , '(A,T40,A,ES0.7,A,ES0.1,A)' ) \"Final residual\" , & \": ||r|| = \" , & params % norm_residual , & \" >= \" , params % tol , \" (convergence not achieved)\" call verbose % log_info ( msg ) end if call verbose % write ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) end subroutine log_final_result !====================== ! Solve methods !====================== !> Jacobi iterative method !> !> This subroutine implements the Jacobi method for solving linear systems. function solve_Jacobi ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x integer :: i , N N = size ( A , 1 ) ! forward do i = 1 , N x ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) end do end function solve_Jacobi !> Gauss-Seidel iterative method !> !> This subroutine implements the Gauss-Seidel method for solving linear systems. function solve_Gauss_Seidel ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x integer :: i , N N = size ( A , 1 ) ! forward do i = 1 , N x ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) end do end function solve_Gauss_Seidel !> Successive Over-Relaxation (SOR) iterative method !> !> This subroutine implements the SOR method for solving linear systems. function solve_SOR ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x integer :: i , N N = size ( A , 1 ) ! forward do i = 1 , N x ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) end do end function solve_SOR !> Jacobi over-relaxation (JOR) iterative method !> !> This subroutine implements the Jacobi over-relaxation method for solving linear systems. function solve_JOR ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x integer :: i , N N = size ( A , 1 ) ! forward do i = 1 , N x ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) end do end function solve_JOR !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete LU decomposition of the matrix A. function solve_SIP_ILU ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: y , z if (. not . allocated ( params % L ) . or . . not . allocated ( params % U )) then stop \"ERROR :: Incomplete LU decomposition not initialized\" end if y = forward ( params % L , params % residual ) z = backward ( params % U , y ) x = x0 + params % omega * z end function solve_SIP_ILU !> strongly implicit procedure (SIP) method (or stone's method) !> !> This subroutine implements the SIP method for solving linear systems. !> It uses the incomplete Cholesky decomposition of the matrix A. function solve_SIP_ICF ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: y , z if (. not . allocated ( params % L )) then stop \"ERROR :: Incomplete LU decomposition not initialized\" end if y = forward ( params % L , params % residual ) z = backward ( transpose ( params % L ), y ) x = x0 + params % omega * z end function solve_SIP_ICF !> Symmetric successive Over-Relaxation (SSOR) iterative method !> !> This subroutine implements the SSOR method for solving linear systems. function solve_SSOR ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: x_tmp integer :: i , N N = size ( A , 1 ) ! forward do i = 1 , N x_tmp ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x_tmp ( i ) = params % omega * ( x_tmp ( i ) / A ( i , i ) - x0 ( i )) + x0 ( i ) end do ! backward do i = N , 1 , - 1 x ( i ) = b ( i ) - & dot_product ( A ( i , 1 : i - 1 ), x_tmp ( 1 : i - 1 )) - & dot_product ( A ( i , i + 1 : N ), x ( i + 1 : N )) x ( i ) = params % omega * ( x ( i ) / A ( i , i ) - x_tmp ( i )) + x_tmp ( i ) end do end function solve_SSOR !> Richardson iterative method !> !> This subroutine implements the Richardson method for solving linear systems. function solve_Richardson ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: z_prec if ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) then if (. not . params % is_stationary ) then params % alpha = dot_product ( params % residual , params % residual ) / & dot_product ( params % residual , matmul ( A , params % residual )) end if x = x0 + params % alpha * params % residual else if ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) if (. not . params % is_stationary ) then params % alpha = dot_product ( params % residual , z_prec ) / & dot_product ( z_prec , matmul ( A , z_prec )) end if x = x0 + params % alpha * z_prec end if end function solve_Richardson !> Conjugate Gradient iterative method !> !> This subroutine implements the Conjugate Gradient method for solving linear systems. function solve_ConjugateGradient ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: z_prec if ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) then if ( params % k == 1 ) then params % p = params % residual else if ( params % k /= 1 ) then params % beta = dot_product ( params % residual , params % residual ) / & params % old_dot_product params % p = params % residual + params % beta * params % p end if params % alpha = dot_product ( params % residual , params % residual ) / & dot_product ( params % p , matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , params % residual ) else if ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then if ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . or . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) then stop \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" end if if ( params % k == 1 ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) params % p = z_prec else if ( params % k /= 1 ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , params % residual ) / params % old_dot_product params % p = z_prec + params % beta * params % p end if params % alpha = dot_product ( z_prec , params % residual ) / & dot_product ( params % p , matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , params % residual ) end if end function solve_ConjugateGradient !> Conjugate Residual iterative method !> !> This subroutine implements the Conjugate Residual method for solving linear systems. function solve_ConjugateResidual ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: z_prec if ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) then if ( params % k == 1 ) then params % p = params % residual else if ( params % k /= 1 ) then params % beta = dot_product ( params % residual , matmul ( A , params % residual )) / & params % old_dot_product params % p = params % residual + params % beta * params % p end if params % alpha = dot_product ( params % residual , matmul ( A , params % residual )) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , matmul ( A , params % residual )) else if ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then if ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . or . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) then stop \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" end if if ( params % k == 1 ) then params % p = params % precond ( this % preconditioner_type , params % residual ) z_prec = params % p else if ( params % k /= 1 ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , matmul ( A , params % residual )) / & params % old_dot_product params % p = z_prec + params % beta * params % p end if params % alpha = dot_product ( z_prec , matmul ( A , params % residual )) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , matmul ( A , params % residual )) end if end function solve_ConjugateResidual !> Conjugate Gradient on Normal Equations iterative method !> !> This subroutine implements the Conjugate Gradient on Normal Equations method (or Craig’s Method) for solving linear systems. function solve_CGNR ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: z_prec real ( dp ), dimension ( size ( A , 1 )) :: AT_r if ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) then if ( params % k == 1 ) then AT_r = matmul ( transpose ( A ), params % residual ) params % p = AT_r else if ( params % k /= 1 ) then AT_r = matmul ( transpose ( A ), params % residual ) params % beta = dot_product ( AT_r , AT_r ) / params % old_dot_product params % p = AT_r + params % beta * params % p end if params % alpha = dot_product ( AT_r , AT_r ) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( AT_r , AT_r ) else if ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then if ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . or . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) then stop \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" end if if ( params % k == 1 ) then AT_r = matmul ( transpose ( A ), params % residual ) z_prec = params % precond ( this % preconditioner_type , AT_r ) params % p = z_prec else if ( params % k /= 1 ) then AT_r = matmul ( transpose ( A ), params % residual ) z_prec = params % precond ( this % preconditioner_type , AT_r ) params % beta = dot_product ( z_prec , AT_r ) / params % old_dot_product params % p = z_prec + params % beta * params % p end if params % alpha = dot_product ( z_prec , AT_r ) / & dot_product ( matmul ( A , params % p ), matmul ( A , params % p )) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , AT_r ) end if end function solve_CGNR !> Conjugate Gradient on Normal Residual iterative method !> !> This subroutine implements the Conjugate Gradient on Normal Residual method for solving linear systems. function solve_CGNE ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x real ( dp ), dimension ( size ( A , 1 )) :: z_prec if ( this % preconditioner_type % id == METHOD_PRECOND_NONE % id ) then if ( params % k == 1 ) then params % p = matmul ( transpose ( A ), params % residual ) else if ( params % k /= 1 ) then params % beta = dot_product ( params % residual , params % residual ) / params % old_dot_product params % p = matmul ( transpose ( A ), params % residual ) + params % beta * params % p end if params % alpha = dot_product ( params % residual , params % residual ) / & dot_product ( params % p , params % p ) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( params % residual , params % residual ) else if ( this % preconditioner_type % id /= METHOD_PRECOND_NONE % id ) then if ( this % preconditioner_type % id == METHOD_PRECOND_GS % id . or . & this % preconditioner_type % id == METHOD_PRECOND_SOR % id ) then stop \"ERROR :: Preconditioner Gauss-Seidel and SOR not supported for Conjugate Gradient method\" end if if ( params % k == 1 ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) params % p = matmul ( transpose ( A ), z_prec ) else if ( params % k /= 1 ) then z_prec = params % precond ( this % preconditioner_type , params % residual ) params % beta = dot_product ( z_prec , params % residual ) / params % old_dot_product params % p = matmul ( transpose ( A ), z_prec ) + params % beta * params % p end if params % alpha = dot_product ( z_prec , params % residual ) / & dot_product ( params % p , params % p ) x = x0 + params % alpha * params % p params % old_dot_product = dot_product ( z_prec , params % residual ) end if end function solve_CGNE function solve_GMRES ( this , A , b , x0 , params ) result ( x ) class ( IterativeMethod ), intent ( in ) :: this real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b , x0 type ( IterativeParams ), intent ( inout ) :: params real ( dp ), dimension ( size ( A , 1 )) :: x ! in progress end function solve_GMRES end module NAFPack_Iterative_methods","tags":"","url":"sourcefile\\nafpack_iterative_methods.f90.html"},{"title":"NAFPack_matrix_decomposition.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_decomposition.f90~~EfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_decomposition.f90~~AfferentGraph sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for matrix decomposition methods !> !> This module provides subroutines for various matrix decomposition methods including LU, LDU, Cholesky, and QR decompositions. module NAFPack_matrix_decomposition use NAFPack_kinds , only : dp use NAFPack_constant , only : TOL_CONVERGENCE_dp , int_inf use NAFPack_matricielle , only : Identity_n , rotation_matrix implicit none ( type , external ) private public :: forward , backward public :: LU_decomposition , LDU_decomposition , ILU_decomposition public :: Cholesky_decomposition , LDL_Cholesky_decomposition , Incomplete_Cholesky_decomposition public :: QR_decomposition public :: QR_Householder_decomposition , QR_Givens_decomposition , & QR_Gram_Schmidt_Classical_decomposition , QR_Gram_Schmidt_Modified_decomposition public :: pivot_partial , pivot_total contains !> forward algorithm, !> solves the system !>  L * y = b  !> where **L** is a lower triangular matrix and **b** is a vector function forward ( L , b ) result ( y ) real ( dp ), dimension (:, :), intent ( in ) :: L real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension ( size ( L , 1 )) :: y integer :: i , N N = size ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) do i = 2 , N y ( i ) = ( b ( i ) - dot_product ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) end do end function forward !> backward algorithm, !> solves the system !>  U * x = y  !> where **U** is an upper triangular matrix and **y** is a vector function backward ( U , y ) result ( x ) real ( dp ), dimension (:, :), intent ( in ) :: U real ( dp ), dimension (:), intent ( in ) :: y real ( dp ), dimension ( size ( U , 1 )) :: x integer :: i , N N = size ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) do i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - dot_product ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) end do end function backward !> LU decomposition of a matrix A !>  A = LU  !> This subroutine performs LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. subroutine LU_decomposition ( A , L , U ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U integer :: i , j , N N = size ( A , 1 ) L = 0.d0 U = 0.d0 do j = 1 , N L ( j , j ) = 1.d0 do i = 1 , j U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) end do do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) end do end do end subroutine LU_decomposition !> LDU decomposition of a matrix A !>  A = LDU  !> This subroutine performs LDU decomposition of a given matrix **A**, where **L** is a lower triangular matrix, **D** is a diagonal matrix, and **U** is an upper triangular matrix. subroutine LDU_decomposition ( A , L , D , U ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U , D integer :: i , j , k , N N = size ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 do j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 do i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [( D ( k , k ), k = 1 , i - 1 )])) / & D ( i , i ) end do i = j D ( j , j ) = A ( j , j ) - & dot_product ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )]) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [( D ( k , k ), k = 1 , j - 1 )])) / & D ( j , j ) end do end do end subroutine LDU_decomposition !> Incomplete LU decomposition of a matrix A !>  A \\approx LU  !> This subroutine performs incomplete LU decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. subroutine ILU_decomposition ( A , L , U , level ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , U integer , optional , intent ( in ) :: level integer :: N , i , j integer , dimension ( size ( A , 1 ), size ( A , 1 )) :: fill_level logical , dimension ( size ( A , 1 ), size ( A , 1 )) :: S N = size ( A , 1 ) L = 0.d0 U = 0.d0 if ( present ( level )) then call compute_fill_pattern_ILU ( A , fill_level , level , N ) S = ( fill_level <= level ) else S = A /= 0 end if do j = 1 , N L ( j , j ) = 1.d0 do i = 1 , j if ( S ( i , j )) U ( i , j ) = A ( i , j ) - dot_product ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) end do if ( abs ( U ( j , j )) < 1.0e-12_dp ) then print * , \"Warning: Near-zero pivot at row \" , j , \", value =\" , U ( j , j ) print * , \"Replacing with small value, value =\" , sign ( 1.0e-12_dp , U ( j , j )) U ( j , j ) = sign ( 1.0e-12_dp , U ( j , j )) end if do i = j + 1 , N if ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / & U ( j , j ) end do end do end subroutine ILU_decomposition !> Cholesky decomposition of a matrix A !>  A = LL&#94;T  !> This subroutine performs Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix. subroutine Cholesky_decomposition ( A , L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L integer :: i , j , N N = size ( A , 1 ) do j = 1 , N L ( j , j ) = sqrt ( A ( j , j ) - dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) end do end do end subroutine Cholesky_decomposition !> Alternative Cholesky decomposition of a matrix A !>  A = LDL&#94;T  !> This subroutine performs alternative Cholesky decomposition of a given symmetric positive definite matrix **A**, where **L** is a lower triangular matrix and **D** is a diagonal matrix. subroutine LDL_Cholesky_decomposition ( A , L , D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L , D integer :: i , j , N , k N = size ( A , 1 ) L = Identity_n ( N ) D = 0.d0 do j = 1 , N D ( j , j ) = A ( j , j ) - & dot_product ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )]) do i = j + 1 , N L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ) * [( D ( k , k ), k = 1 , j - 1 )])) / & D ( j , j ) end do end do end subroutine LDL_Cholesky_decomposition !> Incomplete Cholesky decomposition of a matrix A !>  A \\approx LL&#94;T  !> This subroutine performs incomplete Cholesky decomposition of a given matrix **A**, where **L** is a lower triangular matrix and **U** is an upper triangular matrix. subroutine Incomplete_Cholesky_decomposition ( A , L , level ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , optional , intent ( in ) :: level real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: L logical , dimension ( size ( A , 1 ), size ( A , 1 )) :: S integer :: N , i , j integer , dimension ( size ( A , 1 ), size ( A , 1 )) :: fill_level N = size ( A , 1 ) L = 0.d0 if ( present ( level )) then call compute_fill_pattern_IC ( A , fill_level , level , N ) S = ( fill_level <= level ) else S = A /= 0 end if do i = 1 , N do j = 1 , i - 1 if ( S ( i , j )) L ( i , j ) = ( A ( i , j ) - & dot_product ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / & L ( j , j ) end do if ( S ( i , i )) L ( i , i ) = sqrt ( A ( i , i ) - & dot_product ( L ( i , 1 : i - 1 ), L ( i , 1 : i - 1 ))) end do end subroutine Incomplete_Cholesky_decomposition !> QR decomposition of a matrix **A** using various methods !>  A = QR  !> This subroutine performs QR decomposition of a given matrix **A** using the specified method (Householder, Givens, Classical Gram-Schmidt, or Modified Gram-Schmidt). !> The output matrices **Q** is an orthogonal matrix and **R** is an upper triangular matrix. subroutine QR_decomposition ( A , method , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A character ( LEN =* ), optional , intent ( in ) :: method real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R if ( method == \"QR_Householder\" ) then call QR_Householder_decomposition ( A , Q , R ) else if ( method == \"QR_Givens\" ) then call QR_Givens_decomposition ( A , Q , R ) else if ( method == \"QR_Gram_Schmidt_Classical\" ) then call QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) else if ( method == \"QR_Gram_Schmidt_Modified\" ) then call QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) end if end subroutine QR_decomposition !> QR decomposition using Householder method subroutine QR_Householder_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: Id , H , v_mat_tmp real ( dp ), dimension ( size ( A , 1 )) :: v , u , x integer :: N , i , j , k real ( dp ) :: alpha , w , signe , norm_u N = size ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) do k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = norm2 ( R ( k : N , k )) signe = - sign ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = norm2 ( u ) if ( norm_u < TOL_CONVERGENCE_dp ) cycle v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 do i = k , N do j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) end do end do H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = matmul ( Q , H ) R ( k : N , k : N ) = matmul ( H ( k : N , k : N ), R ( k : N , k : N )) end do end subroutine QR_Householder_decomposition !> QR decomposition using Givens rotations subroutine QR_Givens_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: G integer :: N , i , j N = size ( A , 1 ) R = A Q = Identity_n ( N ) do j = 1 , N - 1 do i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = matmul ( G , R ) Q = matmul ( Q , transpose ( G )) end do end do end subroutine QR_Givens_decomposition !> QR decomposition using Classical Gram-Schmidt method subroutine QR_Gram_Schmidt_Classical_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 )) :: u integer :: N , i , j N = size ( A , 1 ) Q = 0.d0 R = 0.d0 do j = 1 , N u = A (:, j ) do i = 1 , j - 1 R ( i , j ) = dot_product ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) end do R ( j , j ) = norm2 ( u ) Q (:, j ) = u / R ( j , j ) end do end subroutine QR_Gram_Schmidt_Classical_decomposition !> QR decomposition using Modified Gram-Schmidt method subroutine QR_Gram_Schmidt_Modified_decomposition ( A , Q , R ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: Q , R real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: u integer :: N , i , j N = size ( A , 1 ) u = A Q = 0.d0 R = 0.d0 do i = 1 , N R ( i , i ) = norm2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) do j = i + 1 , N R ( i , j ) = dot_product ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) end do end do end subroutine QR_Gram_Schmidt_Modified_decomposition subroutine pivot_partial ( A , P ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: P integer , dimension ( 1 ) :: vlmax integer :: N , lmax , k real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: P_tmp N = size ( A , 1 ) P = Identity_n ( N ) do k = 1 , N - 1 ! Find the maximum absolute value in the column from row k to N vlmax = maxloc ( abs ( A ( k : N , k ))) lmax = vlmax ( 1 ) + k - 1 !calculate permutation matrix P P_tmp = Identity_n ( N ) if ( k /= lmax ) then P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) end if P = matmul ( P_tmp , P ) end do end subroutine pivot_partial subroutine pivot_total ( A , P , Q ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( out ) :: P , Q real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: P_tmp , Q_tmp integer , dimension ( 2 ) :: vlmax integer :: N , lmax , cmax , k N = size ( A , 1 ) P = Identity_n ( N ) Q = Identity_n ( N ) do k = 1 , N - 1 ! Find max abs element in submatrix vlmax = maxloc ( abs ( A ( k : N , k : N ))) lmax = vlmax ( 1 ) + k - 1 cmax = vlmax ( 2 ) + k - 1 ! permute line if necessary P_tmp = Identity_n ( N ) if ( k /= lmax ) then P_tmp ([ k , lmax ], :) = P_tmp ([ lmax , k ], :) end if P = matmul ( P_tmp , P ) ! permute column if necessary Q_tmp = Identity_n ( N ) if ( cmax /= k ) then Q_tmp (:, [ k , cmax ]) = Q_tmp (:, [ cmax , k ]) end if Q = matmul ( Q_tmp , Q ) end do end subroutine pivot_total subroutine compute_fill_pattern_ILU ( A , fill_level , max_level , N ) real ( dp ), dimension ( N , N ), intent ( in ) :: A integer , dimension ( N , N ), intent ( out ) :: fill_level integer , intent ( in ) :: max_level , N logical , dimension ( N , N ) :: S integer :: new_level integer :: i , j , k ! Niveau initial basé sur A fill_level = int_inf S = A /= 0.d0 where ( S ) fill_level = 0 ! Calcul symbolique des niveaux de remplissage do k = 1 , N - 1 do i = k + 1 , N if ( fill_level ( i , k ) <= max_level ) then do j = k + 1 , N if ( fill_level ( k , j ) <= max_level ) then new_level = fill_level ( i , k ) + fill_level ( k , j ) + 1 if ( new_level < max_level ) then fill_level ( i , j ) = new_level end if end if end do end if end do end do end subroutine compute_fill_pattern_ILU subroutine compute_fill_pattern_IC ( A , fill_level , max_level , N ) real ( dp ), dimension ( N , N ), intent ( in ) :: A integer , dimension ( N , N ), intent ( out ) :: fill_level integer , intent ( in ) :: max_level , N logical , dimension ( N , N ) :: S integer :: new_level integer :: i , j , k ! Niveau initial basé sur A fill_level = int_inf S = A /= 0.d0 where ( S ) fill_level = 0 ! Calcul symbolique des niveaux de remplissage do k = 1 , N - 1 do i = k + 1 , N if ( fill_level ( i , k ) <= max_level ) then do j = k + 1 , i if ( fill_level ( k , j ) <= max_level ) then new_level = fill_level ( i , k ) + fill_level ( k , j ) + 1 if ( new_level < max_level ) then fill_level ( i , j ) = new_level fill_level ( j , i ) = new_level end if end if end do end if end do end do end subroutine compute_fill_pattern_IC end module NAFPack_matrix_decomposition","tags":"","url":"sourcefile\\nafpack_matrix_decomposition.f90.html"},{"title":"NAFPack_Fourier_Transform_fft2.f90 – NAFPack","text":"Source Code","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft2.f90.html"},{"title":"NAFPack_memory_management.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_memory_management.f90~~EfferentGraph sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_memory_management.f90~~AfferentGraph sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_memory_management_complex.f90 NAFPack_memory_management_complex.f90 sourcefile~nafpack_memory_management_complex.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_memory_management_integer.f90 NAFPack_memory_management_integer.f90 sourcefile~nafpack_memory_management_integer.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_memory_management_real.f90 NAFPack_memory_management_real.f90 sourcefile~nafpack_memory_management_real.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_memory_management use NAFPack_kinds , only : sp , dp , qp , i8 , i16 , isp , idp implicit none ( type , external ) private public :: realloc interface realloc module procedure realloc_vec_integer_i8_1D module procedure realloc_vec_integer_i16_1D module procedure realloc_vec_integer_isp_1D module procedure realloc_vec_integer_idp_1D module procedure realloc_vec_integer_i8_2D module procedure realloc_vec_integer_i16_2D module procedure realloc_vec_integer_isp_2D module procedure realloc_vec_integer_idp_2D module procedure realloc_vec_integer_i8_3D module procedure realloc_vec_integer_i16_3D module procedure realloc_vec_integer_isp_3D module procedure realloc_vec_integer_idp_3D module procedure realloc_vec_real_sp_1D module procedure realloc_vec_real_dp_1D module procedure realloc_vec_real_qp_1D module procedure realloc_vec_real_sp_2D module procedure realloc_vec_real_dp_2D module procedure realloc_vec_real_qp_2D module procedure realloc_vec_real_sp_3D module procedure realloc_vec_real_dp_3D module procedure realloc_vec_real_qp_3D module procedure realloc_vec_complex_sp_1D module procedure realloc_vec_complex_dp_1D module procedure realloc_vec_complex_qp_1D module procedure realloc_vec_complex_sp_2D module procedure realloc_vec_complex_dp_2D module procedure realloc_vec_complex_qp_2D module procedure realloc_vec_complex_sp_3D module procedure realloc_vec_complex_dp_3D module procedure realloc_vec_complex_qp_3D end interface realloc interface module subroutine realloc_vec_integer_i8_1D ( vec , new_size ) integer ( i8 ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i8_1D module subroutine realloc_vec_integer_i16_1D ( vec , new_size ) integer ( i16 ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i16_1D module subroutine realloc_vec_integer_isp_1D ( vec , new_size ) integer ( isp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_integer_isp_1D module subroutine realloc_vec_integer_idp_1D ( vec , new_size ) integer ( idp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_integer_idp_1D end interface interface module subroutine realloc_vec_integer_i8_2D ( vec , new_size ) integer ( i8 ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i8_2D module subroutine realloc_vec_integer_i16_2D ( vec , new_size ) integer ( i16 ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i16_2D module subroutine realloc_vec_integer_isp_2D ( vec , new_size ) integer ( isp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_isp_2D module subroutine realloc_vec_integer_idp_2D ( vec , new_size ) integer ( idp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_idp_2D end interface interface module subroutine realloc_vec_integer_i8_3D ( vec , new_size ) integer ( i8 ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i8_3D module subroutine realloc_vec_integer_i16_3D ( vec , new_size ) integer ( i16 ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_i16_3D module subroutine realloc_vec_integer_isp_3D ( vec , new_size ) integer ( isp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_isp_3D module subroutine realloc_vec_integer_idp_3D ( vec , new_size ) integer ( idp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_integer_idp_3D end interface interface module subroutine realloc_vec_real_sp_1D ( vec , new_size ) real ( sp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_real_sp_1D module subroutine realloc_vec_real_dp_1D ( vec , new_size ) real ( dp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_real_dp_1D module subroutine realloc_vec_real_qp_1D ( vec , new_size ) real ( qp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_real_qp_1D end interface interface module subroutine realloc_vec_real_sp_2D ( vec , new_size ) real ( sp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_real_sp_2D module subroutine realloc_vec_real_dp_2D ( vec , new_size ) real ( dp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_real_dp_2D module subroutine realloc_vec_real_qp_2D ( vec , new_size ) real ( qp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_real_qp_2D end interface interface module subroutine realloc_vec_real_sp_3D ( vec , new_size ) real ( sp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_real_sp_3D module subroutine realloc_vec_real_dp_3D ( vec , new_size ) real ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_real_dp_3D module subroutine realloc_vec_real_qp_3D ( vec , new_size ) real ( qp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_real_qp_3D end interface interface module subroutine realloc_vec_complex_sp_1D ( vec , new_size ) complex ( sp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_complex_sp_1D module subroutine realloc_vec_complex_dp_1D ( vec , new_size ) complex ( dp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_complex_dp_1D module subroutine realloc_vec_complex_qp_1D ( vec , new_size ) complex ( qp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size end subroutine realloc_vec_complex_qp_1D end interface interface module subroutine realloc_vec_complex_sp_2D ( vec , new_size ) complex ( sp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_sp_2D module subroutine realloc_vec_complex_dp_2D ( vec , new_size ) complex ( dp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_dp_2D module subroutine realloc_vec_complex_qp_2D ( vec , new_size ) complex ( qp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_qp_2D end interface interface module subroutine realloc_vec_complex_sp_3D ( vec , new_size ) complex ( sp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_sp_3D module subroutine realloc_vec_complex_dp_3D ( vec , new_size ) complex ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_dp_3D module subroutine realloc_vec_complex_qp_3D ( vec , new_size ) complex ( qp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size end subroutine realloc_vec_complex_qp_3D end interface end module NAFPack_memory_management","tags":"","url":"sourcefile\\nafpack_memory_management.f90.html"},{"title":"NAFPack_Fourier_Transform_dft2.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_dft2.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform ) NAFPack_Fourier_Transform_dft2 implicit none ( type , external ) contains module function dft2_cmplx_sp ( signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = dft_cmplx_sp ( signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = dft_cmplx_sp ( tmp ( i , :), loop_method ) end do end function dft2_cmplx_sp module function idft2_cmplx_sp ( f_signal , loop_method ) result ( result ) complex ( sp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = idft_cmplx_sp ( f_signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = idft_cmplx_sp ( tmp ( i , :), loop_method ) end do end function idft2_cmplx_sp module function dft2_cmplx_dp ( signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = dft_cmplx_dp ( signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = dft_cmplx_dp ( tmp ( i , :), loop_method ) end do end function dft2_cmplx_dp module function idft2_cmplx_dp ( f_signal , loop_method ) result ( result ) complex ( dp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = idft_cmplx_dp ( f_signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = idft_cmplx_dp ( tmp ( i , :), loop_method ) end do end function idft2_cmplx_dp module function dft2_cmplx_qp ( signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = dft_cmplx_qp ( signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = dft_cmplx_qp ( tmp ( i , :), loop_method ) end do end function dft2_cmplx_qp module function idft2_cmplx_qp ( f_signal , loop_method ) result ( result ) complex ( qp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), allocatable :: tmp type ( LoopMethod ) :: loop_method_used integer ( isp ) :: i , Nx , Ny if ( present ( loop_method )) then loop_method_used = loop_method else loop_method_used = default_loop_method end if Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) allocate ( tmp ( Nx , Ny )) do i = 1 , Ny tmp (:, i ) = idft_cmplx_qp ( f_signal (:, i ), loop_method ) end do do i = 1 , Nx result ( i , :) = idft_cmplx_qp ( tmp ( i , :), loop_method ) end do end function idft2_cmplx_qp module function dft2_real_sp ( signal , loop_method ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension ( size ( signal , 1 ), & size ( signal , 2 )) :: signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = sp ) if ( present ( loop_method )) then result = dft2_cmplx_sp ( signal_cmplx , loop_method ) else result = dft2_cmplx_sp ( signal_cmplx ) end if end function dft2_real_sp module function idft2_real_sp ( f_signal , loop_method ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = sp ) if ( present ( loop_method )) then result = idft2_cmplx_sp ( f_signal_cmplx , loop_method ) else result = idft2_cmplx_sp ( f_signal_cmplx ) end if end function idft2_real_sp module function dft2_real_dp ( signal , loop_method ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension ( size ( signal , 1 ), & size ( signal , 2 )) :: signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = dp ) if ( present ( loop_method )) then result = dft2_cmplx_dp ( signal_cmplx , loop_method ) else result = dft2_cmplx_dp ( signal_cmplx ) end if end function dft2_real_dp module function idft2_real_dp ( f_signal , loop_method ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = dp ) if ( present ( loop_method )) then result = idft2_cmplx_dp ( f_signal_cmplx , loop_method ) else result = idft2_cmplx_dp ( f_signal_cmplx ) end if end function idft2_real_dp module function dft2_real_qp ( signal , loop_method ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension ( size ( signal , 1 ), & size ( signal , 2 )) :: signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( signal , 1 ) Ny = size ( signal , 2 ) allocate ( result ( Nx , Ny )) signal_cmplx = cmplx ( signal , 0.0_dp , kind = qp ) if ( present ( loop_method )) then result = dft2_cmplx_qp ( signal_cmplx , loop_method ) else result = dft2_cmplx_qp ( signal_cmplx ) end if end function dft2_real_qp module function idft2_real_qp ( f_signal , loop_method ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: f_signal type ( LoopMethod ), optional , intent ( in ) :: loop_method complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension ( size ( f_signal , 1 ), & size ( f_signal , 2 )) :: f_signal_cmplx integer ( isp ) :: Nx , Ny Nx = size ( f_signal , 1 ) Ny = size ( f_signal , 2 ) allocate ( result ( Nx , Ny )) f_signal_cmplx = cmplx ( f_signal , 0.0_dp , kind = qp ) if ( present ( loop_method )) then result = idft2_cmplx_qp ( f_signal_cmplx , loop_method ) else result = idft2_cmplx_qp ( f_signal_cmplx ) end if end function idft2_real_qp end submodule NAFPack_Fourier_Transform_dft2","tags":"","url":"sourcefile\\nafpack_fourier_transform_dft2.f90.html"},{"title":"NAFPack_memory_management_real.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_memory_management_real.f90~~EfferentGraph sourcefile~nafpack_memory_management_real.f90 NAFPack_memory_management_real.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_memory_management_real.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_memory_management ) NAFPack_memory_management_real implicit none ( type , external ) contains module subroutine realloc_vec_real_sp_1D ( vec , new_size ) real ( sp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size real ( sp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_real_sp_1D module subroutine realloc_vec_real_dp_1D ( vec , new_size ) real ( dp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size real ( dp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_real_dp_1D module subroutine realloc_vec_real_qp_1D ( vec , new_size ) real ( qp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size real ( qp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_real_qp_1D module subroutine realloc_vec_real_sp_2D ( vec , new_size ) real ( sp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size real ( sp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_sp_2D module subroutine realloc_vec_real_dp_2D ( vec , new_size ) real ( dp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size real ( dp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_dp_2D module subroutine realloc_vec_real_qp_2D ( vec , new_size ) real ( qp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size real ( qp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_qp_2D module subroutine realloc_vec_real_sp_3D ( vec , new_size ) real ( sp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size real ( sp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_sp_3D module subroutine realloc_vec_real_dp_3D ( vec , new_size ) real ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size real ( dp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_dp_3D module subroutine realloc_vec_real_qp_3D ( vec , new_size ) real ( qp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size real ( qp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_real_qp_3D end submodule NAFPack_memory_management_real","tags":"","url":"sourcefile\\nafpack_memory_management_real.f90.html"},{"title":"NAFPack_constant.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_constant.f90~~EfferentGraph sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_constant.f90~~AfferentGraph sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for defining constants used in NAFPack !> !> This module includes mathematical constants, !> and other parameters that are used throughout the NAFPack library. module NAFPack_constant use NAFPack_kinds , only : sp , dp , qp implicit none ( type , external ) public !>  \\pi  constant real ( sp ), parameter :: pi_sp = acos ( - 1.0_sp ) real ( dp ), parameter :: pi_dp = acos ( - 1.0_dp ) real ( qp ), parameter :: pi_qp = acos ( - 1.0_qp ) !> Imaginary unit  i&#94;2 = -1  complex ( sp ), parameter :: im_sp = ( 0.0_sp , 1.0_sp ) complex ( dp ), parameter :: im_dp = ( 0.0_dp , 1.0_dp ) complex ( qp ), parameter :: im_qp = ( 0.0_qp , 1.0_qp ) !> Integer infinity integer , parameter :: int_inf = huge ( 1 ) !> Error codes for better error handling integer , parameter :: NAF_SUCCESS = 0 integer , parameter :: NAF_ERROR_DIMENSION = 1 integer , parameter :: NAF_ERROR_SINGULAR = 2 integer , parameter :: NAF_ERROR_CONVERGENCE = 3 integer , parameter :: NAF_ERROR_MEMORY = 4 integer , parameter :: NAF_ERROR_INVALID_METHOD = 5 ! Numerical tolerances real ( sp ), parameter :: TOL_PIVOT_sp = 1.0e-7_sp + epsilon ( 1.0_sp ) real ( dp ), parameter :: TOL_PIVOT_dp = 1.0e-14_dp + epsilon ( 1.0_dp ) real ( qp ), parameter :: TOL_PIVOT_qp = 1.0e-28_qp + epsilon ( 1.0_qp ) real ( sp ), parameter :: TOL_CONVERGENCE_sp = 1.0e-6_sp + epsilon ( 1.0_sp ) real ( dp ), parameter :: TOL_CONVERGENCE_dp = 1.0e-12_dp + epsilon ( 1.0_dp ) real ( qp ), parameter :: TOL_CONVERGENCE_qp = 1.0e-24_qp + epsilon ( 1.0_qp ) real ( sp ), parameter :: TOL_RESIDUAL_sp = 1.0e-5_sp + epsilon ( 1.0_sp ) real ( dp ), parameter :: TOL_RESIDUAL_dp = 1.0e-10_dp + epsilon ( 1.0_dp ) real ( qp ), parameter :: TOL_RESIDUAL_qp = 1.0e-20_qp + epsilon ( 1.0_qp ) real ( sp ), parameter :: TOL_TEST_sp = 1.0e-4_sp + epsilon ( 1.0_sp ) real ( dp ), parameter :: TOL_TEST_dp = 1.0e-12_dp + epsilon ( 1.0_dp ) real ( qp ), parameter :: TOL_TEST_qp = 1.0e-24_qp + epsilon ( 1.0_qp ) ! Performance settings integer , parameter :: MAX_ITERATION = 10000 ! integer, parameter :: block_size = 64 ! logical, parameter :: use_openmp = .true. ! logical, parameter :: use_blas = .true. ! logical, parameter :: use_lapack = .true. end module NAFPack_constant","tags":"","url":"sourcefile\\nafpack_constant.f90.html"},{"title":"NAFPack_Logger_mod.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_logger_mod.f90~~EfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_logger_mod.f90~~AfferentGraph sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> module NAFPack_Logger_mod use NAFPack_kinds , only : dp , ucs4 use NAFPack_ANSI , only : ColorsUcs4 use NAFPack_terminal , only : output_unit ! use NAFPack_terminal_colors, only: & !     red_color_ucs4, green_color_ucs4, yellow_color_ucs4, blue_color_ucs4, & !     white_color_ucs4, cyan_color_ucs4, purple_color_ucs4, reset_color_ucs4 implicit none ( type , external ) private public :: Logger public :: Format_file public :: FORMAT_FILE_BIN , FORMAT_FILE_TXT , FORMAT_FILE_CSV , FORMAT_FILE_LOG , FORMAT_FILE_TSV public :: FORMAT_FILE_JSON , FORMAT_FILE_XML , FORMAT_FILE_YAML public :: log_field public :: center_with_fill type :: Format_file integer :: id = 1 character ( LEN = 10 ) :: format_name = \"txt\" character ( LEN = 100 ) :: format_description = \"Text file format\" end type Format_file type ( Format_file ), parameter :: FORMAT_FILE_BIN = Format_file ( 0 , & \"binary\" , & \"Binary file format\" ) type ( Format_file ), parameter :: FORMAT_FILE_TXT = Format_file ( 1 , & \"txt\" , & \"Text file format\" ) type ( Format_file ), parameter :: FORMAT_FILE_CSV = Format_file ( 2 , & \"csv\" , & \"Comma-separated values format\" ) type ( Format_file ), parameter :: FORMAT_FILE_LOG = Format_file ( 3 , & \"log\" , & \"Log file format\" ) type ( Format_file ), parameter :: FORMAT_FILE_TSV = Format_file ( 4 , & \"tsv\" , & \"Tab-separated values format\" ) type ( Format_file ), parameter :: FORMAT_FILE_JSON = Format_file ( 5 , & \"json\" , & \"JSON file format\" ) type ( Format_file ), parameter :: FORMAT_FILE_XML = Format_file ( 6 , & \"xml\" , & \"XML file format\" ) type ( Format_file ), parameter :: FORMAT_FILE_YAML = Format_file ( 7 , & \"yaml\" , & \"YAML file format\" ) type :: Logger integer :: verbosity_level = 1 logical :: to_terminal = . true . logical :: to_file = . false . integer :: frequency = 10 character ( LEN = 100 ) :: filename = \"Log\" type ( Format_file ) :: file_format = FORMAT_FILE_LOG integer :: file_unit = 99 character ( LEN = 100 ) :: message = \"Default log message\" logical :: show_Logger_initialization = . true . logical :: show_matrix_test = . true . logical :: show_info_solver = . true . logical :: show_iteration = . true . logical :: show_final = . true . contains procedure :: init => init_logger procedure :: log_info procedure :: log_detail procedure :: log_warning procedure :: log_error procedure :: log_time procedure :: write => write_output procedure :: close => close_logger end type Logger interface log_field module procedure log_field_str , & log_field_real , & log_field_int , & log_field_ucs4 , & log_field_logical end interface log_field contains !========================================================================== subroutine init_logger ( this ) class ( Logger ), intent ( inout ) :: this if ( this % to_file ) then open ( UNIT = this % file_unit , & FILE = trim ( this % filename ) // \".\" // this % file_format % format_name , & STATUS = 'REPLACE' , & ACTION = 'WRITE' , & ENCODING = 'UTF-8' ) end if if ( this % to_terminal ) then open ( output_unit , encoding = 'UTF-8' ) end if if ( this % show_Logger_initialization ) then call this % write ( center_with_fill ( \"NAFPack Logger initialized\" , & width = 100 , & fill_char = \"=\" ), box_style = \"top\" ) call this % write ( ucs4_ \"\" , box_style = \"middle\" ) call log_field ( this , \"Verbosity level\" , this % verbosity_level ) call log_field ( this , \"Output to terminal\" , this % to_terminal ) call log_field ( this , \"Output to file\" , this % to_file ) if ( this % to_file ) then call log_field ( this , \"File unit\" , this % file_unit ) call log_field ( this , \"File format\" , this % file_format % format_name ) call log_field ( this , & \"File name\" , & trim ( this % filename ) // \".\" // trim ( this % file_format % format_name )) end if call this % write ( center_with_fill ( \"\" , width = 100 , fill_char = \"=\" ), box_style = \"bottom\" ) call this % write ( ucs4_ \"\" ) end if end subroutine init_logger !========================================================================== subroutine log_info ( this , msg ) class ( Logger ), intent ( inout ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg type ( ColorsUcs4 ) :: colors CALL colors % init () if ( this % verbosity_level >= 2 ) call this % write ( msg , ucs4_ \"INFO\" , colors % blue ) end subroutine log_info subroutine log_detail ( this , msg ) class ( Logger ), intent ( inout ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg type ( ColorsUcs4 ) :: colors CALL colors % init () if ( this % verbosity_level >= 3 ) call this % write ( ucs4_ \"    \" // msg , & ucs4_ \"DETAIL\" , & colors % green ) end subroutine log_detail subroutine log_warning ( this , msg ) class ( Logger ), intent ( inout ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg type ( ColorsUcs4 ) :: colors CALL colors % init () if ( this % verbosity_level >= 1 ) call this % write ( msg , ucs4_ \"WARNING\" , colors % yellow ) end subroutine log_warning subroutine log_error ( this , msg ) class ( Logger ), intent ( inout ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg type ( ColorsUcs4 ) :: colors CALL colors % init () if ( this % verbosity_level >= 1 ) call this % write ( msg , ucs4_ \"ERROR\" , colors % red ) end subroutine log_error subroutine log_time ( this , msg ) class ( Logger ), intent ( inout ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg character ( LEN = 10 ) :: time character ( KIND = ucs4 , LEN = 10 ) :: time_ucs4 type ( ColorsUcs4 ) :: colors CALL colors % init () call date_and_time ( TIME = time ) write ( time_ucs4 , '(A)' ) time (: 2 ) // \":\" // time ( 3 : 4 ) // \":\" // time ( 5 : 6 ) if ( this % verbosity_level >= 2 ) call this % write ( msg , time_ucs4 , colors % magenta ) end subroutine log_time !========================================================================== subroutine write_output ( this , msg , name_level , color_level , box_style ) class ( Logger ), intent ( in ) :: this character ( KIND = ucs4 , LEN =* ), intent ( in ) :: msg character ( KIND = ucs4 , LEN =* ), optional , intent ( in ) :: name_level character ( KIND = ucs4 , LEN =* ), optional , intent ( in ) :: color_level character ( LEN =* ), optional , intent ( in ) :: box_style character ( KIND = ucs4 , LEN = 100 ) :: info_char character ( LEN = 4 ) :: box_char type ( ColorsUcs4 ) :: colors CALL colors % init () if ( present ( box_style )) then select case ( trim ( adjustl ( box_style ))) case ( \"top\" ) box_char = \"╔\" case ( \"bottom\" ) box_char = \"╚\" case ( \"middle\" ) box_char = \"║ \" case ( \"None\" ) box_char = \" \" case DEFAULT box_char = \" \" end select end if info_char = \"\" if ( this % to_file ) then if ( present ( name_level )) then info_char = ucs4_ \"[\" // trim ( name_level ) // ucs4_ \"] \" write ( this % file_unit , '(A, T15, \"║ \", A)' ) trim ( info_char ), trim ( msg ) else if ( present ( box_style )) then write ( this % file_unit , '(T15, A, A)' ) trim ( box_char ), trim ( msg ) else write ( this % file_unit , '(A)' ) trim ( msg ) end if end if end if if ( this % to_terminal ) then if ( present ( name_level )) then if ( present ( color_level )) then info_char = ucs4_ \"[\" // trim ( color_level ) // trim ( name_level ) // trim ( colors % reset ) // ucs4_ \"] \" else info_char = ucs4_ \"[\" // trim ( name_level ) // ucs4_ \"] \" end if write ( output_unit , '(A, T24, \"║ \", A)' ) trim ( info_char ), trim ( msg ) else if ( present ( box_style )) then write ( output_unit , '(T15, A, A)' ) trim ( box_char ), trim ( msg ) else write ( output_unit , '(A)' ) trim ( msg ) end if end if end if end subroutine write_output !========================================================================== subroutine close_logger ( this ) class ( Logger ), intent ( inout ) :: this if ( this % to_file ) close ( this % file_unit ) end subroutine close_logger !========================================================================== subroutine log_field_str ( verbose , label , value ) type ( Logger ), intent ( inout ) :: verbose character ( * ), intent ( in ) :: label , value character ( KIND = ucs4 , LEN = 100 ) :: msg write ( msg , '(A, T40, 2A)' ) trim ( label ), \": \" , trim ( value ) call verbose % log_info ( msg ) end subroutine log_field_str subroutine log_field_ucs4 ( verbose , label , value ) type ( Logger ), intent ( inout ) :: verbose character ( * ), intent ( in ) :: label character ( KIND = ucs4 , LEN =* ), intent ( in ) :: value character ( KIND = ucs4 , LEN = 100 ) :: msg write ( msg , '(A, T40, 2A)' ) trim ( label ), \": \" , trim ( value ) call verbose % log_info ( msg ) end subroutine log_field_ucs4 subroutine log_field_int ( verbose , label , value ) type ( Logger ), intent ( inout ) :: verbose character ( * ), intent ( in ) :: label integer , intent ( in ) :: value character ( KIND = ucs4 , LEN = 100 ) :: msg write ( msg , '(A, T40, A, I0)' ) trim ( label ), \": \" , value call verbose % log_info ( msg ) end subroutine log_field_int subroutine log_field_real ( verbose , label , value ) type ( Logger ), intent ( inout ) :: verbose character ( * ), intent ( in ) :: label real ( dp ), intent ( in ) :: value character ( KIND = ucs4 , LEN = 100 ) :: msg write ( msg , '(A, T40, A, ES0.7)' ) trim ( label ), \": \" , value call verbose % log_info ( msg ) end subroutine log_field_real subroutine log_field_logical ( verbose , label , value ) type ( Logger ), intent ( inout ) :: verbose character ( * ), intent ( in ) :: label logical , intent ( in ) :: value character ( KIND = ucs4 , LEN = 100 ) :: msg write ( msg , '(A, T40, A, L)' ) trim ( label ), \": \" , value call verbose % log_info ( msg ) end subroutine log_field_logical function center_with_fill ( text , width , fill_char ) result ( centered_text ) character ( LEN =* ), intent ( in ) :: text integer , intent ( in ) :: width character ( LEN = 1 ), optional , intent ( in ) :: fill_char character ( LEN = 1 ) :: fill character ( KIND = ucs4 , LEN = width ) :: centered_text integer :: text_len , padding , left_padding , right_padding , i if ( present ( fill_char )) then fill = fill_char else fill = \" \" end if text_len = len_trim ( text ) if ( text_len >= width ) then centered_text = text ( 1 : width ) return end if ! Calculate the total padding required padding = width - text_len if ( trim ( text ) == \"\" ) then left_padding = padding / 2 right_padding = padding - left_padding - mod ( padding , 2 ) else text_len = text_len + 1 left_padding = padding / 2 - 1 right_padding = padding - left_padding - mod ( padding , 2 ) end if ! Initialize the result centered_text = repeat ( ' ' , width ) ! Fill with fill on the left do i = 1 , left_padding centered_text ( i : i ) = fill end do ! Place the text in the center if ( trim ( text ) == \"\" ) then centered_text ( left_padding + 1 : left_padding + text_len ) = trim ( text ) else centered_text ( left_padding + 1 : left_padding + text_len ) = \" \" // trim ( text ) // \" \" end if ! Fill with fill on the right do i = right_padding + text_len , width centered_text ( i : i ) = fill end do end function center_with_fill end module NAFPack_Logger_mod","tags":"","url":"sourcefile\\nafpack_logger_mod.f90.html"},{"title":"NAFPack_meshgrid_complex_2D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_complex_2d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_complex_2d_compute.f90 NAFPack_meshgrid_complex_2D_compute.f90 sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90->sourcefile~nafpack_meshgrid_complex_2d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_complex_2D ) NAFPack_meshgrid_complex_2D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of two complex vectors in 32-bit (single precision) !================================================================================= module subroutine compute_meshgrid_cmplx_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_2D_sp pure subroutine compute_do_classic_cmplx_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_cmplx_2D_sp pure subroutine compute_do_vectorized_cmplx_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( sp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_cmplx_2D_sp pure subroutine compute_do_concurrent_cmplx_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_cmplx_2D_sp subroutine compute_openmp_cmplx_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads complex ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_2D_sp !================================================================================= ! Compute the meshgrid of two complex vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_cmplx_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_2D_dp module pure subroutine compute_do_classic_cmplx_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_cmplx_2D_dp module pure subroutine compute_do_vectorized_cmplx_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( dp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_cmplx_2D_dp module pure subroutine compute_do_concurrent_cmplx_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_cmplx_2D_dp module subroutine compute_openmp_cmplx_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads complex ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_2D_dp !================================================================================= ! Compute the meshgrid of two complex vectors in 128-bit (Quadruple precision) !================================================================================= module subroutine compute_meshgrid_cmplx_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_2D_qp module pure subroutine compute_do_classic_cmplx_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_cmplx_2D_qp module pure subroutine compute_do_vectorized_cmplx_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( qp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_cmplx_2D_qp module pure subroutine compute_do_concurrent_cmplx_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny complex ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_cmplx_2D_qp module subroutine compute_openmp_cmplx_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads complex ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_2D_qp end submodule NAFPack_meshgrid_complex_2D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_complex_2d_compute.f90.html"},{"title":"NAFPack_Krylov_method.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_krylov_method.f90~~EfferentGraph sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Krylov_method use NAFPack_kinds , only : dp use NAFPack_matricielle , only : Make_Tridiagonal implicit none ( type , external ) private contains subroutine lanczos ( A , q1 , m , Q , T ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: q1 integer , intent ( in ) :: m real ( dp ), dimension (:, :), intent ( out ) :: Q real ( dp ), dimension (:, :), intent ( out ) :: T real ( dp ), dimension ( size ( A , 1 )) :: y , z real ( dp ), dimension ( m ) :: alpha real ( dp ), dimension ( m - 1 ) :: beta integer :: N , k N = size ( A , 1 ) alpha = 0.d0 beta = 0.d0 Q = 0.d0 Q (:, 1 ) = q1 / norm2 ( q1 ) do k = 1 , m if ( k == 1 ) then y = matmul ( A , Q (:, k )) else y = matmul ( A , Q (:, k )) - beta ( k - 1 ) * Q (:, k - 1 ) end if alpha ( k ) = dot_product ( Q (:, k ), y ) z = y - alpha ( k ) * Q (:, k ) if ( k < m ) then beta ( k ) = norm2 ( z ) if ( beta ( k ) < 1.0d-12 ) exit Q (:, k + 1 ) = z / beta ( k ) end if end do T = Make_Tridiagonal ( beta , alpha , beta ) end subroutine lanczos subroutine Arnoldi ( A , q1 , m , Q , H ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: q1 integer , intent ( in ) :: m real ( dp ), dimension (:, :), intent ( out ) :: Q real ( dp ), dimension (:, :), intent ( out ) :: H integer :: k , j , N N = size ( A , 1 ) Q (:, 1 ) = q1 / norm2 ( q1 ) H = 0.0d0 do k = 2 , m Q (:, k ) = matmul ( A , Q (:, k - 1 )) do j = 1 , k - 1 H ( j , k - 1 ) = dot_product ( Q (:, j ), Q (:, k )) Q (:, k ) = Q (:, k ) - H ( j , k - 1 ) * Q (:, j ) end do H ( k , k - 1 ) = norm2 ( Q (:, k )) Q (:, k ) = Q (:, k ) / H ( k , k - 1 ) end do end subroutine Arnoldi subroutine Arnoldi_MGS ( A , q1 , m , Q , H ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: q1 integer , intent ( in ) :: m real ( dp ), dimension (:, :), intent ( out ) :: Q ! (n, m+1) real ( dp ), dimension (:, :), intent ( out ) :: H ! (m+1, m) integer :: k , j , N real ( dp ), dimension ( size ( A , 1 )) :: w N = size ( A , 1 ) Q (:, 1 ) = q1 / norm2 ( q1 ) H = 0.0d0 do k = 1 , m ! w = A * q_k w = matmul ( A , Q (:, k )) ! Modified Gram-Schmidt orthonormalization do j = 1 , k H ( j , k ) = dot_product ( Q (:, j ), w ) w = w - H ( j , k ) * Q (:, j ) end do H ( k + 1 , k ) = norm2 ( w ) if ( H ( k + 1 , k ) > 0.0d0 ) then Q (:, k + 1 ) = w / H ( k + 1 , k ) else Q (:, k + 1 ) = 0.0d0 end if end do end subroutine Arnoldi_MGS end module NAFPack_Krylov_method","tags":"","url":"sourcefile\\nafpack_krylov_method.f90.html"},{"title":"NAFPack_meshgrid_integer_2D.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_integer_2d.f90~~EfferentGraph sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid_integer_2d.f90~~AfferentGraph sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90 NAFPack_meshgrid_integer_2D_compute.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90->sourcefile~nafpack_meshgrid_integer_2d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid ) NAFPack_meshgrid_integer_2D implicit none ( type , external ) interface module subroutine compute_meshgrid_integer_2D_i8 ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i8 ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_2D_i8 end interface interface module subroutine compute_meshgrid_integer_2D_i16 ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i16 ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_2D_i16 end interface interface module subroutine compute_meshgrid_integer_2D_isp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_2D_isp end interface interface module subroutine compute_meshgrid_integer_2D_idp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( idp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method end subroutine compute_meshgrid_integer_2D_idp end interface contains module subroutine meshgrid_integer_i8_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i8 ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_2D_i8 ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_integer_i8_2D module subroutine meshgrid_integer_i16_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i16 ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_2D_i16 ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_integer_i16_2D module subroutine meshgrid_integer_isp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_2D_isp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_integer_isp_2D module subroutine meshgrid_integer_idp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( idp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used logical :: use_ij_indexing , use_xy_indexing integer :: Nx , Ny call check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) if ( present ( loop_method )) then loop_method_used = check_loop_method ( loop_method ) else loop_method_used = default_loop_method end if Nx = size ( x_vector , 1 ) Ny = size ( y_vector , 1 ) if ( use_ij_indexing ) then call compute_meshgrid_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny , loop_method_used ) else if ( use_xy_indexing ) then call compute_meshgrid_integer_2D_idp ( y_vector , x_vector , Y , X , Ny , Nx , loop_method_used ) end if end subroutine meshgrid_integer_idp_2D end submodule NAFPack_meshgrid_integer_2D","tags":"","url":"sourcefile\\nafpack_meshgrid_integer_2d.f90.html"},{"title":"NAFPack_kinds.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_kinds.f90~~AfferentGraph sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_fft.f90 NAFPack_fft.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_fft.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_krylov_method.f90 NAFPack_Krylov_method.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_krylov_method.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_market.f90 NAFPack_matrix_market.f90 sourcefile~nafpack_matrix_market.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_ansi_ascii.f90 NAFPack_ANSI_ASCII.f90 sourcefile~nafpack_ansi_ascii.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_ansi_ucs4.f90 NAFPack_ANSI_ucs4.f90 sourcefile~nafpack_ansi_ucs4.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_memory_management_complex.f90 NAFPack_memory_management_complex.f90 sourcefile~nafpack_memory_management_complex.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_memory_management_integer.f90 NAFPack_memory_management_integer.f90 sourcefile~nafpack_memory_management_integer.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_memory_management_real.f90 NAFPack_memory_management_real.f90 sourcefile~nafpack_memory_management_real.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid_complex_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid_complex_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid_integer_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid_integer_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid_real_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid_real_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90 NAFPack_meshgrid_complex_2D_compute.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90->sourcefile~nafpack_meshgrid_complex_2d.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90 NAFPack_meshgrid_complex_3D_compute.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90->sourcefile~nafpack_meshgrid_complex_3d.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90 NAFPack_meshgrid_integer_2D_compute.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90->sourcefile~nafpack_meshgrid_integer_2d.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90 NAFPack_meshgrid_integer_3D_compute.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90->sourcefile~nafpack_meshgrid_integer_3d.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90 NAFPack_meshgrid_real_2D_compute.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90->sourcefile~nafpack_meshgrid_real_2d.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90 NAFPack_meshgrid_real_3D_compute.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90->sourcefile~nafpack_meshgrid_real_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_kinds use , intrinsic :: iso_fortran_env , only : & int8 , int16 , int32 , int64 , & real32 , real64 , real128 implicit none ( type , external ) public integer , parameter :: ascii = selected_char_kind ( 'ascii' ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: sp = real32 integer , parameter :: dp = real64 integer , parameter :: qp = real128 integer , parameter :: i8 = int8 integer , parameter :: i16 = int16 integer , parameter :: isp = int32 integer , parameter :: idp = int64 end module NAFPack_kinds","tags":"","url":"sourcefile\\nafpack_kinds.f90.html"},{"title":"NAFPack_meshgrid_integer_2D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_integer_2d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_integer_2d_compute.f90 NAFPack_meshgrid_integer_2D_compute.f90 sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90->sourcefile~nafpack_meshgrid_integer_2d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_integer_2D ) NAFPack_meshgrid_integer_2D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of two integer vectors in 8-bit !================================================================================= module subroutine compute_meshgrid_integer_2D_i8 ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i8 ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_2D_i8 pure subroutine compute_do_classic_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i8 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_integer_2D_i8 pure subroutine compute_do_vectorized_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i8 ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_integer_2D_i8 pure subroutine compute_do_concurrent_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i8 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_integer_2D_i8 subroutine compute_openmp_integer_2D_i8 ( x_vector , y_vector , X , Y , Nx , Ny , threads ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads integer ( i8 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_2D_i8 !================================================================================= ! Compute the meshgrid of two integer vectors in 16-bit !================================================================================= module subroutine compute_meshgrid_integer_2D_i16 ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i16 ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_2D_i16 pure subroutine compute_do_classic_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i16 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_integer_2D_i16 pure subroutine compute_do_vectorized_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i16 ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_integer_2D_i16 pure subroutine compute_do_concurrent_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( i16 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_integer_2D_i16 subroutine compute_openmp_integer_2D_i16 ( x_vector , y_vector , X , Y , Nx , Ny , threads ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads integer ( i16 ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_2D_i16 !================================================================================= ! Compute the meshgrid of two integer vectors in 32-bit (Single precision) !================================================================================= module subroutine compute_meshgrid_integer_2D_isp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_2D_isp pure subroutine compute_do_classic_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( isp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_integer_2D_isp pure subroutine compute_do_vectorized_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( isp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_integer_2D_isp pure subroutine compute_do_concurrent_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( isp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_integer_2D_isp subroutine compute_openmp_integer_2D_isp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads integer ( isp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_2D_isp !================================================================================= ! Compute the meshgrid of two integer vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_integer_2D_idp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( idp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_integer_2D_idp pure subroutine compute_do_classic_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( idp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_integer_2D_idp pure subroutine compute_do_vectorized_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( idp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_integer_2D_idp pure subroutine compute_do_concurrent_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny integer ( idp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_integer_2D_idp subroutine compute_openmp_integer_2D_idp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads integer ( idp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_integer_2D_idp end submodule NAFPack_meshgrid_integer_2D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_integer_2d_compute.f90.html"},{"title":"NAFPack_Direct_types.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_direct_types.f90~~AfferentGraph sourcefile~nafpack_direct_types.f90 NAFPack_Direct_types.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_types.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Direct_types implicit none ( type , external ) private public :: MethodTypeDirect , MethodQR public :: METHOD_DIRECT_NONE public :: METHOD_Gauss , METHOD_Gauss_JORDAN public :: METHOD_LU , METHOD_LDU public :: METHOD_CHOLESKY , METHOD_LDL_Cholesky , METHOD_QR public :: METHOD_TDMA , METHOD_FADDEEV_LEVERRIER public :: QR_HOUSEHOLDER , QR_GIVENS , QR_GRAM_SCHMIDT public :: QR_GRAM_SCHMIDT_Modified public :: DirectMethodRequirements type :: MethodTypeDirect integer :: id character ( LEN = 64 ) :: name end type MethodTypeDirect type :: MethodQR integer :: id character ( LEN = 64 ) :: name end type MethodQR type :: DirectMethodRequirements logical :: needs_SPD = . false . logical :: needs_non_zero_diag = . false . logical :: needs_square = . false . logical :: needs_tridiagonal = . false . logical :: needs_symmetric = . false . end type DirectMethodRequirements type ( MethodTypeDirect ), parameter :: METHOD_DIRECT_NONE = & MethodTypeDirect ( 0 , \"None\" ) type ( MethodTypeDirect ), parameter :: METHOD_Gauss = & MethodTypeDirect ( 1 , \"Gauss\" ) type ( MethodTypeDirect ), parameter :: METHOD_Gauss_JORDAN = & MethodTypeDirect ( 2 , \"Gauss-Jordan\" ) type ( MethodTypeDirect ), parameter :: METHOD_LU = & MethodTypeDirect ( 3 , \"LU\" ) type ( MethodTypeDirect ), parameter :: METHOD_LDU = & MethodTypeDirect ( 4 , \"LDU\" ) type ( MethodTypeDirect ), parameter :: METHOD_CHOLESKY = & MethodTypeDirect ( 5 , \"Cholesky\" ) type ( MethodTypeDirect ), parameter :: METHOD_LDL_Cholesky = & MethodTypeDirect ( 6 , \"LDL-Cholesky\" ) type ( MethodTypeDirect ), parameter :: METHOD_QR = & MethodTypeDirect ( 7 , \"QR\" ) type ( MethodTypeDirect ), parameter :: METHOD_TDMA = & MethodTypeDirect ( 8 , \"TDMA\" ) type ( MethodTypeDirect ), parameter :: METHOD_FADDEEV_LEVERRIER = & MethodTypeDirect ( 9 , \"Faddeev-Leverrier\" ) type ( MethodQR ), parameter :: QR_HOUSEHOLDER = & MethodQR ( 1 , \"Householder\" ) type ( MethodQR ), parameter :: QR_GIVENS = & MethodQR ( 2 , \"Givens\" ) type ( MethodQR ), parameter :: QR_GRAM_SCHMIDT = & MethodQR ( 3 , \"Gram-Schmidt\" ) type ( MethodQR ), parameter :: QR_GRAM_SCHMIDT_Modified = & MethodQR ( 4 , \"Gram-Schmidt_Modified\" ) end module NAFPack_Direct_types","tags":"","url":"sourcefile\\nafpack_direct_types.f90.html"},{"title":"NAFPack_Eigen.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_eigen.f90~~EfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_eigen.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_eigen.f90~~AfferentGraph sourcefile~nafpack_eigen.f90 NAFPack_Eigen.f90 sourcefile~nafpack_matrix_properties.f90 NAFPack_matrix_properties.f90 sourcefile~nafpack_matrix_properties.f90->sourcefile~nafpack_eigen.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_matrix_properties.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for eigenvalue and eigenvector computations in NAFPack module NAFPack_Eigen use NAFPack_kinds , only : dp use NAFPack_constant , only : TOL_CONVERGENCE_dp , MAX_ITERATION use NAFPack_matrix_decomposition , only : QR_decomposition use NAFPack_matricielle , only : Identity_n , normalise implicit none ( type , external ) private public :: Eigen contains !================== Eigen =============================================================== !> Computes the eigenvalues and eigenvectors of a matrix A !>  A * \\vec{v} = \\lambda * \\vec{v}  !> with **A** a square matrix, **λ** the eigenvalue, and **v** the eigenvector. !> This subroutine allows you to choose the method for computing eigenvalues and eigenvectors: !> !> - Power iteration !> - QR algorithm (with or without shift) !> The default method is Power iteration. subroutine Eigen ( A , lambda , vp , method , k ) real ( dp ), dimension (:, :), intent ( in ) :: A character ( LEN =* ), optional , intent ( in ) :: method integer , optional , intent ( in ) :: k real ( dp ), dimension (:, :), optional , intent ( out ) :: vp real ( dp ), dimension (:), intent ( out ) :: lambda real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: A_tmp real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: vp_tmp character ( LEN = 50 ) :: base_method integer :: N , i , k_max , pos if ( present ( k )) then if ( k <= 0 ) stop \"ERROR :: k must be a positive integer\" k_max = k else k_max = MAX_ITERATION end if N = size ( A , 1 ) if ( size ( A , 2 ) /= N ) stop \"ERROR :: Matrix A not square\" if ( size ( lambda , 1 ) /= N ) stop \"ERROR :: dimension lambda\" if ( present ( vp ) . and . ( size ( vp , 1 ) /= N . or . size ( vp , 2 ) /= N )) stop \"ERROR :: dimension vp\" if ( method == \"Power_iteration\" ) then A_tmp = A do i = 1 , N call Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) end do if ( present ( vp )) vp = vp_tmp else if ( index ( method , \"QR\" ) == 1 ) then if ( present ( vp )) vp = 0 if ( present ( vp )) print * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = index ( trim ( method ), \"_Shifted\" ) if ( pos > 0 . and . pos + 7 == len_trim ( method )) then base_method = method (: pos - 1 ) call Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) else call Eigen_QR ( A , lambda , method , N , k_max ) end if else stop \"ERROR :: Wrong method for Eigen\" end if end subroutine Eigen !> QR algorithm for computing eigenvalues !> !> This subroutine implements the QR algorithm for computing the eigenvalues of a matrix. subroutine Eigen_QR ( A , lambda , method , N , k ) real ( dp ), dimension (:, :), intent ( in ) :: A character ( LEN =* ), intent ( in ) :: method integer , intent ( in ) :: N , k real ( dp ), dimension (:), intent ( out ) :: lambda real ( dp ), dimension ( size ( A , 1 )) :: lambda_old real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: A_tmp , Q , R real ( dp ) :: diff integer :: i , j A_tmp = A do i = 1 , k lambda_old = lambda call QR_decomposition ( A_tmp , method , Q , R ) A_tmp = matmul ( R , Q ) diff = abs ( A_tmp ( 2 , 1 )) do j = 3 , N if ( maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) > diff ) then diff = maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) end if end do if ( i == k ) then print * , \" WARNING :: non-convergence of the QR Algorithm for eigenvalues \" // method print * , \"convergence = \" , diff exit end if if ( diff <= TOL_CONVERGENCE_dp ) exit end do ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] end subroutine Eigen_QR !> Shifted QR algorithm for computing eigenvalues !> !> This subroutine implements the shifted QR algorithm for computing the eigenvalues of a matrix. !> The shift is chosen as the last diagonal element of the matrix. subroutine Eigen_QR_Shifted ( A , lambda , method , N , k ) integer , intent ( in ) :: N , k character ( LEN =* ), intent ( in ) :: method real ( dp ), dimension ( N , N ), intent ( in ) :: A real ( dp ), dimension ( N ), intent ( out ) :: lambda integer :: i , j real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: A_tmp , Q , R , Id real ( dp ) :: shift , diff A_tmp = A Id = Identity_n ( N ) do i = 1 , k !choice of shift: last diagonal element shift = A_tmp ( N , N ) ! Gap : A - µI A_tmp = A_tmp - shift * Id ! QR Decomposition : A - µI = Q * R call QR_decomposition ( A_tmp , method , Q , R ) ! A = RQ + µI A_tmp = matmul ( R , Q ) + shift * Id diff = abs ( A_tmp ( 2 , 1 )) do j = 3 , N if ( maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) > diff ) then diff = maxval ( abs ( A_tmp ( j , 1 : j - 1 ))) end if end do if ( i == k ) then print * , \"WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues \" , & trim ( method ) print * , \"convergence = \" , diff exit end if if ( diff <= TOL_CONVERGENCE_dp ) exit end do ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] end subroutine Eigen_QR_Shifted !> Power iteration method for computing the dominant eigenvalue and eigenvector !> !> This subroutine implements the power iteration method for finding the dominant eigenvalue and eigenvector of a matrix. !> It iteratively computes the eigenvector and eigenvalue until convergence subroutine Power_iteration ( A , lambda , vp , k ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ) :: k real ( dp ), dimension (:), intent ( out ) :: vp real ( dp ), intent ( out ) :: lambda real ( dp ), dimension ( size ( A , 1 )) :: u , vp_tmp , r integer :: i , N N = size ( A , 1 ) call random_number ( u ) u = normalise ( u ) vp_tmp = matmul ( A , u ) lambda = dot_product ( vp_tmp , u ) r = vp_tmp - lambda * u do i = 1 , k u = normalise ( vp_tmp ) vp_tmp = matmul ( A , u ) lambda = dot_product ( vp_tmp , u ) if ( norm2 ( r ) <= TOL_CONVERGENCE_dp ) exit r = vp_tmp - lambda * u if ( i == k ) then print * , \"WARNING :: non-convergence of the power iteration method\" end if end do vp = u end subroutine Power_iteration !> Deflation method for removing the influence of an eigenvalue and eigenvector !> !> This function performs deflation on a matrix A by removing the influence of an eigenvalue and its corresponding eigenvector. function deflation ( A , lambda , vp , k ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: vp real ( dp ), intent ( in ) :: lambda integer , intent ( in ) :: k real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: result real ( dp ), dimension ( size ( A , 1 )) :: wp integer :: i , j , N real ( dp ) :: lambda1 N = size ( A , 1 ) result = A call Power_iteration ( transpose ( A ), lambda1 , wp , k ) do i = 1 , N do j = 1 , N result ( i , j ) = result ( i , j ) - ( lambda * vp ( i ) * wp ( j )) / dot_product ( vp , wp ) end do end do end function deflation end module NAFPack_Eigen","tags":"","url":"sourcefile\\nafpack_eigen.f90.html"},{"title":"NAFPack_matrix_tools.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_matrix_tools.f90~~EfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_tools.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_matrix_tools.f90~~AfferentGraph sourcefile~nafpack_matrix_tools.f90 NAFPack_matrix_tools.f90 sourcefile~nafpack_direct_methode.f90 NAFPack_Direct_methode.f90 sourcefile~nafpack_direct_methode.f90->sourcefile~nafpack_matrix_tools.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_direct_methode.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_matrix_tools use NAFPack_kinds , only : dp use NAFPack_matricielle , only : Identity_n , Trace implicit none ( type , external ) private public :: Faddeev_Leverrier contains subroutine Faddeev_Leverrier ( A , c , Ainv , success , check ) integer , parameter :: dp = kind ( 1.0d0 ) real ( dp ), dimension (:, :), intent ( in ) :: A logical , optional , intent ( in ) :: check real ( dp ), dimension (:), intent ( out ) :: c real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )), optional , intent ( out ) :: Ainv logical , optional , intent ( out ) :: success real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: Bk , I , B_Nm1 , AB logical :: do_check integer :: N , k N = size ( A , 1 ) do_check = . true . if ( present ( check )) do_check = check if ( do_check ) then print * , \"Checking if the matrix A is square and size of c is correct\" if ( size ( A , 2 ) /= N . or . size ( c ) < N + 1 ) then print * , \"Error : Matrix A must be square and size of c must be at least N+1\" stop end if end if ! Initialization I = Identity_n ( N ) c = 0.0_dp c ( 1 ) = 1.0_dp c ( 2 ) = - Trace ( A ) Bk = A + c ( 2 ) * I do k = 2 , N AB = matmul ( A , Bk ) c ( k + 1 ) = - Trace ( AB ) / real ( k , dp ) Bk = AB + c ( k + 1 ) * I if ( k == N - 1 . and . present ( Ainv )) B_Nm1 = - Bk end do if ( present ( Ainv ) . and . present ( success )) then if ( abs ( c ( N + 1 )) < 1.0e-12_dp ) then success = . false . Ainv = 0.0_dp else success = . true . Ainv = B_Nm1 / c ( N + 1 ) end if else if ( present ( Ainv )) then if ( abs ( c ( N + 1 )) < 1.0e-12_dp ) then Ainv = 0.0_dp else Ainv = B_Nm1 / c ( N + 1 ) end if end if end subroutine Faddeev_Leverrier end module NAFPack_matrix_tools","tags":"","url":"sourcefile\\nafpack_matrix_tools.f90.html"},{"title":"NAFPack_meshgrid.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid.f90~~EfferentGraph sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_meshgrid.f90~~AfferentGraph sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid_complex_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid_complex_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid_integer_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid_integer_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid_real_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid_real_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90 NAFPack_meshgrid_complex_2D_compute.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90->sourcefile~nafpack_meshgrid_complex_2d.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90 NAFPack_meshgrid_complex_3D_compute.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90->sourcefile~nafpack_meshgrid_complex_3d.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90 NAFPack_meshgrid_integer_2D_compute.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90->sourcefile~nafpack_meshgrid_integer_2d.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90 NAFPack_meshgrid_integer_3D_compute.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90->sourcefile~nafpack_meshgrid_integer_3d.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90 NAFPack_meshgrid_real_2D_compute.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90->sourcefile~nafpack_meshgrid_real_2d.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90 NAFPack_meshgrid_real_3D_compute.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90->sourcefile~nafpack_meshgrid_real_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module for creating a meshgrid from two vectors !> !> This module provides a subroutine to create a meshgrid. module NAFPack_meshgrid use NAFPack_kinds , only : dp , sp , qp , i8 , i16 , isp , idp use NAFPack_loop_method , only : LoopMethod , count_true_methods , default_loop_method , check_loop_method implicit none ( type , external ) private public :: meshgrid public :: INDEXING_XY , INDEXING_IJ public :: check_indexing , check_loop_method type :: meshgrid_indexing integer :: id character ( len = 2 ) :: name end type meshgrid_indexing type ( meshgrid_indexing ), parameter :: INDEXING_XY = meshgrid_indexing ( 1 , \"XY\" ), & INDEXING_IJ = meshgrid_indexing ( 2 , \"IJ\" ) !> Make N-dimensional meshgrid from two vectors **x_vector** and **y_vector** interface meshgrid module procedure meshgrid_real_sp_2D module procedure meshgrid_real_dp_2D module procedure meshgrid_real_qp_2D module procedure meshgrid_real_sp_3D module procedure meshgrid_real_dp_3D module procedure meshgrid_real_qp_3D module procedure meshgrid_integer_i8_2D module procedure meshgrid_integer_i16_2D module procedure meshgrid_integer_isp_2D module procedure meshgrid_integer_idp_2D module procedure meshgrid_integer_i8_3D module procedure meshgrid_integer_i16_3D module procedure meshgrid_integer_isp_3D module procedure meshgrid_integer_idp_3D module procedure meshgrid_cmplx_sp_2D module procedure meshgrid_cmplx_dp_2D module procedure meshgrid_cmplx_qp_2D module procedure meshgrid_cmplx_sp_3D module procedure meshgrid_cmplx_dp_3D module procedure meshgrid_cmplx_qp_3D end interface meshgrid interface module subroutine meshgrid_real_sp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_sp_2D module subroutine meshgrid_real_dp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_dp_2D module subroutine meshgrid_real_qp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_qp_2D end interface interface module subroutine meshgrid_real_sp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_sp_3D module subroutine meshgrid_real_dp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_dp_3D module subroutine meshgrid_real_qp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector real ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_real_qp_3D end interface interface module subroutine meshgrid_integer_i8_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i8 ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_i8_2D module subroutine meshgrid_integer_i16_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( i16 ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_i16_2D module subroutine meshgrid_integer_isp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_isp_2D module subroutine meshgrid_integer_idp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( idp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_idp_2D end interface interface module subroutine meshgrid_integer_i8_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( i8 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i8 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_i8_3D module subroutine meshgrid_integer_i16_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( i16 ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( i16 ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_i16_3D module subroutine meshgrid_integer_isp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( isp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_isp_3D module subroutine meshgrid_integer_idp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) integer ( idp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( idp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_integer_idp_3D end interface interface module subroutine meshgrid_cmplx_sp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_sp_2D module subroutine meshgrid_cmplx_dp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_dp_2D module subroutine meshgrid_cmplx_qp_2D ( & x_vector , y_vector , & X , Y , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_qp_2D end interface interface module subroutine meshgrid_cmplx_sp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_sp_3D module subroutine meshgrid_cmplx_dp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_dp_3D module subroutine meshgrid_cmplx_qp_3D ( & x_vector , y_vector , z_vector , & X , Y , Z , & indexing , & strict_mode , & loop_method ) implicit none ( type , external ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode type ( LoopMethod ), optional , intent ( in ) :: loop_method end subroutine meshgrid_cmplx_qp_3D end interface contains subroutine check_indexing ( indexing , strict_mode , use_ij_indexing , use_xy_indexing ) type ( meshgrid_indexing ), optional , intent ( in ) :: indexing logical , optional , intent ( in ) :: strict_mode logical , intent ( out ) :: use_ij_indexing , use_xy_indexing logical :: is_strict is_strict = . false . if ( present ( strict_mode )) is_strict = strict_mode use_ij_indexing = . false . use_xy_indexing = . false . if ( present ( indexing )) then if ( indexing % id == INDEXING_IJ % id ) then use_ij_indexing = . true . else if ( indexing % id == INDEXING_XY % id ) then use_xy_indexing = . true . else if ( is_strict ) then error stop \"Error: Unknown indexing%id in meshgrid\" else use_ij_indexing = . true . end if end if else use_ij_indexing = . true . end if end subroutine check_indexing end module NAFPack_meshgrid","tags":"","url":"sourcefile\\nafpack_meshgrid.f90.html"},{"title":"NAFPack_meshgrid_complex_3D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_complex_3d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_complex_3d_compute.f90 NAFPack_meshgrid_complex_3D_compute.f90 sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90->sourcefile~nafpack_meshgrid_complex_3d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_complex_3D ) NAFPack_meshgrid_complex_3D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of three complex vectors in 32-bit (single precision) !================================================================================= module subroutine compute_meshgrid_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_3D_sp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_3D_sp pure subroutine compute_do_classic_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_cmplx_3D_sp pure subroutine compute_do_vectorized_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_cmplx_3D_sp pure subroutine compute_do_concurrent_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_cmplx_3D_sp subroutine compute_openmp_cmplx_3D_sp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) complex ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads complex ( sp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_3D_sp !================================================================================= ! Compute the meshgrid of three complex vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_3D_dp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_3D_dp pure subroutine compute_do_classic_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_cmplx_3D_dp pure subroutine compute_do_vectorized_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_cmplx_3D_dp pure subroutine compute_do_concurrent_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_cmplx_3D_dp subroutine compute_openmp_cmplx_3D_dp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) complex ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads complex ( dp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_3D_dp !================================================================================= ! Compute the meshgrid of three complex vectors in 128-bit (Quadruple precision) !================================================================================= module subroutine compute_meshgrid_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , & loop_method ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector complex ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X , Y , Z integer ( isp ), intent ( in ) :: Nx , Ny , Nz type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx , Nz ), Y ( Ny , Nx , Nz ), Z ( Ny , Nx , Nz )) if ( loop_method % use_do_classic ) then call compute_do_classic_cmplx_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_cmplx_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_cmplx_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_cmplx_3D_qp ( x_vector , y_vector , z_vector , X , Y , Z , Nx , Ny , Nz , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_cmplx_3D_qp pure subroutine compute_do_classic_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do end subroutine compute_do_classic_cmplx_3D_qp pure subroutine compute_do_vectorized_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z X = spread ( spread ( x_vector , 1 , Ny ), 3 , Nz ) Y = spread ( spread ( y_vector , 2 , Nx ), 3 , Nz ) Z = spread ( spread ( z_vector , 1 , Nx ), 1 , Ny ) end subroutine compute_do_vectorized_cmplx_3D_qp pure subroutine compute_do_concurrent_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz complex ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k do concurrent ( k = 1 : Nz , i = 1 : Ny ) X ( i , :, k ) = x_vector (:) end do do concurrent ( k = 1 : Nz , j = 1 : Nx ) Y (:, j , k ) = y_vector (:) end do do concurrent ( j = 1 : Nx , i = 1 : Ny ) Z ( i , j , :) = z_vector (:) end do end subroutine compute_do_concurrent_cmplx_3D_qp subroutine compute_openmp_cmplx_3D_qp ( & x_vector , y_vector , z_vector , & X , Y , Z , & Nx , Ny , Nz , threads ) complex ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector , z_vector integer ( isp ), intent ( in ) :: Nx , Ny , Nz , threads complex ( qp ), dimension (:, :, :), intent ( out ) :: X , Y , Z integer ( isp ) :: i , j , k !$omp parallel default(none) private(i, j, k) & !$omp& shared(X, Y, Z, x_vector, y_vector, z_vector, Nx, Ny, Nz) & !$omp& num_threads(threads) !$omp do do k = 1 , Nz do i = 1 , Ny X ( i , :, k ) = x_vector (:) end do end do !$omp end do !$omp do do k = 1 , Nz do j = 1 , Nx Y (:, j , k ) = y_vector (:) end do end do !$omp end do !$omp do do j = 1 , Nx do i = 1 , Ny Z ( i , j , :) = z_vector (:) end do end do !$omp end do !$omp end parallel end subroutine compute_openmp_cmplx_3D_qp end submodule NAFPack_meshgrid_complex_3D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_complex_3d_compute.f90.html"},{"title":"NAFPack_ANSI.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_ansi.f90~~EfferentGraph sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_io_utils.f90 NAFPack_io_utils.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_io_utils.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_ansi.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_io_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_ansi.f90~~AfferentGraph sourcefile~nafpack_ansi.f90 NAFPack_ANSI.f90 sourcefile~nafpack_ansi_ascii.f90 NAFPack_ANSI_ASCII.f90 sourcefile~nafpack_ansi_ascii.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_ansi_ucs4.f90 NAFPack_ANSI_ucs4.f90 sourcefile~nafpack_ansi_ucs4.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_logger_mod.f90 NAFPack_Logger_mod.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_terminal.f90 NAFPack_terminal.f90 sourcefile~nafpack_logger_mod.f90->sourcefile~nafpack_terminal.f90 sourcefile~nafpack_terminal.f90->sourcefile~nafpack_ansi.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_logger_mod.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_ANSI use , intrinsic :: iso_fortran_env , only : output_unit use NAFPack_kinds , only : i8 , i16 , ascii , ucs4 use NAFPack_io_utils , only : to_str_ascii , to_str_ucs4 implicit none ( type , external ) private public :: output_unit public :: AnsiCode public :: Ansi_Constants public :: ColorsAscii , ColorsUcs4 public :: set_ansi_code , reset_ansi_code public :: create_ansi_ascii , create_ansi_ucs4 public :: apply_style_ascii , apply_style_ucs4 public :: colorize_text_ascii , colorize_text_ucs4 public :: cursor_position_ascii , cursor_position_ucs4 public :: clear_screen_ascii , clear_screen_ucs4 public :: clear_line_ascii , clear_line_ucs4 public :: save_cursor_ascii , save_cursor_ucs4 public :: restore_cursor_ascii , restore_cursor_ucs4 type :: AnsiCode private !> Style descriptor logical :: use_style = . false . integer ( i8 ) :: style = - 1_i8 !> Foreground color logical :: use_fg = . false . integer ( i16 ) :: fg = - 1_i16 !> Background color logical :: use_bg = . false . integer ( i16 ) :: bg = - 1_i16 end type AnsiCode type :: AnsiConstants ! Styles type ( AnsiCode ) :: & STYLE_RESET = AnsiCode ( use_style = . true ., style = 0_i8 ), & STYLE_BOLD = AnsiCode ( use_style = . true ., style = 1_i8 ), & STYLE_FAINT = AnsiCode ( use_style = . true ., style = 2_i8 ), & STYLE_ITALIC = AnsiCode ( use_style = . true ., style = 3_i8 ), & STYLE_UNDERLINE = AnsiCode ( use_style = . true ., style = 4_i8 ), & STYLE_BLINK = AnsiCode ( use_style = . true ., style = 5_i8 ), & STYLE_REVERSE = AnsiCode ( use_style = . true ., style = 7_i8 ), & STYLE_HIDDEN = AnsiCode ( use_style = . true ., style = 8_i8 ), & STYLE_STRIKETHROUGH = AnsiCode ( use_style = . true ., style = 9_i8 ) ! fg colors type ( AnsiCode ) :: & FG_BLACK = AnsiCode ( use_fg = . true ., fg = 0_i16 ), & FG_RED = AnsiCode ( use_fg = . true ., fg = 1_i16 ), & FG_GREEN = AnsiCode ( use_fg = . true ., fg = 2_i16 ), & FG_YELLOW = AnsiCode ( use_fg = . true ., fg = 3_i16 ), & FG_BLUE = AnsiCode ( use_fg = . true ., fg = 4_i16 ), & FG_MAGENTA = AnsiCode ( use_fg = . true ., fg = 5_i16 ), & FG_CYAN = AnsiCode ( use_fg = . true ., fg = 6_i16 ), & FG_WHITE = AnsiCode ( use_fg = . true ., fg = 7_i16 ) ! fg bright colors type ( AnsiCode ) :: & FG_BRIGHT_BLACK = AnsiCode ( use_fg = . true ., fg = 8_i16 ), & FG_BRIGHT_RED = AnsiCode ( use_fg = . true ., fg = 9_i16 ), & FG_BRIGHT_GREEN = AnsiCode ( use_fg = . true ., fg = 10_i16 ), & FG_BRIGHT_YELLOW = AnsiCode ( use_fg = . true ., fg = 11_i16 ), & FG_BRIGHT_BLUE = AnsiCode ( use_fg = . true ., fg = 12_i16 ), & FG_BRIGHT_MAGENTA = AnsiCode ( use_fg = . true ., fg = 13_i16 ), & FG_BRIGHT_CYAN = AnsiCode ( use_fg = . true ., fg = 14_i16 ), & FG_BRIGHT_WHITE = AnsiCode ( use_fg = . true ., fg = 15_i16 ) ! bg colors type ( AnsiCode ) :: & BG_BLACK = AnsiCode ( use_bg = . true ., bg = 0_i16 ), & BG_RED = AnsiCode ( use_bg = . true ., bg = 1_i16 ), & BG_GREEN = AnsiCode ( use_bg = . true ., bg = 2_i16 ), & BG_YELLOW = AnsiCode ( use_bg = . true ., bg = 3_i16 ), & BG_BLUE = AnsiCode ( use_bg = . true ., bg = 4_i16 ), & BG_MAGENTA = AnsiCode ( use_bg = . true ., bg = 5_i16 ), & BG_CYAN = AnsiCode ( use_bg = . true ., bg = 6_i16 ), & BG_WHITE = AnsiCode ( use_bg = . true ., bg = 7_i16 ) ! bg bright colors type ( AnsiCode ) :: & BG_BRIGHT_BLACK = AnsiCode ( use_bg = . true ., bg = 8_i16 ), & BG_BRIGHT_RED = AnsiCode ( use_bg = . true ., bg = 9_i16 ), & BG_BRIGHT_GREEN = AnsiCode ( use_bg = . true ., bg = 10_i16 ), & BG_BRIGHT_YELLOW = AnsiCode ( use_bg = . true ., bg = 11_i16 ), & BG_BRIGHT_BLUE = AnsiCode ( use_bg = . true ., bg = 12_i16 ), & BG_BRIGHT_MAGENTA = AnsiCode ( use_bg = . true ., bg = 13_i16 ), & BG_BRIGHT_CYAN = AnsiCode ( use_bg = . true ., bg = 14_i16 ), & BG_BRIGHT_WHITE = AnsiCode ( use_bg = . true ., bg = 15_i16 ) end type AnsiConstants type ( AnsiConstants ), parameter :: Ansi_Constants = AnsiConstants () type :: ColorsAscii character ( len = :), allocatable :: & reset , bold , faint , italic , underline , blink , reverse , hidden , strikethrough , & red , green , yellow , blue , magenta , cyan , white , & bright_red , bright_green , bright_yellow , bright_blue , bright_magenta , bright_cyan , & bright_white contains procedure :: init => init_colors_ascii end type ColorsAscii interface module subroutine init_colors_ascii ( this ) class ( ColorsAscii ), intent ( out ) :: this end subroutine init_colors_ascii end interface type :: ColorsUcs4 character ( len = :, kind = ucs4 ), allocatable :: & reset , bold , faint , italic , underline , blink , reverse , hidden , strikethrough , & red , green , yellow , blue , magenta , cyan , white , & bright_red , bright_green , bright_yellow , bright_blue , bright_magenta , bright_cyan , & bright_white contains procedure :: init => init_colors_ucs4 end type ColorsUcs4 interface module subroutine init_colors_ucs4 ( this ) class ( ColorsUcs4 ), intent ( out ) :: this end subroutine init_colors_ucs4 end interface interface pure module function create_ansi_ascii ( ansi_code ) result ( ansi_string ) type ( AnsiCode ), intent ( in ) :: ansi_code character ( len = :, kind = ascii ), allocatable :: ansi_string end function create_ansi_ascii pure module function apply_style_ascii ( text , style ) result ( styled_text ) character ( * , kind = ascii ), intent ( in ) :: text type ( AnsiCode ), intent ( in ) :: style character (:, kind = ascii ), allocatable :: styled_text end function apply_style_ascii pure module function colorize_text_ascii ( text , color ) result ( colored_text ) character ( * , kind = ascii ), intent ( in ) :: text integer ( i16 ), intent ( in ) :: color character (:, kind = ascii ), allocatable :: colored_text end function colorize_text_ascii module subroutine cursor_position_ascii ( row , col ) integer , intent ( in ) :: row , col end subroutine cursor_position_ascii module subroutine clear_screen_ascii () end subroutine clear_screen_ascii module subroutine clear_line_ascii () end subroutine clear_line_ascii module subroutine save_cursor_ascii () end subroutine save_cursor_ascii module subroutine restore_cursor_ascii () end subroutine restore_cursor_ascii end interface interface pure module function create_ansi_ucs4 ( ansi_code ) result ( ansi_string ) type ( AnsiCode ), intent ( in ) :: ansi_code character ( len = :, kind = ucs4 ), allocatable :: ansi_string end function create_ansi_ucs4 pure module function apply_style_ucs4 ( text , style ) result ( styled_text ) character ( * , kind = ucs4 ), intent ( in ) :: text type ( AnsiCode ), intent ( in ) :: style character (:, kind = ucs4 ), allocatable :: styled_text end function apply_style_ucs4 pure module function colorize_text_ucs4 ( text , color ) result ( colored_text ) character ( * , kind = ucs4 ), intent ( in ) :: text integer ( i16 ), intent ( in ) :: color character (:, kind = ucs4 ), allocatable :: colored_text end function colorize_text_ucs4 module subroutine cursor_position_ucs4 ( row , col ) integer , intent ( in ) :: row , col end subroutine cursor_position_ucs4 module subroutine clear_screen_ucs4 () end subroutine clear_screen_ucs4 module subroutine clear_line_ucs4 () end subroutine clear_line_ucs4 module subroutine save_cursor_ucs4 () end subroutine save_cursor_ucs4 module subroutine restore_cursor_ucs4 () end subroutine restore_cursor_ucs4 end interface contains pure module function set_ansi_code ( style , fg_color , bg_color ) result ( ansi_code ) integer ( i8 ), optional , intent ( in ) :: style integer ( i16 ), optional , intent ( in ) :: fg_color , bg_color type ( AnsiCode ) :: ansi_code ansi_code % use_style = . false . ansi_code % use_fg = . false . ansi_code % use_bg = . false . if ( present ( style )) then ansi_code % use_style = style >= 0 . and . style < 10 if ( ansi_code % use_style ) ansi_code % style = style end if if ( present ( fg_color )) then ansi_code % use_fg = fg_color >= 0 . and . fg_color <= 255 if ( ansi_code % use_fg ) ansi_code % fg = fg_color end if if ( present ( bg_color )) then ansi_code % use_bg = bg_color >= 0 . and . bg_color <= 255 if ( ansi_code % use_bg ) ansi_code % bg = bg_color end if if (. not . ( ansi_code % use_style . or . ansi_code % use_fg . or . ansi_code % use_bg )) then ansi_code = Ansi_Constants % STYLE_RESET end if end function set_ansi_code pure module function reset_ansi_code () result ( ansi_code ) type ( AnsiCode ) :: ansi_code ansi_code = Ansi_Constants % STYLE_RESET end function reset_ansi_code end module NAFPack_ANSI","tags":"","url":"sourcefile\\nafpack_ansi.f90.html"},{"title":"NAFPack_loop_method.f90 – NAFPack","text":"Files dependent on this one sourcefile~~nafpack_loop_method.f90~~AfferentGraph sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_fourier_transform_dft.f90 NAFPack_Fourier_Transform_dft.f90 sourcefile~nafpack_fourier_transform_dft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft2.f90 NAFPack_Fourier_Transform_dft2.f90 sourcefile~nafpack_fourier_transform_dft2.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_dft3.f90 NAFPack_Fourier_Transform_dft3.f90 sourcefile~nafpack_fourier_transform_dft3.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_meshgrid_complex_2d.f90 NAFPack_meshgrid_complex_2D.f90 sourcefile~nafpack_meshgrid_complex_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_complex_3d.f90 NAFPack_meshgrid_complex_3D.f90 sourcefile~nafpack_meshgrid_complex_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_2d.f90 NAFPack_meshgrid_integer_2D.f90 sourcefile~nafpack_meshgrid_integer_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_integer_3d.f90 NAFPack_meshgrid_integer_3D.f90 sourcefile~nafpack_meshgrid_integer_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid_real_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_3d.f90 NAFPack_meshgrid_real_3D.f90 sourcefile~nafpack_meshgrid_real_3d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90 NAFPack_Fourier_Transform_dft_compute.f90 sourcefile~nafpack_fourier_transform_dft_compute.f90->sourcefile~nafpack_fourier_transform_dft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90 NAFPack_Fourier_Transform_fft_compute_split_radix.f90 sourcefile~nafpack_fourier_transform_fft_compute_split_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90 NAFPack_meshgrid_complex_2D_compute.f90 sourcefile~nafpack_meshgrid_complex_2d_compute.f90->sourcefile~nafpack_meshgrid_complex_2d.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90 NAFPack_meshgrid_complex_3D_compute.f90 sourcefile~nafpack_meshgrid_complex_3d_compute.f90->sourcefile~nafpack_meshgrid_complex_3d.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90 NAFPack_meshgrid_integer_2D_compute.f90 sourcefile~nafpack_meshgrid_integer_2d_compute.f90->sourcefile~nafpack_meshgrid_integer_2d.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90 NAFPack_meshgrid_integer_3D_compute.f90 sourcefile~nafpack_meshgrid_integer_3d_compute.f90->sourcefile~nafpack_meshgrid_integer_3d.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90 NAFPack_meshgrid_real_2D_compute.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90->sourcefile~nafpack_meshgrid_real_2d.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90 NAFPack_meshgrid_real_3D_compute.f90 sourcefile~nafpack_meshgrid_real_3d_compute.f90->sourcefile~nafpack_meshgrid_real_3d.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_loop_method implicit none ( type , external ) private public :: LoopMethod , init_loop_method , count_true_methods , check_loop_method public :: default_loop_method type :: ParallelMethod logical :: use_openmp = . false . logical :: use_mpi = . false . integer :: num_threads = 1 end type ParallelMethod type :: LoopMethod logical :: use_do_classic = . false . logical :: use_vectorized = . false . logical :: use_do_concurrent = . false . type ( ParallelMethod ) :: parallel end type LoopMethod type ( LoopMethod ), parameter :: default_loop_method = LoopMethod ( use_do_classic = . true .), & empty_loop_method = LoopMethod () contains pure function init_loop_method ( & use_do_classic , & use_vectorized , & use_do_concurrent , & use_openmp , & use_mpi , & num_threads ) result ( loop_method ) logical , intent ( in ), optional :: use_do_classic , & use_vectorized , & use_do_concurrent , & use_openmp , & use_mpi integer , intent ( in ), optional :: num_threads type ( LoopMethod ) :: loop_method logical :: method_used loop_method = empty_loop_method method_used = . false . if ( present ( use_do_classic )) then if ( use_do_classic ) loop_method % use_do_classic = . true . end if if ( present ( use_vectorized )) then if ( use_vectorized ) loop_method % use_vectorized = . true . call check_method_used ( method_used ) end if if ( present ( use_do_concurrent )) then if ( use_do_concurrent ) loop_method % use_do_concurrent = . true . call check_method_used ( method_used ) end if if ( present ( use_openmp )) then if ( use_openmp ) loop_method % parallel % use_openmp = . true . if ( present ( num_threads )) then if ( num_threads > 0 ) then loop_method % parallel % num_threads = num_threads else error stop \"num_threads must be a positive integer\" end if end if call check_method_used ( method_used ) end if if ( present ( use_mpi )) then if ( use_mpi ) loop_method % parallel % use_mpi = . true . if ( present ( num_threads )) then if ( num_threads > 0 ) then loop_method % parallel % num_threads = num_threads else error stop \"num_threads must be a positive integer\" end if end if call check_method_used ( method_used ) end if if (. not . method_used ) then loop_method = default_loop_method end if end function init_loop_method pure subroutine check_method_used ( method_used ) logical , intent ( inout ) :: method_used if (. not . method_used ) then method_used = . true . else error stop \"Multiple loop methods cannot be used simultaneously\" end if end subroutine check_method_used pure function count_true_methods ( loop_method ) result ( count_true ) type ( LoopMethod ), intent ( in ) :: loop_method integer :: count_true count_true = 0 if ( loop_method % use_do_classic ) count_true = count_true + 1 if ( loop_method % use_vectorized ) count_true = count_true + 1 if ( loop_method % use_do_concurrent ) count_true = count_true + 1 if ( loop_method % parallel % use_openmp ) count_true = count_true + 1 if ( loop_method % parallel % use_mpi ) count_true = count_true + 1 end function count_true_methods function check_loop_method ( loop_method ) result ( loop_method_used ) type ( LoopMethod ), intent ( in ) :: loop_method type ( LoopMethod ) :: loop_method_used integer :: nb_of_true nb_of_true = count_true_methods ( loop_method ) if ( nb_of_true == 0 ) then loop_method_used = default_loop_method else if ( nb_of_true == 1 ) then loop_method_used = loop_method else loop_method_used = default_loop_method end if end function check_loop_method end module NAFPack_loop_method","tags":"","url":"sourcefile\\nafpack_loop_method.f90.html"},{"title":"NAFPack_memory_management_complex.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_memory_management_complex.f90~~EfferentGraph sourcefile~nafpack_memory_management_complex.f90 NAFPack_memory_management_complex.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_memory_management_complex.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_memory_management ) NAFPack_memory_management_complex implicit none ( type , external ) contains module subroutine realloc_vec_complex_sp_1D ( vec , new_size ) complex ( sp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size complex ( sp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_sp_1D module subroutine realloc_vec_complex_dp_1D ( vec , new_size ) complex ( dp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size complex ( dp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_dp_1D module subroutine realloc_vec_complex_qp_1D ( vec , new_size ) complex ( qp ), dimension (:), allocatable , intent ( inout ) :: vec integer ( isp ), intent ( in ) :: new_size complex ( qp ), dimension (:), allocatable :: vec_tmp integer ( isp ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size )) return end if old_size = size ( vec ) call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size )) vec (:) = vec_tmp ( 1 : min ( old_size , new_size )) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_qp_1D module subroutine realloc_vec_complex_sp_2D ( vec , new_size ) complex ( sp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size complex ( sp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_sp_2D module subroutine realloc_vec_complex_dp_2D ( vec , new_size ) complex ( dp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size complex ( dp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_dp_2D module subroutine realloc_vec_complex_qp_2D ( vec , new_size ) complex ( qp ), dimension (:, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 2 ), intent ( in ) :: new_size complex ( qp ), dimension (:, :), allocatable :: vec_tmp integer ( isp ), dimension ( 2 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ))) vec (:, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), 1 : min ( old_size ( 2 ), new_size ( 2 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_qp_2D module subroutine realloc_vec_complex_sp_3D ( vec , new_size ) complex ( sp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size complex ( sp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_sp_3D module subroutine realloc_vec_complex_dp_3D ( vec , new_size ) complex ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size complex ( dp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_dp_3D module subroutine realloc_vec_complex_qp_3D ( vec , new_size ) complex ( qp ), dimension (:, :, :), allocatable , intent ( inout ) :: vec integer ( isp ), dimension ( 3 ), intent ( in ) :: new_size complex ( qp ), dimension (:, :, :), allocatable :: vec_tmp integer ( isp ), dimension ( 3 ) :: old_size if (. not . allocated ( vec )) then allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) return end if old_size = [ size ( vec , 1 ), size ( vec , 2 ), size ( vec , 3 )] call move_alloc ( vec , vec_tmp ) allocate ( vec ( new_size ( 1 ), new_size ( 2 ), new_size ( 3 ))) vec (:, :, :) = vec_tmp ( 1 : min ( old_size ( 1 ), new_size ( 1 )), & 1 : min ( old_size ( 2 ), new_size ( 2 )), & 1 : min ( old_size ( 3 ), new_size ( 3 ))) deallocate ( vec_tmp ) end subroutine realloc_vec_complex_qp_3D end submodule NAFPack_memory_management_complex","tags":"","url":"sourcefile\\nafpack_memory_management_complex.f90.html"},{"title":"NAFPack_Preconditioners.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_preconditioners.f90~~EfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_preconditioners.f90~~AfferentGraph sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Preconditioners use NAFPack_kinds , only : dp USE NAFPack_constant , only : TOL_CONVERGENCE_dp use NAFPack_matricielle , only : Diag use NAFPack_matrix_decomposition , only : Incomplete_Cholesky_decomposition , ILU_decomposition implicit none ( type , external ) private public :: MethodPreconditioner public :: METHOD_PRECOND_NONE public :: METHOD_PRECOND_JACOBI , METHOD_PRECOND_JOR public :: METHOD_PRECOND_GS , METHOD_PRECOND_SOR , METHOD_PRECOND_SSOR public :: METHOD_PRECOND_ILU , METHOD_PRECOND_ICF public :: FILL_LEVEL_USED public :: FILL_LEVEL_NONE public :: FILL_LEVEL_0 , FILL_LEVEL_1 , FILL_LEVEL_2 , FILL_LEVEL_3 public :: FILL_LEVEL_N public :: Calculate_Jacobi_preconditioner public :: Calculate_Gauss_Seidel_preconditioner public :: Calculate_SOR_preconditioner public :: Calculate_JOR_preconditioner public :: Calculate_ILU_preconditioner public :: Calculate_ICF_preconditioner public :: Calculate_SSOR_preconditioner type :: MethodPreconditioner integer :: id character ( LEN = 64 ) :: name end type MethodPreconditioner type :: Fill_level_used integer :: id character ( LEN = 64 ) :: name integer :: value end type Fill_level_used type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_NONE = & MethodPreconditioner ( 0 , \"None\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_JACOBI = & MethodPreconditioner ( 1 , \"Jacobi\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_GS = & MethodPreconditioner ( 2 , \"Gauss-Seidel\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_SOR = & MethodPreconditioner ( 3 , \"Successive Over-Relaxation\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_JOR = & MethodPreconditioner ( 4 , \"Jacobi Over-Relaxation\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_ILU = & MethodPreconditioner ( 5 , \"ILU\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_ICF = & MethodPreconditioner ( 6 , \"ICF\" ) type ( MethodPreconditioner ), parameter :: METHOD_PRECOND_SSOR = & MethodPreconditioner ( 7 , \"SSOR\" ) type ( Fill_level_used ), parameter :: FILL_LEVEL_NONE = Fill_level_used ( - 1 , \"None\" , - huge ( 1 )) type ( Fill_level_used ), parameter :: FILL_LEVEL_0 = Fill_level_used ( 0 , \"Level 0\" , 0 ) type ( Fill_level_used ), parameter :: FILL_LEVEL_1 = Fill_level_used ( 1 , \"Level 1\" , 1 ) type ( Fill_level_used ), parameter :: FILL_LEVEL_2 = Fill_level_used ( 2 , \"Level 2\" , 2 ) type ( Fill_level_used ), parameter :: FILL_LEVEL_3 = Fill_level_used ( 3 , \"Level 3\" , 3 ) type ( Fill_level_used ) :: FILL_LEVEL_N = Fill_level_used ( 3 , \"Level N\" , 0 ) contains function Calculate_Jacobi_preconditioner ( A ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: D integer :: N , i N = size ( A , 1 ) D = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in Jacobi preconditioner\" forall ( i = 1 : N ) D ( i , i ) = 1.d0 / A ( i , i ) end function Calculate_Jacobi_preconditioner function Calculate_Gauss_Seidel_preconditioner ( A ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer :: N , i , j N = size ( A , 1 ) L = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in Gauss-Seidel preconditioner\" forall ( i = 1 : size ( A , 1 ), j = 1 : size ( A , 2 ), i >= j ) L ( i , j ) = A ( i , j ) end function Calculate_Gauss_Seidel_preconditioner function Calculate_SOR_preconditioner ( A , omega , alpha ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer :: N , i N = size ( A , 1 ) L = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in SOR preconditioner\" do i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) end do L = alpha * L end function Calculate_SOR_preconditioner function Calculate_JOR_preconditioner ( A , omega , alpha ) result ( D ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: D integer :: N , i N = size ( A , 1 ) D = 0.d0 if ( any ( Diag ( A ) < TOL_CONVERGENCE_dp )) stop \"ERROR :: Zero diagonal in JOR preconditioner\" forall ( i = 1 : size ( A , 1 )) D ( i , i ) = omega / A ( i , i ) D = D / alpha end function Calculate_JOR_preconditioner subroutine Calculate_ILU_preconditioner ( A , L , U , omega , alpha , fill_level ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: L , U integer , optional , intent ( in ) :: fill_level integer :: N N = size ( A , 1 ) L = 0.d0 U = 0.d0 if ( present ( fill_level )) then call ILU_decomposition ( A , L , U , fill_level ) else call ILU_decomposition ( A , L , U ) end if L = alpha / omega * L end subroutine Calculate_ILU_preconditioner function Calculate_ICF_preconditioner ( A , omega , alpha , fill_level ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: L integer , optional , intent ( in ) :: fill_level integer :: N N = size ( A , 1 ) L = 0.d0 if ( present ( fill_level )) then call Incomplete_Cholesky_decomposition ( A , L , fill_level ) else call Incomplete_Cholesky_decomposition ( A , L ) end if L = alpha / omega * L end function Calculate_ICF_preconditioner subroutine Calculate_SSOR_preconditioner ( A , L , D , omega , alpha ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), intent ( in ) :: omega , alpha real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )), intent ( out ) :: L , D integer :: N , i N = size ( A , 1 ) L = 0.d0 D = 0.d0 do i = 1 , size ( A , 1 ) L ( i , i ) = 1.d0 / omega * A ( i , i ) L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D ( i , i ) = A ( i , i ) end do L = ( alpha * omega ) / ( 2 - omega ) * L end subroutine Calculate_SSOR_preconditioner end module NAFPack_Preconditioners","tags":"","url":"sourcefile\\nafpack_preconditioners.f90.html"},{"title":"NAFPack_meshgrid_real_2D_compute.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_meshgrid_real_2d_compute.f90~~EfferentGraph sourcefile~nafpack_meshgrid_real_2d_compute.f90 NAFPack_meshgrid_real_2D_compute.f90 sourcefile~nafpack_meshgrid_real_2d.f90 NAFPack_meshgrid_real_2D.f90 sourcefile~nafpack_meshgrid_real_2d_compute.f90->sourcefile~nafpack_meshgrid_real_2d.f90 sourcefile~nafpack_meshgrid.f90 NAFPack_meshgrid.f90 sourcefile~nafpack_meshgrid_real_2d.f90->sourcefile~nafpack_meshgrid.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_meshgrid.f90->sourcefile~nafpack_loop_method.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_meshgrid : NAFPack_meshgrid_real_2D ) NAFPack_meshgrid_real_2D_compute implicit none ( type , external ) contains !================================================================================= ! Compute the meshgrid of two real vectors in 32-bit (single precision) !================================================================================= module subroutine compute_meshgrid_real_2D_sp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_2D_sp pure subroutine compute_do_classic_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_real_2D_sp pure subroutine compute_do_vectorized_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( sp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_real_2D_sp pure subroutine compute_do_concurrent_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_real_2D_sp subroutine compute_openmp_real_2D_sp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) real ( sp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads real ( sp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_2D_sp !================================================================================= ! Compute the meshgrid of two real vectors in 64-bit (double precision) !================================================================================= module subroutine compute_meshgrid_real_2D_dp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_2D_dp pure subroutine compute_do_classic_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_real_2D_dp pure subroutine compute_do_vectorized_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( dp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_real_2D_dp pure subroutine compute_do_concurrent_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_real_2D_dp subroutine compute_openmp_real_2D_dp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) real ( dp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads real ( dp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_2D_dp !================================================================================= ! Compute the meshgrid of two real vectors in 128-bit (quadruple precision) !================================================================================= module subroutine compute_meshgrid_real_2D_qp ( & x_vector , y_vector , & X , Y , & Nx , Ny , & loop_method ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X , Y integer ( isp ), intent ( in ) :: Nx , Ny type ( LoopMethod ), intent ( in ) :: loop_method allocate ( X ( Ny , Nx ), Y ( Ny , Nx )) if ( loop_method % use_do_classic ) then call compute_do_classic_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_vectorized ) then call compute_do_vectorized_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % use_do_concurrent ) then call compute_do_concurrent_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) else if ( loop_method % parallel % use_openmp ) then call compute_openmp_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , & loop_method % parallel % num_threads ) end if end subroutine compute_meshgrid_real_2D_qp pure subroutine compute_do_classic_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do i = 1 , Ny X ( i , :) = x_vector (:) end do do j = 1 , Nx Y (:, j ) = y_vector (:) end do end subroutine compute_do_classic_real_2D_qp pure subroutine compute_do_vectorized_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( qp ), dimension (:, :), intent ( out ) :: X , Y X = spread ( x_vector , 1 , Ny ) Y = spread ( y_vector , 2 , Nx ) end subroutine compute_do_vectorized_real_2D_qp pure subroutine compute_do_concurrent_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny real ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j do concurrent ( i = 1 : Ny ) X ( i , :) = x_vector (:) end do do concurrent ( j = 1 : Nx ) Y (:, j ) = y_vector (:) end do end subroutine compute_do_concurrent_real_2D_qp subroutine compute_openmp_real_2D_qp ( x_vector , y_vector , X , Y , Nx , Ny , threads ) real ( qp ), dimension (:), intent ( in ) :: x_vector , y_vector integer ( isp ), intent ( in ) :: Nx , Ny , threads real ( qp ), dimension (:, :), intent ( out ) :: X , Y integer ( isp ) :: i , j !$omp parallel default(none) private(i, j) & !$omp& shared(X, Y, x_vector, y_vector, Nx, Ny) & !$omp& num_threads(threads) !$omp do do i = 1 , Ny X ( i , :) = x_vector (:) end do !$omp end do !$omp do do j = 1 , Nx Y (:, j ) = y_vector (:) end do !$omp end do !$omp end parallel end subroutine compute_openmp_real_2D_qp end submodule NAFPack_meshgrid_real_2D_compute","tags":"","url":"sourcefile\\nafpack_meshgrid_real_2d_compute.f90.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_radix2.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_fft_compute_radix2.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90 NAFPack_Fourier_Transform_fft_compute_radix2.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_radix2.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft ) NAFPack_Fourier_Transform_fft_compute_radix2 implicit none ( type , external ) contains module function compute_fft_radix2_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % use_vectorized ) then result = compute_vectorized_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % use_do_concurrent ) then result = compute_do_concurrent_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % parallel % use_openmp ) then result = compute_openmp_cmplx_sp ( & signal , plan , stage_params , & loop_method % parallel % num_threads ) end if end function compute_fft_radix2_cmplx_sp pure function compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ) :: even , odd , twiddle integer ( isp ) :: j , block_index , base integer ( isp ) :: i0 , i1 do block_index = 0 , stage_params % nb_blocks - 1 base = block_index * stage_params % current_block_size do j = 0 , stage_params % block_size - 1 i0 = base + j + 1 i1 = i0 + stage_params % block_size even = signal ( i0 ) odd = signal ( i1 ) twiddle = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) result ( i0 ) = even + twiddle * odd result ( i1 ) = even - twiddle * odd case ( DIF % id ) result ( i0 ) = even + odd result ( i1 ) = ( even - odd ) * twiddle end select end do end do end function compute_do_classic_cmplx_sp pure function compute_vectorized_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ), dimension ( stage_params % block_size ) :: even , odd , twiddles integer ( sp ), dimension ( stage_params % block_size ) :: idx , i0 , i1 integer ( isp ) :: j , block_index , base result = signal idx = [( j , j = 0 , stage_params % block_size - 1 )] twiddles = plan % twiddles ( stage_params % stage )% twiddles_factor ( idx + 1 ) do block_index = 0 , stage_params % nb_blocks - 1 base = block_index * stage_params % current_block_size i0 = base + idx + 1 i1 = i0 + stage_params % block_size even = result ( i0 ) odd = result ( i1 ) select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) result ( i0 ) = even + twiddles * odd result ( i1 ) = even - twiddles * odd case ( DIF % id ) result ( i0 ) = even + odd result ( i1 ) = ( even - odd ) * twiddles end select end do end function compute_vectorized_cmplx_sp pure function compute_do_concurrent_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ) :: even , odd , twiddle integer ( isp ) :: j , base , block_index integer ( isp ) :: i0 , i1 result = signal do concurrent ( block_index = 0 : stage_params % nb_blocks - 1 , j = 0 : stage_params % block_size - 1 ) base = block_index * stage_params % current_block_size i0 = base + j + 1 i1 = i0 + stage_params % block_size even = result ( i0 ) odd = result ( i1 ) twiddle = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) result ( i0 ) = even + twiddle * odd result ( i1 ) = even - twiddle * odd case ( DIF % id ) result ( i0 ) = even + odd result ( i1 ) = ( even - odd ) * twiddle end select end do end function compute_do_concurrent_cmplx_sp function compute_openmp_cmplx_sp ( & signal , plan , stage_params , threads ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params integer ( isp ), intent ( in ) :: threads complex ( sp ), dimension ( plan % N ) :: result complex ( sp ) :: even , odd , twiddle integer ( isp ) :: j , block_index , base integer ( isp ) :: i0 , i1 result = signal !$omp parallel do default(none) private(block_index, base, j, even, odd, twiddle, i0, i1) & !$omp& shared(result, plan, stage_params) & !$omp& num_threads(threads) do block_index = 0 , stage_params % nb_blocks - 1 base = block_index * stage_params % current_block_size do j = 0 , stage_params % block_size - 1 i0 = base + j + 1 i1 = i0 + stage_params % block_size even = result ( i0 ) odd = result ( i1 ) twiddle = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) result ( i0 ) = even + twiddle * odd result ( i1 ) = even - twiddle * odd case ( DIF % id ) result ( i0 ) = even + odd result ( i1 ) = ( even - odd ) * twiddle end select end do end do !$omp end parallel do end function compute_openmp_cmplx_sp end submodule NAFPack_Fourier_Transform_fft_compute_radix2","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft_compute_radix2.f90.html"},{"title":"NAFPack_Iterative_Params.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_iterative_params.f90~~EfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_types.f90 NAFPack_Iterative_types.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_iterative_types.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90 NAFPack_matrix_decomposition.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90 NAFPack_Preconditioners.f90 sourcefile~nafpack_iterative_params.f90->sourcefile~nafpack_preconditioners.f90 sourcefile~nafpack_iterative_types.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_matricielle.f90 NAFPack_matricielle.f90 sourcefile~nafpack_matrix_decomposition.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matrix_decomposition.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_preconditioners.f90->sourcefile~nafpack_matricielle.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_matricielle.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~nafpack_iterative_params.f90~~AfferentGraph sourcefile~nafpack_iterative_params.f90 NAFPack_Iterative_Params.f90 sourcefile~nafpack_iterative_methods.f90 NAFPack_Iterative_methods.f90 sourcefile~nafpack_iterative_methods.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90 NAFPack_linalg.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_params.f90 sourcefile~nafpack_linalg.f90->sourcefile~nafpack_iterative_methods.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module NAFPack_Iterative_Params use NAFPack_kinds , only : dp use NAFPack_Iterative_types , only : Norm_used , NORM_1 , NORM_2 , NORM_INF use NAFPack_Preconditioners , only : FILL_LEVEL_USED , FILL_LEVEL_NONE , & MethodPreconditioner , & METHOD_PRECOND_JACOBI , METHOD_PRECOND_GS , & METHOD_PRECOND_SOR , METHOD_PRECOND_JOR , & METHOD_PRECOND_ILU , METHOD_PRECOND_ICF , & METHOD_PRECOND_SSOR use NAFPack_matrix_decomposition , only : forward , backward implicit none ( type , external ) private public :: IterativeParams public :: ApplyPreconditioner type :: IterativeParams ! Solution and initial guess real ( dp ), dimension (:), allocatable :: x_init ! Preconditioner matrices real ( dp ), dimension (:, :), allocatable :: L , U , D ! Algorithm vectors real ( dp ), dimension (:), allocatable :: p real ( dp ), dimension (:), allocatable :: residual ! Norms and tolerances real ( dp ) :: norm_residual real ( dp ) :: norm_initial_residual = 1.d0 real ( dp ) :: tol = 1.0d-12 ! Iteration control integer :: k = 0 integer :: max_iter = 1000 ! Method parameters real ( dp ) :: omega = 1.d0 real ( dp ) :: alpha = 1.d0 real ( dp ) :: beta = 1.d0 ! ILU/IC fill level type ( FILL_LEVEL_USED ) :: fill_level = FILL_LEVEL_NONE ! Flags logical :: is_stationary = . true . logical :: strict_mode = . false . ! Miscellaneous real ( dp ) :: old_dot_product = 0.d0 type ( Norm_used ) :: norm = NORM_2 ! Preconditioner procedure pointer procedure ( ApplyPreconditioner ), pass ( params ), pointer :: precond contains procedure :: norm_function end type IterativeParams contains function ApplyPreconditioner ( params , method , x ) result ( y ) class ( IterativeParams ), intent ( in ) :: params class ( MethodPreconditioner ), intent ( in ) :: method real ( dp ), dimension (:), intent ( in ) :: x real ( dp ), dimension ( size ( params % x_init )) :: y select case ( method % id ) case ( METHOD_PRECOND_JACOBI % id ) if (. not . allocated ( params % D )) stop \"ERROR :: Jacobi preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) case ( METHOD_PRECOND_GS % id ) if (. not . allocated ( params % L )) stop \"ERROR :: Gauss-Seidel preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) case ( METHOD_PRECOND_SOR % id ) if (. not . allocated ( params % L )) stop \"ERROR :: SOR preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) case ( METHOD_PRECOND_JOR % id ) if (. not . allocated ( params % D )) stop \"ERROR :: JOR preconditioner requires & &preconditioner matrix D to be allocated\" y = matmul ( params % D , x ) case ( METHOD_PRECOND_ILU % id ) if (. not . allocated ( params % L ) . or . & . not . allocated ( params % U )) stop \"ERROR :: ILU preconditioner requires & &preconditioner matrices L and U to be allocated\" y = forward ( params % L , x ) y = backward ( params % U , y ) case ( METHOD_PRECOND_ICF % id ) if (. not . allocated ( params % L )) stop \"ERROR :: ICF preconditioner requires & &preconditioner matrix L to be allocated\" y = forward ( params % L , x ) y = backward ( transpose ( params % L ), y ) case ( METHOD_PRECOND_SSOR % id ) if (. not . allocated ( params % L ) . or . & . not . allocated ( params % D )) stop \"ERROR :: SSOR preconditioner requires & &preconditioner matrices L and D to be allocated\" y = forward ( params % L , x ) y = matmul ( params % D , y ) y = backward ( transpose ( params % L ), y ) case DEFAULT stop \"ERROR :: Unknown preconditioner method\" end select end function ApplyPreconditioner function norm_function ( this , vector ) result ( result ) class ( IterativeParams ), intent ( in ) :: this real ( dp ), dimension (:), intent ( in ) :: vector real ( dp ) :: result select case ( this % norm % id ) case ( NORM_1 % id ) result = sum ( abs ( vector )) case ( NORM_2 % id ) result = norm2 ( vector ) case ( NORM_INF % id ) result = maxval ( abs ( vector )) case DEFAULT stop \"ERROR :: Unknown norm type\" end select end function norm_function end module NAFPack_Iterative_Params","tags":"","url":"sourcefile\\nafpack_iterative_params.f90.html"},{"title":"NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 – NAFPack","text":"This file depends on sourcefile~~nafpack_fourier_transform_fft_compute_mixed_radix.f90~~EfferentGraph sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90 NAFPack_Fourier_Transform_fft_compute_mixed_radix.f90 sourcefile~nafpack_fourier_transform_fft.f90 NAFPack_Fourier_Transform_fft.f90 sourcefile~nafpack_fourier_transform_fft_compute_mixed_radix.f90->sourcefile~nafpack_fourier_transform_fft.f90 sourcefile~nafpack_fourier_transform.f90 NAFPack_Fourier_Transform.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_fourier_transform.f90 sourcefile~nafpack_memory_management.f90 NAFPack_memory_management.f90 sourcefile~nafpack_fourier_transform_fft.f90->sourcefile~nafpack_memory_management.f90 sourcefile~nafpack_constant.f90 NAFPack_constant.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_constant.f90 sourcefile~nafpack_kinds.f90 NAFPack_kinds.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_loop_method.f90 NAFPack_loop_method.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_loop_method.f90 sourcefile~nafpack_math_utils.f90 NAFPack_math_utils.f90 sourcefile~nafpack_fourier_transform.f90->sourcefile~nafpack_math_utils.f90 sourcefile~nafpack_memory_management.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_constant.f90->sourcefile~nafpack_kinds.f90 sourcefile~nafpack_math_utils.f90->sourcefile~nafpack_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( NAFPack_Fourier_Transform : NAFPack_Fourier_Transform_fft ) NAFPack_Fourier_Transform_fft_compute_mixed_radix implicit none ( type , external ) contains module function compute_fft_mixed_radix_cmplx_sp ( & signal , plan , stage_params , loop_method ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params type ( LoopMethod ), intent ( in ) :: loop_method complex ( sp ), dimension ( plan % N ) :: result if ( loop_method % use_do_classic ) then result = compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % use_vectorized ) then result = compute_vectorized_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % use_do_concurrent ) then result = compute_do_concurrent_cmplx_sp ( & signal , plan , stage_params ) else if ( loop_method % parallel % use_openmp ) then result = compute_openmp_cmplx_sp ( & signal , plan , stage_params , & loop_method % parallel % num_threads ) end if end function compute_fft_mixed_radix_cmplx_sp pure function compute_do_classic_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ), dimension ( plan % twiddles ( stage_params % stage )% radix ) :: result_temp integer ( isp ) :: block_index , base , j , r , radix complex ( sp ) :: wj result = signal radix = plan % twiddles ( stage_params % stage )% radix do block_index = 0 , stage_params % nb_blocks - 1 base = block_index * stage_params % current_block_size do j = 0 , stage_params % block_size - 1 select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) * wj ** r end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do case ( DIF % id ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) ! * apply twiddle factors after the small DFT (exept for r=0) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 1 , radix - 1 result_temp ( r + 1 ) = result_temp ( r + 1 ) * wj ** r end do do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do end select end do end do end function compute_do_classic_cmplx_sp pure function compute_vectorized_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ), dimension ( plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ) :: result_temp complex ( sp ), dimension ( plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ) :: fourier_matrix complex ( sp ), dimension ( stage_params % block_size ) :: twiddles integer ( isp ), dimension ( plan % twiddles ( stage_params % stage )% radix * stage_params % block_size ) :: indices integer ( isp ), dimension ( plan % twiddles ( stage_params % stage )% radix ) :: r_idx integer ( isp ), dimension ( stage_params % block_size ) :: idx integer ( isp ) :: j , block_index , base result = signal idx = [( j , j = 0 , stage_params % block_size - 1 )] r_idx = [( j , j = 0 , plan % twiddles ( stage_params % stage )% radix - 1 )] indices = reshape ( spread ( idx , dim = 1 , ncopies = plan % twiddles ( stage_params % stage )% radix ) + & spread ( r_idx * stage_params % block_size , dim = 2 , ncopies = stage_params % block_size ), & [ plan % twiddles ( stage_params % stage )% radix * stage_params % block_size ]) twiddles = plan % twiddles ( stage_params % stage )% twiddles_factor ( idx + 1 ) fourier_matrix = spread ( twiddles , 1 , plan % twiddles ( stage_params % stage )% radix ) ** spread ( r_idx , 2 , stage_params % block_size ) do block_index = 0 , stage_params % nb_blocks - 1 select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) base = block_index * stage_params % current_block_size result_temp = reshape ( result ( base + indices + 1 ), [ plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ]) result_temp = fourier_matrix * result_temp result_temp = small_dft_kernel_sp ( result_temp , plan , stage_params % stage , plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ) result ( base + indices + 1 ) = reshape ( result_temp , [ plan % twiddles ( stage_params % stage )% radix * stage_params % block_size ]) case ( DIF % id ) base = block_index * stage_params % current_block_size result_temp = reshape ( result ( base + indices + 1 ), [ plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ]) result_temp = small_dft_kernel_sp ( result_temp , plan , stage_params % stage , plan % twiddles ( stage_params % stage )% radix , stage_params % block_size ) ! * apply twiddle factors after the small DFT (exept for r=0) fourier_matrix ( 1 , :) = 1.0_sp result_temp = fourier_matrix * result_temp result ( base + indices + 1 ) = reshape ( result_temp , [ plan % twiddles ( stage_params % stage )% radix * stage_params % block_size ]) end select end do end function compute_vectorized_cmplx_sp pure function compute_do_concurrent_cmplx_sp ( & signal , plan , stage_params ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params complex ( sp ), dimension ( plan % N ) :: result complex ( sp ), dimension ( plan % twiddles ( stage_params % stage )% radix ) :: result_temp integer ( isp ) :: block_index , base , j , r , radix complex ( sp ) :: wj result = signal radix = plan % twiddles ( stage_params % stage )% radix do concurrent ( block_index = 0 : stage_params % nb_blocks - 1 , j = 0 : stage_params % block_size - 1 ) base = block_index * stage_params % current_block_size select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) * wj ** r end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do case ( DIF % id ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) ! * apply twiddle factors after the small DFT (exept for r=0) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 1 , radix - 1 result_temp ( r + 1 ) = result_temp ( r + 1 ) * wj ** r end do do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do end select end do end function compute_do_concurrent_cmplx_sp function compute_openmp_cmplx_sp ( & signal , plan , stage_params , threads ) result ( result ) complex ( sp ), dimension (:), intent ( in ) :: signal type ( FFTPlan ), intent ( in ) :: plan type ( FFTStageParams ), intent ( in ) :: stage_params integer ( isp ), intent ( in ) :: threads complex ( sp ), dimension ( plan % N ) :: result complex ( sp ), dimension ( plan % twiddles ( stage_params % stage )% radix ) :: result_temp integer ( isp ) :: block_index , base , j , r , radix complex ( sp ) :: wj result = signal radix = plan % twiddles ( stage_params % stage )% radix !$omp parallel do default(none) private(block_index, base, j, r, wj, result_temp) & !$omp& shared(result, plan, stage_params, radix) & !$omp& num_threads(threads) do block_index = 0 , stage_params % nb_blocks - 1 base = block_index * stage_params % current_block_size do j = 0 , stage_params % block_size - 1 select case ( plan % algorithm % decimation_method % id ) case ( DIT % id ) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) * wj ** r end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do case ( DIF % id ) do r = 0 , radix - 1 result_temp ( r + 1 ) = result ( base + j + r * stage_params % block_size + 1 ) end do result_temp = reshape ( small_dft_kernel_sp ( reshape ( result_temp , [ radix , 1 ]), plan , stage_params % stage , radix , 1 ), [ radix ]) ! * apply twiddle factors after the small DFT (exept for r=0) wj = plan % twiddles ( stage_params % stage )% twiddles_factor ( j + 1 ) do r = 1 , radix - 1 result_temp ( r + 1 ) = result_temp ( r + 1 ) * wj ** r end do do r = 0 , radix - 1 result ( base + j + r * stage_params % block_size + 1 ) = result_temp ( r + 1 ) end do end select end do end do !$omp end parallel do end function compute_openmp_cmplx_sp pure function small_dft_kernel_sp ( x , plan , stage , radix , block_size ) result ( y ) complex ( sp ), dimension (:, :), intent ( in ) :: x type ( FFTPlan ), intent ( in ) :: plan integer ( isp ), intent ( in ) :: stage , radix , block_size complex ( sp ), dimension ( radix , block_size ) :: y complex ( sp ), dimension (:, :), allocatable :: w_kn real ( sp ), dimension (:, :), allocatable :: kvec , nvec complex ( sp ) :: W3 , W4 , W5 integer ( isp ) :: k , n W3 = exp ( - 2.0_sp * pi_sp * im_sp / 3.0_sp ) W4 = im_sp W5 = exp ( - 2.0_sp * pi_sp * im_sp / 5.0_sp ) select case ( plan % twiddles ( stage )% radix ) case ( 2 ) y ( 1 , :) = x ( 1 , :) + x ( 2 , :) y ( 2 , :) = x ( 1 , :) - x ( 2 , :) case ( 3 ) y ( 1 , :) = x ( 1 , :) + x ( 2 , :) + x ( 3 , :) y ( 2 , :) = x ( 1 , :) + W3 * x ( 2 , :) + W3 ** 2 * x ( 3 , :) y ( 3 , :) = x ( 1 , :) + W3 ** 2 * x ( 2 , :) + W3 * x ( 3 , :) case ( 4 ) y ( 1 , :) = x ( 1 , :) + x ( 2 , :) + x ( 3 , :) + x ( 4 , :) y ( 2 , :) = x ( 1 , :) - W4 * x ( 2 , :) - x ( 3 , :) + W4 * x ( 4 , :) y ( 3 , :) = x ( 1 , :) - x ( 2 , :) + x ( 3 , :) - x ( 4 , :) y ( 4 , :) = x ( 1 , :) + W4 * x ( 2 , :) - x ( 3 , :) - W4 * x ( 4 , :) case ( 5 ) y ( 1 , :) = x ( 1 , :) + x ( 2 , :) + x ( 3 , :) + x ( 4 , :) + x ( 5 , :) y ( 2 , :) = x ( 1 , :) + W5 * x ( 2 , :) + W5 ** 2 * x ( 3 , :) + W5 ** 3 * x ( 4 , :) + W5 ** 4 * x ( 5 , :) y ( 3 , :) = x ( 1 , :) + W5 ** 2 * x ( 2 , :) + W5 ** 4 * x ( 3 , :) + W5 * x ( 4 , :) + W5 ** 3 * x ( 5 , :) y ( 4 , :) = x ( 1 , :) + W5 ** 3 * x ( 2 , :) + W5 * x ( 3 , :) + W5 ** 4 * x ( 4 , :) + W5 ** 2 * x ( 5 , :) y ( 5 , :) = x ( 1 , :) + W5 ** 4 * x ( 2 , :) + W5 ** 3 * x ( 3 , :) + W5 ** 2 * x ( 4 , :) + W5 * x ( 5 , :) case default allocate ( w_kn ( radix , radix ), kvec ( radix , radix ), nvec ( radix , radix )) kvec = spread ([( k - 1 , k = 1 , radix )], dim = 1 , ncopies = radix ) nvec = spread ([( n - 1 , n = 1 , radix )], dim = 2 , ncopies = radix ) w_kn = exp ( - 2.0_sp * pi_sp * im_sp * kvec * nvec / real ( radix , sp )) y = matmul ( w_kn , x ) end select end function small_dft_kernel_sp end submodule NAFPack_Fourier_Transform_fft_compute_mixed_radix","tags":"","url":"sourcefile\\nafpack_fourier_transform_fft_compute_mixed_radix.f90.html"}]}