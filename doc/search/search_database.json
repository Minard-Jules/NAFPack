var tipuesearch = {"pages":[{"title":" NAFPack ","text":"NAFPack exclude; ./src\\FFT\\FFTW3.f90\noutput_dir: ./fpm-doc\nsource: true\nproc_internals: true\nmd_extensions: markdown.extensions.toc\ngraph: false\ncoloured_edges: false\ndbg: true [TOC] Warning This documentation is a work in progress NAFPack Numerical Analysis in Fortran Package A modern, modular, and open-source Fortran package for numerical analysis, designed to provide robust and efficient tools for scientific computing. Author Minard-Jules About This Documentation This documentation provides an overview of the NAFPack project, including installation instructions, usage examples, and API references. Please note that this documentation is a work in progress and may be updated frequently. Developer Info https://github.com/Minard-Jules","tags":"home","url":"index.html"},{"title":"fftw_iodim – NAFPack ","text":"type, public, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","url":"type\\fftw_iodim.html"},{"title":"fftw_iodim64 – NAFPack ","text":"type, public, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","url":"type\\fftw_iodim64.html"},{"title":"fftwf_iodim – NAFPack ","text":"type, public, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","url":"type\\fftwf_iodim.html"},{"title":"fftwf_iodim64 – NAFPack ","text":"type, public, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","url":"type\\fftwf_iodim64.html"},{"title":"dot – NAFPack","text":"public  function dot(a, b) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp)","tags":"","url":"proc\\dot.html"},{"title":"cross – NAFPack","text":"public  function cross(a, b) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3)","tags":"","url":"proc\\cross.html"},{"title":"norm_2 – NAFPack","text":"public  function norm_2(a) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp)","tags":"","url":"proc\\norm_2.html"},{"title":"norm_2_complex – NAFPack","text":"public  function norm_2_complex(a) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp)","tags":"","url":"proc\\norm_2_complex.html"},{"title":"normalise – NAFPack","text":"public  function normalise(a) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a))","tags":"","url":"proc\\normalise.html"},{"title":"normalise_complexe – NAFPack","text":"public  function normalise_complexe(a) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a))","tags":"","url":"proc\\normalise_complexe.html"},{"title":"Diagonally_Dominant_Matrix – NAFPack","text":"public  function Diagonally_Dominant_Matrix(A) result(diagonally_dominant) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical","tags":"","url":"proc\\diagonally_dominant_matrix.html"},{"title":"Identity_n – NAFPack","text":"public  function Identity_n(N, use_concurrent) result(Identity) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N)","tags":"","url":"proc\\identity_n.html"},{"title":"LU_decomposition – NAFPack","text":"public  subroutine LU_decomposition(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U","tags":"","url":"proc\\lu_decomposition.html"},{"title":"LDU_decomposition – NAFPack","text":"public  subroutine LDU_decomposition(A, L, D, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U","tags":"","url":"proc\\ldu_decomposition.html"},{"title":"Cholesky_decomposition – NAFPack","text":"public  subroutine Cholesky_decomposition(A, L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L","tags":"","url":"proc\\cholesky_decomposition.html"},{"title":"QR_decomposition – NAFPack","text":"public  subroutine QR_decomposition(A, method, Q, R) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R","tags":"","url":"proc\\qr_decomposition.html"},{"title":"fftw_plan_dft – NAFPack","text":"interface public  function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft.html"},{"title":"fftw_plan_dft_1d – NAFPack","text":"interface public  function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_1d.html"},{"title":"fftw_plan_dft_2d – NAFPack","text":"interface public  function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_2d.html"},{"title":"fftw_plan_dft_3d – NAFPack","text":"interface public  function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_3d.html"},{"title":"fftw_plan_many_dft – NAFPack","text":"interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_many_dft.html"},{"title":"fftw_plan_guru_dft – NAFPack","text":"interface public  function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_dft.html"},{"title":"fftw_plan_guru_split_dft – NAFPack","text":"interface public  function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_split_dft.html"},{"title":"fftw_plan_guru64_dft – NAFPack","text":"interface public  function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_dft.html"},{"title":"fftw_plan_guru64_split_dft – NAFPack","text":"interface public  function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_split_dft.html"},{"title":"fftw_plan_many_dft_r2c – NAFPack","text":"interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_many_dft_r2c.html"},{"title":"fftw_plan_dft_r2c – NAFPack","text":"interface public  function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_r2c.html"},{"title":"fftw_plan_dft_r2c_1d – NAFPack","text":"interface public  function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_r2c_1d.html"},{"title":"fftw_plan_dft_r2c_2d – NAFPack","text":"interface public  function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_r2c_2d.html"},{"title":"fftw_plan_dft_r2c_3d – NAFPack","text":"interface public  function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_r2c_3d.html"},{"title":"fftw_plan_many_dft_c2r – NAFPack","text":"interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_many_dft_c2r.html"},{"title":"fftw_plan_dft_c2r – NAFPack","text":"interface public  function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_c2r.html"},{"title":"fftw_plan_dft_c2r_1d – NAFPack","text":"interface public  function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_c2r_1d.html"},{"title":"fftw_plan_dft_c2r_2d – NAFPack","text":"interface public  function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_c2r_2d.html"},{"title":"fftw_plan_dft_c2r_3d – NAFPack","text":"interface public  function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_dft_c2r_3d.html"},{"title":"fftw_plan_guru_dft_r2c – NAFPack","text":"interface public  function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_dft_r2c.html"},{"title":"fftw_plan_guru_dft_c2r – NAFPack","text":"interface public  function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_dft_c2r.html"},{"title":"fftw_plan_guru_split_dft_r2c – NAFPack","text":"interface public  function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_split_dft_r2c.html"},{"title":"fftw_plan_guru_split_dft_c2r – NAFPack","text":"interface public  function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_split_dft_c2r.html"},{"title":"fftw_plan_guru64_dft_r2c – NAFPack","text":"interface public  function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_dft_r2c.html"},{"title":"fftw_plan_guru64_dft_c2r – NAFPack","text":"interface public  function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_dft_c2r.html"},{"title":"fftw_plan_guru64_split_dft_r2c – NAFPack","text":"interface public  function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_split_dft_r2c.html"},{"title":"fftw_plan_guru64_split_dft_c2r – NAFPack","text":"interface public  function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_split_dft_c2r.html"},{"title":"fftw_plan_many_r2r – NAFPack","text":"interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_many_r2r.html"},{"title":"fftw_plan_r2r – NAFPack","text":"interface public  function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_r2r.html"},{"title":"fftw_plan_r2r_1d – NAFPack","text":"interface public  function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_r2r_1d.html"},{"title":"fftw_plan_r2r_2d – NAFPack","text":"interface public  function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_r2r_2d.html"},{"title":"fftw_plan_r2r_3d – NAFPack","text":"interface public  function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_r2r_3d.html"},{"title":"fftw_plan_guru_r2r – NAFPack","text":"interface public  function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru_r2r.html"},{"title":"fftw_plan_guru64_r2r – NAFPack","text":"interface public  function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftw_plan_guru64_r2r.html"},{"title":"fftw_planner_nthreads – NAFPack","text":"interface public  function fftw_planner_nthreads() bind(C, name='fftw_planner_nthreads') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_planner_nthreads.html"},{"title":"fftw_init_threads – NAFPack","text":"interface public  function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_init_threads.html"},{"title":"fftw_export_wisdom_to_filename – NAFPack","text":"interface public  function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_export_wisdom_to_filename.html"},{"title":"fftw_export_wisdom_to_string – NAFPack","text":"interface public  function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(c_ptr)","tags":"","url":"interface\\fftw_export_wisdom_to_string.html"},{"title":"fftw_import_system_wisdom – NAFPack","text":"interface public  function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_import_system_wisdom.html"},{"title":"fftw_import_wisdom_from_filename – NAFPack","text":"interface public  function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_import_wisdom_from_filename.html"},{"title":"fftw_import_wisdom_from_file – NAFPack","text":"interface public  function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_import_wisdom_from_file.html"},{"title":"fftw_import_wisdom_from_string – NAFPack","text":"interface public  function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_import_wisdom_from_string.html"},{"title":"fftw_import_wisdom – NAFPack","text":"interface public  function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_import_wisdom.html"},{"title":"fftw_sprint_plan – NAFPack","text":"interface public  function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr)","tags":"","url":"interface\\fftw_sprint_plan.html"},{"title":"fftw_malloc – NAFPack","text":"interface public  function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftw_malloc.html"},{"title":"fftw_alloc_real – NAFPack","text":"interface public  function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftw_alloc_real.html"},{"title":"fftw_alloc_complex – NAFPack","text":"interface public  function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftw_alloc_complex.html"},{"title":"fftw_estimate_cost – NAFPack","text":"interface public  function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","url":"interface\\fftw_estimate_cost.html"},{"title":"fftw_cost – NAFPack","text":"interface public  function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","url":"interface\\fftw_cost.html"},{"title":"fftw_alignment_of – NAFPack","text":"interface public  function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=c_int)","tags":"","url":"interface\\fftw_alignment_of.html"},{"title":"fftw_execute_dft – NAFPack","text":"interface public  subroutine fftw_execute_dft(p, in, out) bind(C, name='fftw_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftw_execute_dft.html"},{"title":"fftw_execute_split_dft – NAFPack","text":"interface public  subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftw_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","url":"interface\\fftw_execute_split_dft.html"},{"title":"fftw_execute_dft_r2c – NAFPack","text":"interface public  subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name='fftw_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftw_execute_dft_r2c.html"},{"title":"fftw_execute_dft_c2r – NAFPack","text":"interface public  subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name='fftw_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftw_execute_dft_c2r.html"},{"title":"fftw_execute_split_dft_r2c – NAFPack","text":"interface public  subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftw_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","url":"interface\\fftw_execute_split_dft_r2c.html"},{"title":"fftw_execute_split_dft_c2r – NAFPack","text":"interface public  subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftw_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftw_execute_split_dft_c2r.html"},{"title":"fftw_execute_r2r – NAFPack","text":"interface public  subroutine fftw_execute_r2r(p, in, out) bind(C, name='fftw_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftw_execute_r2r.html"},{"title":"fftw_destroy_plan – NAFPack","text":"interface public  subroutine fftw_destroy_plan(p) bind(C, name='fftw_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftw_destroy_plan.html"},{"title":"fftw_forget_wisdom – NAFPack","text":"interface public  subroutine fftw_forget_wisdom() bind(C, name='fftw_forget_wisdom') Arguments None","tags":"","url":"interface\\fftw_forget_wisdom.html"},{"title":"fftw_cleanup – NAFPack","text":"interface public  subroutine fftw_cleanup() bind(C, name='fftw_cleanup') Arguments None","tags":"","url":"interface\\fftw_cleanup.html"},{"title":"fftw_set_timelimit – NAFPack","text":"interface public  subroutine fftw_set_timelimit(t) bind(C, name='fftw_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","url":"interface\\fftw_set_timelimit.html"},{"title":"fftw_plan_with_nthreads – NAFPack","text":"interface public  subroutine fftw_plan_with_nthreads(nthreads) bind(C, name='fftw_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","url":"interface\\fftw_plan_with_nthreads.html"},{"title":"fftw_cleanup_threads – NAFPack","text":"interface public  subroutine fftw_cleanup_threads() bind(C, name='fftw_cleanup_threads') Arguments None","tags":"","url":"interface\\fftw_cleanup_threads.html"},{"title":"fftw_make_planner_thread_safe – NAFPack","text":"interface public  subroutine fftw_make_planner_thread_safe() bind(C, name='fftw_make_planner_thread_safe') Arguments None","tags":"","url":"interface\\fftw_make_planner_thread_safe.html"},{"title":"fftw_export_wisdom_to_file – NAFPack","text":"interface public  subroutine fftw_export_wisdom_to_file(output_file) bind(C, name='fftw_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","url":"interface\\fftw_export_wisdom_to_file.html"},{"title":"fftw_export_wisdom – NAFPack","text":"interface public  subroutine fftw_export_wisdom(write_char, data) bind(C, name='fftw_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","url":"interface\\fftw_export_wisdom.html"},{"title":"fftw_fprint_plan – NAFPack","text":"interface public  subroutine fftw_fprint_plan(p, output_file) bind(C, name='fftw_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","url":"interface\\fftw_fprint_plan.html"},{"title":"fftw_print_plan – NAFPack","text":"interface public  subroutine fftw_print_plan(p) bind(C, name='fftw_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftw_print_plan.html"},{"title":"fftw_free – NAFPack","text":"interface public  subroutine fftw_free(p) bind(C, name='fftw_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftw_free.html"},{"title":"fftw_flops – NAFPack","text":"interface public  subroutine fftw_flops(p, add, mul, fmas) bind(C, name='fftw_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","url":"interface\\fftw_flops.html"},{"title":"fftwf_plan_dft – NAFPack","text":"interface public  function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft.html"},{"title":"fftwf_plan_dft_1d – NAFPack","text":"interface public  function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_1d.html"},{"title":"fftwf_plan_dft_2d – NAFPack","text":"interface public  function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_2d.html"},{"title":"fftwf_plan_dft_3d – NAFPack","text":"interface public  function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_3d.html"},{"title":"fftwf_plan_many_dft – NAFPack","text":"interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_many_dft.html"},{"title":"fftwf_plan_guru_dft – NAFPack","text":"interface public  function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_dft.html"},{"title":"fftwf_plan_guru_split_dft – NAFPack","text":"interface public  function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_split_dft.html"},{"title":"fftwf_plan_guru64_dft – NAFPack","text":"interface public  function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_dft.html"},{"title":"fftwf_plan_guru64_split_dft – NAFPack","text":"interface public  function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_split_dft.html"},{"title":"fftwf_plan_many_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_many_dft_r2c.html"},{"title":"fftwf_plan_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_r2c.html"},{"title":"fftwf_plan_dft_r2c_1d – NAFPack","text":"interface public  function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_r2c_1d.html"},{"title":"fftwf_plan_dft_r2c_2d – NAFPack","text":"interface public  function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_r2c_2d.html"},{"title":"fftwf_plan_dft_r2c_3d – NAFPack","text":"interface public  function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_r2c_3d.html"},{"title":"fftwf_plan_many_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_many_dft_c2r.html"},{"title":"fftwf_plan_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_c2r.html"},{"title":"fftwf_plan_dft_c2r_1d – NAFPack","text":"interface public  function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_c2r_1d.html"},{"title":"fftwf_plan_dft_c2r_2d – NAFPack","text":"interface public  function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_c2r_2d.html"},{"title":"fftwf_plan_dft_c2r_3d – NAFPack","text":"interface public  function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_dft_c2r_3d.html"},{"title":"fftwf_plan_guru_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_dft_r2c.html"},{"title":"fftwf_plan_guru_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_dft_c2r.html"},{"title":"fftwf_plan_guru_split_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_split_dft_r2c.html"},{"title":"fftwf_plan_guru_split_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_split_dft_c2r.html"},{"title":"fftwf_plan_guru64_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_dft_r2c.html"},{"title":"fftwf_plan_guru64_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_dft_c2r.html"},{"title":"fftwf_plan_guru64_split_dft_r2c – NAFPack","text":"interface public  function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_split_dft_r2c.html"},{"title":"fftwf_plan_guru64_split_dft_c2r – NAFPack","text":"interface public  function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_split_dft_c2r.html"},{"title":"fftwf_plan_many_r2r – NAFPack","text":"interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_many_r2r.html"},{"title":"fftwf_plan_r2r – NAFPack","text":"interface public  function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_r2r.html"},{"title":"fftwf_plan_r2r_1d – NAFPack","text":"interface public  function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_r2r_1d.html"},{"title":"fftwf_plan_r2r_2d – NAFPack","text":"interface public  function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_r2r_2d.html"},{"title":"fftwf_plan_r2r_3d – NAFPack","text":"interface public  function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_r2r_3d.html"},{"title":"fftwf_plan_guru_r2r – NAFPack","text":"interface public  function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru_r2r.html"},{"title":"fftwf_plan_guru64_r2r – NAFPack","text":"interface public  function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_plan_guru64_r2r.html"},{"title":"fftwf_planner_nthreads – NAFPack","text":"interface public  function fftwf_planner_nthreads() bind(C, name='fftwf_planner_nthreads') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_planner_nthreads.html"},{"title":"fftwf_init_threads – NAFPack","text":"interface public  function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_init_threads.html"},{"title":"fftwf_export_wisdom_to_filename – NAFPack","text":"interface public  function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_export_wisdom_to_filename.html"},{"title":"fftwf_export_wisdom_to_string – NAFPack","text":"interface public  function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_export_wisdom_to_string.html"},{"title":"fftwf_import_system_wisdom – NAFPack","text":"interface public  function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_import_system_wisdom.html"},{"title":"fftwf_import_wisdom_from_filename – NAFPack","text":"interface public  function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_import_wisdom_from_filename.html"},{"title":"fftwf_import_wisdom_from_file – NAFPack","text":"interface public  function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_import_wisdom_from_file.html"},{"title":"fftwf_import_wisdom_from_string – NAFPack","text":"interface public  function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_import_wisdom_from_string.html"},{"title":"fftwf_import_wisdom – NAFPack","text":"interface public  function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_import_wisdom.html"},{"title":"fftwf_sprint_plan – NAFPack","text":"interface public  function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_sprint_plan.html"},{"title":"fftwf_malloc – NAFPack","text":"interface public  function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_malloc.html"},{"title":"fftwf_alloc_real – NAFPack","text":"interface public  function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_alloc_real.html"},{"title":"fftwf_alloc_complex – NAFPack","text":"interface public  function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","url":"interface\\fftwf_alloc_complex.html"},{"title":"fftwf_estimate_cost – NAFPack","text":"interface public  function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","url":"interface\\fftwf_estimate_cost.html"},{"title":"fftwf_cost – NAFPack","text":"interface public  function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","url":"interface\\fftwf_cost.html"},{"title":"fftwf_alignment_of – NAFPack","text":"interface public  function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=c_int)","tags":"","url":"interface\\fftwf_alignment_of.html"},{"title":"fftwf_execute_dft – NAFPack","text":"interface public  subroutine fftwf_execute_dft(p, in, out) bind(C, name='fftwf_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftwf_execute_dft.html"},{"title":"fftwf_execute_split_dft – NAFPack","text":"interface public  subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftwf_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","url":"interface\\fftwf_execute_split_dft.html"},{"title":"fftwf_execute_dft_r2c – NAFPack","text":"interface public  subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name='fftwf_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftwf_execute_dft_r2c.html"},{"title":"fftwf_execute_dft_c2r – NAFPack","text":"interface public  subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name='fftwf_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftwf_execute_dft_c2r.html"},{"title":"fftwf_execute_split_dft_r2c – NAFPack","text":"interface public  subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftwf_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","url":"interface\\fftwf_execute_split_dft_r2c.html"},{"title":"fftwf_execute_split_dft_c2r – NAFPack","text":"interface public  subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftwf_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftwf_execute_split_dft_c2r.html"},{"title":"fftwf_execute_r2r – NAFPack","text":"interface public  subroutine fftwf_execute_r2r(p, in, out) bind(C, name='fftwf_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","url":"interface\\fftwf_execute_r2r.html"},{"title":"fftwf_destroy_plan – NAFPack","text":"interface public  subroutine fftwf_destroy_plan(p) bind(C, name='fftwf_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftwf_destroy_plan.html"},{"title":"fftwf_forget_wisdom – NAFPack","text":"interface public  subroutine fftwf_forget_wisdom() bind(C, name='fftwf_forget_wisdom') Arguments None","tags":"","url":"interface\\fftwf_forget_wisdom.html"},{"title":"fftwf_cleanup – NAFPack","text":"interface public  subroutine fftwf_cleanup() bind(C, name='fftwf_cleanup') Arguments None","tags":"","url":"interface\\fftwf_cleanup.html"},{"title":"fftwf_set_timelimit – NAFPack","text":"interface public  subroutine fftwf_set_timelimit(t) bind(C, name='fftwf_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","url":"interface\\fftwf_set_timelimit.html"},{"title":"fftwf_plan_with_nthreads – NAFPack","text":"interface public  subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name='fftwf_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","url":"interface\\fftwf_plan_with_nthreads.html"},{"title":"fftwf_cleanup_threads – NAFPack","text":"interface public  subroutine fftwf_cleanup_threads() bind(C, name='fftwf_cleanup_threads') Arguments None","tags":"","url":"interface\\fftwf_cleanup_threads.html"},{"title":"fftwf_make_planner_thread_safe – NAFPack","text":"interface public  subroutine fftwf_make_planner_thread_safe() bind(C, name='fftwf_make_planner_thread_safe') Arguments None","tags":"","url":"interface\\fftwf_make_planner_thread_safe.html"},{"title":"fftwf_export_wisdom_to_file – NAFPack","text":"interface public  subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name='fftwf_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","url":"interface\\fftwf_export_wisdom_to_file.html"},{"title":"fftwf_export_wisdom – NAFPack","text":"interface public  subroutine fftwf_export_wisdom(write_char, data) bind(C, name='fftwf_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","url":"interface\\fftwf_export_wisdom.html"},{"title":"fftwf_fprint_plan – NAFPack","text":"interface public  subroutine fftwf_fprint_plan(p, output_file) bind(C, name='fftwf_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","url":"interface\\fftwf_fprint_plan.html"},{"title":"fftwf_print_plan – NAFPack","text":"interface public  subroutine fftwf_print_plan(p) bind(C, name='fftwf_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftwf_print_plan.html"},{"title":"fftwf_free – NAFPack","text":"interface public  subroutine fftwf_free(p) bind(C, name='fftwf_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","url":"interface\\fftwf_free.html"},{"title":"fftwf_flops – NAFPack","text":"interface public  subroutine fftwf_flops(p, add, mul, fmas) bind(C, name='fftwf_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","url":"interface\\fftwf_flops.html"},{"title":"FFT_1D – NAFPack","text":"public  function FFT_1D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal))","tags":"","url":"proc\\fft_1d.html"},{"title":"IFFT_1D – NAFPack","text":"public  function IFFT_1D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal))","tags":"","url":"proc\\ifft_1d.html"},{"title":"FFT_2D – NAFPack","text":"public  function FFT_2D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2))","tags":"","url":"proc\\fft_2d.html"},{"title":"IFFT_2D – NAFPack","text":"public  function IFFT_2D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2))","tags":"","url":"proc\\ifft_2d.html"},{"title":"FFT_3D – NAFPack","text":"public  function FFT_3D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3))","tags":"","url":"proc\\fft_3d.html"},{"title":"IFFT_3D – NAFPack","text":"public  function IFFT_3D(signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3))","tags":"","url":"proc\\ifft_3d.html"},{"title":"meshgrid – NAFPack","text":"public  subroutine meshgrid(varx, vary, X, Y) returns a meshgrid from two vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: varx vector representing the coordinates of a grid. real(kind=dp), intent(in), DIMENSION(:) :: vary vector representing the coordinates of a grid. real(kind=dp), intent(out), DIMENSION(SIZE(vary), SIZE(varx)) :: X output grid coordinates, X is a matrix where each row is varx real(kind=dp), intent(out), DIMENSION(SIZE(vary), SIZE(varx)) :: Y output grid coordinates, Y is a matrix where each column is vary","tags":"","url":"proc\\meshgrid.html"},{"title":"Direct_methode – NAFPack","text":"public  function Direct_methode(A, b, method, pivot_method, check) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: pivot_method logical, intent(in), optional :: check Return Value real(kind=dp), DIMENSION(SIZE(A,1))","tags":"","url":"proc\\direct_methode.html"},{"title":"Iterative_methods – NAFPack","text":"public  function Iterative_methods(A, b, method, x_init, max_iter, omega) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method real(kind=dp), intent(in), optional, DIMENSION(:) :: x_init integer, intent(in), optional :: max_iter real(kind=dp), intent(in), optional :: omega Return Value real(kind=dp), DIMENSION(SIZE(A, 1))","tags":"","url":"proc\\iterative_methods.html"},{"title":"Eigen – NAFPack","text":"public  subroutine Eigen(A, lambda, vp, method, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"proc\\eigen.html"},{"title":"NAFPack_matricielle – NAFPack","text":"Uses NAFPack_constant Functions public  function dot (a, b) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp) public  function cross (a, b) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(3) :: a real(kind=dp), DIMENSION(3) :: b Return Value real(kind=dp), DIMENSION(3) public  function norm_2 (a) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp) public  function norm_2_complex (a) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp) public  function normalise (a) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), DIMENSION(:) :: a Return Value real(kind=dp), DIMENSION(SIZE(a)) public  function normalise_complexe (a) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), DIMENSION(:) :: a Return Value complex(kind=dp), DIMENSION(SIZE(a)) public  function Diagonally_Dominant_Matrix (A) result(diagonally_dominant) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A Return Value logical public  function Identity_n (N, use_concurrent) result(Identity) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N logical, intent(in), optional :: use_concurrent Return Value real(kind=dp), DIMENSION(N, N)","tags":"","url":"module\\nafpack_matricielle.html"},{"title":"NAFPack_constant – NAFPack","text":"Module for defining constants used in NAFPack This module includes mathematical constants, colors for terminal output,\nand other parameters that are used throughout the NAFPack library. Uses iso_fortran_env Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = ACOS(-1.d0) complex(kind=dp), public, parameter :: im = (0.d0, 1.d0) real(kind=dp), public, parameter :: epsi = 1.d-12 real(kind=dp), public, parameter :: epsi_test = 1.d-6 integer, public, parameter :: kmax = 10000 character(len=*), public, parameter :: status_len = REPEAT(\" \", 15) character(len=10), public :: red_color = CHAR(27)//\"[31m\" character(len=10), public :: green_color = CHAR(27)//\"[32m\" character(len=10), public :: yellow_color = CHAR(27)//\"[33m\" character(len=10), public :: blue_color = CHAR(27)//\"[34m\" character(len=10), public :: purple_color = CHAR(27)//\"[35m\" character(len=10), public :: cyan_color = CHAR(27)//\"[36m\" character(len=10), public :: white_color = CHAR(27)//\"[37m\" character(len=10), public :: reset_color = CHAR(27)//\"[0m\"","tags":"","url":"module\\nafpack_constant.html"},{"title":"NAFPack_matrix_decomposition – NAFPack","text":"Uses NAFPack_matricielle NAFPack_constant Subroutines public  subroutine LU_decomposition (A, L, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine LDU_decomposition (A, L, D, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: L real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: D real(kind=dp), intent(out), DIMENSION(SIZE(A, 1),SIZE(A, 1)) :: U public  subroutine Cholesky_decomposition (A, L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(out), DIMENSION(SIZE(A, 1), SIZE(A, 1)) :: L public  subroutine QR_decomposition (A, method, Q, R) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A character(len=*), intent(in), optional :: method real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: Q real(kind=dp), intent(out), DIMENSION(SIZE(A, 1) ,SIZE(A, 2)) :: R","tags":"","url":"module\\nafpack_matrix_decomposition.html"},{"title":"FFTW3 – NAFPack","text":"Uses iso_c_binding Variables Type Visibility Attributes Name Initial integer, public, parameter :: C_FFTW_R2R_KIND = C_INT32_T integer(kind=C_INT), public, parameter :: FFTW_R2HC = 0 integer(kind=C_INT), public, parameter :: FFTW_HC2R = 1 integer(kind=C_INT), public, parameter :: FFTW_DHT = 2 integer(kind=C_INT), public, parameter :: FFTW_REDFT00 = 3 integer(kind=C_INT), public, parameter :: FFTW_REDFT01 = 4 integer(kind=C_INT), public, parameter :: FFTW_REDFT10 = 5 integer(kind=C_INT), public, parameter :: FFTW_REDFT11 = 6 integer(kind=C_INT), public, parameter :: FFTW_RODFT00 = 7 integer(kind=C_INT), public, parameter :: FFTW_RODFT01 = 8 integer(kind=C_INT), public, parameter :: FFTW_RODFT10 = 9 integer(kind=C_INT), public, parameter :: FFTW_RODFT11 = 10 integer(kind=C_INT), public, parameter :: FFTW_FORWARD = -1 integer(kind=C_INT), public, parameter :: FFTW_BACKWARD = +1 integer(kind=C_INT), public, parameter :: FFTW_MEASURE = 0 integer(kind=C_INT), public, parameter :: FFTW_DESTROY_INPUT = 1 integer(kind=C_INT), public, parameter :: FFTW_UNALIGNED = 2 integer(kind=C_INT), public, parameter :: FFTW_CONSERVE_MEMORY = 4 integer(kind=C_INT), public, parameter :: FFTW_EXHAUSTIVE = 8 integer(kind=C_INT), public, parameter :: FFTW_PRESERVE_INPUT = 16 integer(kind=C_INT), public, parameter :: FFTW_PATIENT = 32 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE = 64 integer(kind=C_INT), public, parameter :: FFTW_WISDOM_ONLY = 2097152 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer(kind=C_INT), public, parameter :: FFTW_BELIEVE_PCOST = 256 integer(kind=C_INT), public, parameter :: FFTW_NO_DFT_R2HC = 512 integer(kind=C_INT), public, parameter :: FFTW_NO_NONTHREADED = 1024 integer(kind=C_INT), public, parameter :: FFTW_NO_BUFFERING = 2048 integer(kind=C_INT), public, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer(kind=C_INT), public, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer(kind=C_INT), public, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer(kind=C_INT), public, parameter :: FFTW_NO_VRECURSE = 65536 integer(kind=C_INT), public, parameter :: FFTW_NO_SIMD = 131072 integer(kind=C_INT), public, parameter :: FFTW_NO_SLOW = 262144 integer(kind=C_INT), public, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_PRUNING = 1048576 Interfaces interface public  function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftw_planner_nthreads() bind(C, name='fftw_planner_nthreads') Arguments None Return Value integer(kind=c_int) interface public  function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=c_int) interface public  function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface public  function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(c_ptr) interface public  function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=c_int) interface public  function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface public  function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int) interface public  function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int) interface public  function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int) interface public  function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr) interface public  function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface public  function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface public  function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=c_int) interface public  subroutine fftw_execute_dft(p, in, out) bind(C, name='fftw_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public  subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftw_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public  subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name='fftw_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public  subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name='fftw_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public  subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftw_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public  subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftw_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public  subroutine fftw_execute_r2r(p, in, out) bind(C, name='fftw_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public  subroutine fftw_destroy_plan(p) bind(C, name='fftw_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftw_forget_wisdom() bind(C, name='fftw_forget_wisdom') Arguments None interface public  subroutine fftw_cleanup() bind(C, name='fftw_cleanup') Arguments None interface public  subroutine fftw_set_timelimit(t) bind(C, name='fftw_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public  subroutine fftw_plan_with_nthreads(nthreads) bind(C, name='fftw_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public  subroutine fftw_cleanup_threads() bind(C, name='fftw_cleanup_threads') Arguments None interface public  subroutine fftw_make_planner_thread_safe() bind(C, name='fftw_make_planner_thread_safe') Arguments None interface public  subroutine fftw_export_wisdom_to_file(output_file) bind(C, name='fftw_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public  subroutine fftw_export_wisdom(write_char, data) bind(C, name='fftw_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public  subroutine fftw_fprint_plan(p, output_file) bind(C, name='fftw_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public  subroutine fftw_print_plan(p) bind(C, name='fftw_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftw_free(p) bind(C, name='fftw_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftw_flops(p, add, mul, fmas) bind(C, name='fftw_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas interface public  function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  function fftwf_planner_nthreads() bind(C, name='fftwf_planner_nthreads') Arguments None Return Value integer(kind=c_int) interface public  function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=c_int) interface public  function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface public  function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(c_ptr) interface public  function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=c_int) interface public  function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface public  function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int) interface public  function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int) interface public  function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int) interface public  function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr) interface public  function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface public  function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface public  function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface public  function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=c_int) interface public  subroutine fftwf_execute_dft(p, in, out) bind(C, name='fftwf_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public  subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftwf_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public  subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name='fftwf_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public  subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name='fftwf_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public  subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftwf_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public  subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftwf_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public  subroutine fftwf_execute_r2r(p, in, out) bind(C, name='fftwf_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public  subroutine fftwf_destroy_plan(p) bind(C, name='fftwf_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftwf_forget_wisdom() bind(C, name='fftwf_forget_wisdom') Arguments None interface public  subroutine fftwf_cleanup() bind(C, name='fftwf_cleanup') Arguments None interface public  subroutine fftwf_set_timelimit(t) bind(C, name='fftwf_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public  subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name='fftwf_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public  subroutine fftwf_cleanup_threads() bind(C, name='fftwf_cleanup_threads') Arguments None interface public  subroutine fftwf_make_planner_thread_safe() bind(C, name='fftwf_make_planner_thread_safe') Arguments None interface public  subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name='fftwf_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public  subroutine fftwf_export_wisdom(write_char, data) bind(C, name='fftwf_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public  subroutine fftwf_fprint_plan(p, output_file) bind(C, name='fftwf_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public  subroutine fftwf_print_plan(p) bind(C, name='fftwf_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftwf_free(p) bind(C, name='fftwf_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public  subroutine fftwf_flops(p, add, mul, fmas) bind(C, name='fftwf_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas Derived Types type, public, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os type, public, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","url":"module\\fftw3.html"},{"title":"NAFPack_fft – NAFPack","text":"Uses FFTW3 NAFPack_constant Functions public  function FFT_1D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function IFFT_1D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal)) public  function FFT_2D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2)) public  function IFFT_2D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2)) public  function FFT_3D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1) ,SIZE(signal, 2), SIZE(signal, 3)) public  function IFFT_3D (signal, method, threads) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), DIMENSION(:, :, :) :: signal character(len=*), intent(in) :: method integer, intent(in), optional :: threads Return Value complex(kind=dp), DIMENSION(SIZE(signal, 1), SIZE(signal, 2), SIZE(signal, 3))","tags":"","url":"module\\nafpack_fft.html"},{"title":"NAFPack_meshgrid – NAFPack","text":"Module for creating a meshgrid from two vectors This module provides a subroutine to create a meshgrid. Uses NAFPack_constant Subroutines public  subroutine meshgrid (varx, vary, X, Y) returns a meshgrid from two vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: varx vector representing the coordinates of a grid. real(kind=dp), intent(in), DIMENSION(:) :: vary vector representing the coordinates of a grid. real(kind=dp), intent(out), DIMENSION(SIZE(vary), SIZE(varx)) :: X output grid coordinates, X is a matrix where each row is varx real(kind=dp), intent(out), DIMENSION(SIZE(vary), SIZE(varx)) :: Y output grid coordinates, Y is a matrix where each column is vary","tags":"","url":"module\\nafpack_meshgrid.html"},{"title":"NAFPack_linear_algebra – NAFPack","text":"Uses NAFPack_matricielle NAFPack_matrix_decomposition NAFPack_constant Functions public  function Direct_methode (A, b, method, pivot_method, check) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(: ,:) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: pivot_method logical, intent(in), optional :: check Return Value real(kind=dp), DIMENSION(SIZE(A,1)) public  function Iterative_methods (A, b, method, x_init, max_iter, omega) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(in), DIMENSION(:) :: b character(len=*), intent(in), optional :: method real(kind=dp), intent(in), optional, DIMENSION(:) :: x_init integer, intent(in), optional :: max_iter real(kind=dp), intent(in), optional :: omega Return Value real(kind=dp), DIMENSION(SIZE(A, 1)) Subroutines public  subroutine Eigen (A, lambda, vp, method, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:, :) :: A real(kind=dp), intent(out), DIMENSION(:) :: lambda real(kind=dp), intent(out), optional, DIMENSION(:, :) :: vp character(len=*), intent(in), optional :: method integer, intent(in), optional :: k","tags":"","url":"module\\nafpack_linear_algebra.html"},{"title":"NAFPack_matricielle.f90 – NAFPack","text":"Source Code MODULE NAFPack_matricielle USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: dot , cross PUBLIC :: norm_2 , norm_2_complex PUBLIC :: normalise , normalise_complexe PUBLIC :: Diagonally_Dominant_Matrix PUBLIC :: Identity_n CONTAINS !function that calculates the dot product between a and b FUNCTION dot ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ) :: result result = a ( 1 ) * b ( 1 ) + a ( 2 ) * b ( 2 ) + a ( 3 ) * b ( 3 ) END FUNCTION dot !function that calculates the cross product between a and b FUNCTION cross ( a , b ) RESULT ( result ) REAL ( dp ), DIMENSION ( 3 ) :: a , b REAL ( dp ), DIMENSION ( 3 ) :: result result ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) result ( 2 ) = - ( a ( 1 ) * b ( 3 ) - b ( 1 ) * a ( 3 )) result ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) END FUNCTION cross !function that calculates the squared norm 2 of a FUNCTION norm_2 ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ) :: result result = SQRT ( SUM ( a ** 2 )) END FUNCTION norm_2 !function that calculates the squared norm 2 of a FUNCTION norm_2_complex ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ) :: result result = SQRT ( SUM ( a ** 2 )) END FUNCTION norm_2_complex !function that transforms a into a unit vector FUNCTION normalise ( a ) RESULT ( result ) REAL ( dp ), DIMENSION (:) :: a REAL ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / NORM2 ( a ) END FUNCTION normalise !function that transforms a into a unit vector FUNCTION normalise_complexe ( a ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:) :: a COMPLEX ( dp ), DIMENSION ( SIZE ( a )) :: result result = a / norm_2_complex ( a ) END FUNCTION normalise_complexe !function which checks if A is diagonally dominant FUNCTION Diagonally_Dominant_Matrix ( A ) RESULT ( diagonally_dominant ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A LOGICAL :: diagonally_dominant REAL ( dp ) :: summation INTEGER :: i , N N = SIZE ( A , 1 ) diagonally_dominant = . TRUE . DO i = 1 , N summation = SUM ( ABS ( A ( i , :) - A ( i , i ))) if ( ABS ( A ( i , i )) < summation ) THEN diagonally_dominant = . FALSE . EXIT END IF END DO END FUNCTION Diagonally_Dominant_Matrix !function that returns the identity matrix FUNCTION Identity_n ( N , use_concurrent ) RESULT ( Identity ) INTEGER , INTENT ( IN ) :: N LOGICAL , INTENT ( IN ), OPTIONAL :: use_concurrent REAL ( dp ), DIMENSION ( N , N ) :: Identity INTEGER :: i LOGICAL :: concurrent_mode concurrent_mode = . FALSE . IF ( PRESENT ( use_concurrent )) concurrent_mode = use_concurrent Identity = 0.d0 IF ( concurrent_mode ) THEN DO CONCURRENT ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END DO ELSE FORALL ( i = 1 : N ) Identity ( i , i ) = 1.0_dp END IF END FUNCTION Identity_n END MODULE NAFPack_matricielle","tags":"","url":"sourcefile\\nafpack_matricielle.f90.html"},{"title":"NAFPack_constant.f90 – NAFPack","text":"Source Code !> Module for defining constants used in NAFPack !> !> This module includes mathematical constants, colors for terminal output, !> and other parameters that are used throughout the NAFPack library. MODULE NAFPack_constant USE , INTRINSIC :: iso_fortran_env , ONLY : sp => real32 , dp => real64 , isp => int32 , idp => int64 IMPLICIT NONE PRIVATE PUBLIC :: pi , im , epsi , kmax , sp , dp , epsi_test , idp , isp PUBLIC :: status_len PUBLIC :: red_color , green_color , yellow_color , blue_color , white_color , cyan_color , purple_color , reset_color REAL ( dp ), PARAMETER :: pi = ACOS ( - 1.d0 ) COMPLEX ( dp ), PARAMETER :: im = ( 0.d0 , 1.d0 ) REAL ( dp ), PARAMETER :: epsi = 1.d-12 , epsi_test = 1.d-6 INTEGER , PARAMETER :: kmax = 10000 CHARACTER ( LEN = * ), PARAMETER :: status_len = REPEAT ( \" \" , 15 ) CHARACTER ( len = 10 ) :: red_color = CHAR ( 27 ) // \"[31m\" CHARACTER ( len = 10 ) :: green_color = CHAR ( 27 ) // \"[32m\" CHARACTER ( len = 10 ) :: yellow_color = CHAR ( 27 ) // \"[33m\" CHARACTER ( len = 10 ) :: blue_color = CHAR ( 27 ) // \"[34m\" CHARACTER ( len = 10 ) :: purple_color = CHAR ( 27 ) // \"[35m\" CHARACTER ( len = 10 ) :: cyan_color = CHAR ( 27 ) // \"[36m\" CHARACTER ( len = 10 ) :: white_color = CHAR ( 27 ) // \"[37m\" CHARACTER ( len = 10 ) :: reset_color = CHAR ( 27 ) // \"[0m\" END MODULE NAFPack_constant","tags":"","url":"sourcefile\\nafpack_constant.f90.html"},{"title":"NAFPack_matrix_decomposition.f90 – NAFPack","text":"Source Code MODULE NAFPack_matrix_decomposition USE NAFPack_constant USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: LU_decomposition , LDU_decomposition , Cholesky_decomposition , QR_decomposition CONTAINS SUBROUTINE LU_decomposition ( A , L , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U INTEGER :: i , j , N N = SIZE ( A , 1 ) L = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 DO i = 1 , j U ( i , j ) = A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j )) END DO DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ))) / U ( j , j ) END DO END DO END SUBROUTINE LU_decomposition SUBROUTINE LDU_decomposition ( A , L , D , U ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L , U , D INTEGER :: i , j , k , N N = SIZE ( A , 1 ) L = 0.d0 D = 0.d0 U = 0.d0 DO j = 1 , N L ( j , j ) = 1.d0 U ( j , j ) = 1.d0 DO i = 1 , j - 1 U ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), U ( 1 : i - 1 , j ) * [ ( D ( k , k ), k = 1 , i - 1 ) ])) / D ( i , i ) END DO i = j D ( j , j ) = A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ]) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), U ( 1 : j - 1 , j ) * [ ( D ( k , k ), k = 1 , j - 1 ) ])) / D ( j , j ) END DO END DO END SUBROUTINE LDU_decomposition SUBROUTINE Cholesky_decomposition ( A , L ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )), INTENT ( OUT ) :: L INTEGER :: i , j , N N = SIZE ( A , 1 ) DO j = 1 , N L ( j , j ) = SQRT ( A ( j , j ) - DOT_PRODUCT ( L ( j , 1 : j - 1 ), L ( j , 1 : j - 1 ))) DO i = j + 1 , N L ( i , j ) = ( A ( i , j ) - DOT_PRODUCT ( L ( i , 1 : j - 1 ), L ( j , 1 : j - 1 ))) / L ( j , j ) END DO END DO END SUBROUTINE Cholesky_decomposition SUBROUTINE QR_decomposition ( A , method , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R IF ( method == \"QR_Householder\" ) THEN CALL QR_Householder ( A , Q , R ) ELSE IF ( method == \"QR_Givens\" ) THEN CALL QR_Givens ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Classical\" ) THEN CALL QR_Gram_Schmidt_Classical ( A , Q , R ) ELSE IF ( method == \"QR_Gram_Schmidt_Modified\" ) THEN CALL QR_Gram_Schmidt_Modified ( A , Q , R ) END IF END SUBROUTINE QR_decomposition SUBROUTINE QR_Householder ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Id , H , v_mat_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: v , u , x INTEGER :: N , i , j , k REAL ( dp ) :: alpha , w , signe , norm_u N = SIZE ( A , 1 ) R = A Id = Identity_n ( N ) Q = Identity_n ( N ) DO k = 1 , N x = 0.d0 u = 0.d0 v = 0.d0 v_mat_tmp = 0.d0 x ( k : N ) = R ( K : N , K ) alpha = NORM2 ( R ( k : N , k )) signe = - SIGN ( alpha , x ( k )) u ( k : N ) = x ( k : N ) - signe * Id ( k : N , k ) norm_u = NORM2 ( u ) IF ( norm_u < epsi ) CYCLE v ( k : N ) = u ( k : N ) / norm_u w = 1.d0 DO i = k , N DO j = k , N v_mat_tmp ( i , j ) = v ( i ) * v ( j ) END DO END DO H = Id H ( k : N , k : N ) = Id ( k : N , k : N ) - ( 1.d0 + w ) * v_mat_tmp ( k : N , k : N ) Q = MATMUL ( Q , H ) R ( k : N , k : N ) = MATMUL ( H ( k : N , k : N ), R ( k : N , k : N )) END DO END SUBROUTINE QR_Householder FUNCTION rotation_matrix ( A , rotation ) RESULT ( G ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , DIMENSION ( 2 ), INTENT ( IN ) :: rotation REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: G REAL ( dp ) :: frac , val_1 , val_2 INTEGER :: i , j i = rotation ( 1 ) j = rotation ( 2 ) G = Identity_n ( SIZE ( A , 1 )) val_1 = A ( j , j ) val_2 = A ( i , j ) frac = SQRT ( val_1 ** 2 + val_2 ** 2 ) G ( i , i ) = val_1 / frac G ( j , j ) = val_1 / frac G ( i , j ) = - val_2 / frac G ( j , i ) = val_2 / frac END FUNCTION rotation_matrix SUBROUTINE QR_Givens ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: G INTEGER :: N , i , j N = SIZE ( A , 1 ) R = A Q = Identity_n ( N ) DO j = 1 , N - 1 DO i = j + 1 , N G = rotation_matrix ( R , [ i , j ]) R = MATMUL ( G , R ) Q = MATMUL ( Q , TRANSPOSE ( G )) END DO END DO END SUBROUTINE QR_Givens SUBROUTINE QR_Gram_Schmidt_Classical ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) Q = Identity_n ( N ) DO j = 1 , N u = A (:, j ) DO i = 1 , j - 1 R ( i , j ) = DOT_PRODUCT ( Q (:, i ), A (:, j )) u = u - ( R ( i , j ) * Q (:, i )) END DO R ( j , j ) = NORM2 ( u ) Q (:, j ) = u / R ( j , j ) END DO END SUBROUTINE QR_Gram_Schmidt_Classical SUBROUTINE QR_Gram_Schmidt_Modified ( A , Q , R ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )), INTENT ( OUT ) :: Q , R REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: u INTEGER :: N , i , j N = SIZE ( A , 1 ) u = A Q = 0.d0 R = 0.d0 DO i = 1 , N R ( i , i ) = NORM2 ( u (:, i )) Q (:, i ) = u (:, i ) / R ( i , i ) DO j = i + 1 , N R ( i , j ) = DOT_PRODUCT ( Q (:, i ), u (:, j )) u (:, j ) = u (:, j ) - R ( i , j ) * Q (:, i ) END DO END DO END SUBROUTINE QR_Gram_Schmidt_Modified END MODULE NAFPack_matrix_decomposition","tags":"","url":"sourcefile\\nafpack_matrix_decomposition.f90.html"},{"title":"FFTW3.f90 – NAFPack","text":"Source Code MODULE FFTW3 USE , INTRINSIC :: iso_c_binding INCLUDE '../../fftw-3.3.10/fftw3.f03' END MODULE FFTW3","tags":"","url":"sourcefile\\fftw3.f90.html"},{"title":"NAFPack_fft.f90 – NAFPack","text":"Source Code MODULE NAFPack_fft USE FFTW3 USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: FFT_1D , FFT_2D , FFT_3D PUBLIC :: IFFT_1D , IFFT_2D , IFFT_3D CONTAINS FUNCTION FFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_DFT\" ) THEN result = NAFPack_DFT_1D ( signal ) ELSE IF ( method == \"NAFPack_FFT_1D\" ) THEN result = NAFPack_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_1D ( signal ) ELSE IF ( method == \"FFTW_FFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_1D\" END IF END FUNCTION FFT_1D FUNCTION IFFT_1D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result IF ( method == \"NAFPack_IFFT_1D\" ) THEN result = NAFPack_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_1D ( signal ) ELSE IF ( method == \"FFTW_IFFT_1D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_1D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_1D FUNCTION FFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_FFT_2D\" ) THEN result = NAFPack_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_2D ( signal ) ELSE IF ( method == \"FFTW_FFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_2D FUNCTION IFFT_2D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result IF ( method == \"NAFPack_IFFT_2D\" ) THEN result = NAFPack_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_2D ( signal ) ELSE IF ( method == \"FFTW_IFFT_2D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_2D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_2D FUNCTION FFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ) , SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_FFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_FFT_3D ( signal ) ELSE IF ( method == \"FFTW_FFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_FFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for FFT_2D\" END IF END FUNCTION FFT_3D FUNCTION IFFT_3D ( signal , method , threads ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal CHARACTER ( * ), INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: threads COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result IF ( method == \"FFTW_IFFT_3D\" . AND . . NOT . PRESENT ( threads )) THEN result = FFTW_IFFT_3D ( signal ) ELSE IF ( method == \"IFFTW_IFFT_3D\" . AND . PRESENT ( threads )) THEN result = FFTW_IFFT_3D_threads ( signal , threads ) ELSE STOP \"ERROR : Wrong method for IFFT_1D\" END IF END FUNCTION IFFT_3D !################### FFTW ########################################## FUNCTION FFTW_FFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_1D_threads FUNCTION FFTW_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_1D FUNCTION FFTW_IFFT_1D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_1D FUNCTION FFTW_IFFT_1D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_1d ( SIZE ( signal ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / SIZE ( signal ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_1D_threads FUNCTION FFTW_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_2D FUNCTION FFTW_FFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_2D_threads FUNCTION FFTW_IFFT_2D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_2D FUNCTION FFTW_IFFT_2D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_2d ( SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_2D_threads FUNCTION FFTW_FFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_FFT_3D FUNCTION FFTW_FFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_FORWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_FFT_3D_threads FUNCTION FFTW_IFFT_3D ( signal ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result TYPE ( c_ptr ) :: plan plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) END FUNCTION FFTW_IFFT_3D FUNCTION FFTW_IFFT_3D_threads ( signal , threads ) RESULT ( result ) COMPLEX ( c_double_complex ), DIMENSION (:, :, :), INTENT ( INOUT ) :: signal INTEGER , INTENT ( IN ) :: threads COMPLEX ( c_double_complex ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 ), SIZE ( signal , 3 )) :: result INTEGER :: error_init_thread TYPE ( c_ptr ) :: plan error_init_thread = fftw_init_threads () IF ( error_init_thread == 0 ) STOP \"ERROR : Thread FFTW initialization problem\" CALL fftw_plan_with_nthreads ( threads ) plan = fftw_plan_dft_3d ( SIZE ( signal , 3 ), SIZE ( signal , 2 ), SIZE ( signal , 1 ), signal , result , FFTW_BACKWARD , FFTW_ESTIMATE ) CALL fftw_execute_dft ( plan , signal , result ) result = result / ( SIZE ( signal , 1 ) * SIZE ( signal , 2 ) * SIZE ( signal , 3 )) CALL fftw_destroy_plan ( plan ) CALL fftw_cleanup_threads () END FUNCTION FFTW_IFFT_3D_threads !################### NAFPack ########################################## !Discrete Fourier transform 1D FUNCTION NAFPack_DFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ) :: S INTEGER :: N , i , k , j N = SIZE ( signal ) IF ( N == 1 ) THEN result = signal ELSE DO i = 1 , N k = i - 1 S = ( 0.d0 , 0.d0 ) DO j = 1 , N S = S + signal ( j ) * EXP (( - 2 * pi * im * k * ( j - 1 )) / N ) END DO result ( i ) = S END DO END IF END FUNCTION NAFPack_DFT_1D FUNCTION fun_omega ( N ) RESULT ( result ) INTEGER , INTENT ( IN ) :: N COMPLEX ( dp ), DIMENSION ( N / 2 ) :: result INTEGER :: i DO i = 1 , N / 2 result ( i ) = EXP ( - 2 * Im * pi * ( i - 1 ) / N ) END DO END FUNCTION fun_omega !Fast Fourier transform 1D Cooley-Tukey RECURSIVE FUNCTION NAFPack_FFT_1D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( signal ) / 2 ) :: f_pair , f_impair , omega INTEGER :: N N = SIZE ( signal ) IF ( MOD ( N , 2 ) == 0 ) THEN f_pair = NAFPack_FFT_1D ( signal ( 1 :: 2 )) f_impair = NAFPack_FFT_1D ( signal ( 2 :: 2 )) omega = fun_omega ( N ) result ( 1 : N / 2 ) = f_pair + f_impair * omega result ( N / 2 + 1 :) = f_pair - f_impair * omega ELSE result = NAFPack_DFT_1D ( signal ) END IF END FUNCTION NAFPack_FFT_1D !The inverse of fft FUNCTION NAFPack_IFFT_1D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: result COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal )) :: f_conjugate INTEGER :: N N = SIZE ( f_signal ) f_conjugate = CONJG ( f_signal ) result = NAFPack_FFT_1D ( f_conjugate ) result = CONJG ( result ) result = result / N END FUNCTION NAFPack_IFFT_1D !Fast Fourier transform 2D Cooley-Tukey FUNCTION NAFPack_FFT_2D ( signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: signal COMPLEX ( dp ), DIMENSION ( SIZE ( signal , 1 ), SIZE ( signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( signal , 1 ) Ny = SIZE ( signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_FFT_1D ( signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_FFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_FFT_2D !The inverse of fft2 FUNCTION NAFPack_IFFT_2D ( f_signal ) RESULT ( result ) COMPLEX ( dp ), DIMENSION (:, :), INTENT ( IN ) :: f_signal COMPLEX ( dp ), DIMENSION ( SIZE ( f_signal , 1 ), SIZE ( f_signal , 2 )) :: result INTEGER :: Nx , Ny , i Nx = SIZE ( f_signal , 1 ) Ny = SIZE ( f_signal , 2 ) DO i = 1 , Nx result ( i , :) = NAFPack_IFFT_1D ( f_signal ( i , :)) END DO DO i = 1 , Ny result (:, i ) = NAFPack_IFFT_1D ( result (:, i )) END DO END FUNCTION NAFPack_IFFT_2D END MODULE NAFPack_fft","tags":"","url":"sourcefile\\nafpack_fft.f90.html"},{"title":"NAFPack_meshgrid.f90 – NAFPack","text":"Source Code !> Module for creating a meshgrid from two vectors !> !> This module provides a subroutine to create a meshgrid. MODULE NAFPack_meshgrid USE NAFPack_constant IMPLICIT NONE PRIVATE PUBLIC :: meshgrid CONTAINS !> returns a meshgrid from two vectors SUBROUTINE meshgrid ( varx , vary , X , Y ) !> vector representing the coordinates of a grid. REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: varx , vary !> output grid coordinates, !> `X` is a matrix where each row is `varx` REAL ( dp ), DIMENSION ( SIZE ( vary ), SIZE ( varx )), INTENT ( OUT ) :: X !> output grid coordinates, !> `Y` is a matrix where each column is `vary` REAL ( dp ), DIMENSION ( SIZE ( vary ), SIZE ( varx )), INTENT ( OUT ) :: Y INTEGER :: sX , sY , i sX = size ( varx ) sY = size ( vary ) DO i = 1 , sY X ( i , :) = varx END DO DO i = 1 , sX Y (:, i ) = vary END DO END SUBROUTINE END MODULE NAFPack_meshgrid","tags":"","url":"sourcefile\\nafpack_meshgrid.f90.html"},{"title":"NAFPack_linear_algebra.f90 – NAFPack","text":"Source Code MODULE NAFPack_linear_algebra USE NAFPack_constant USE NAFPack_matrix_decomposition USE NAFPack_matricielle IMPLICIT NONE PRIVATE PUBLIC :: Direct_methode , Iterative_methods PUBLIC :: Eigen CONTAINS !================== Linear System ======================================================= !forward algorithm FUNCTION forward ( L , b ) RESULT ( y ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: L REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( L , 1 )) :: y INTEGER :: i , N N = SIZE ( L , 1 ) y ( 1 ) = b ( 1 ) / L ( 1 , 1 ) DO i = 2 , N y ( i ) = ( b ( i ) - DOT_PRODUCT ( L ( i , 1 : i - 1 ), y ( 1 : i - 1 ))) / L ( i , i ) END DO END FUNCTION forward !backward algorithm FUNCTION backward ( U , y ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: U REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: y REAL ( dp ), DIMENSION ( SIZE ( U , 1 )) :: x INTEGER :: i , N N = SIZE ( U , 1 ) x ( N ) = y ( N ) / U ( N , N ) DO i = N - 1 , 1 , - 1 x ( i ) = ( y ( i ) - DOT_PRODUCT ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) END DO END FUNCTION backward SUBROUTINE exchange_vector ( Line1 , Line2 ) REAL ( dp ), DIMENSION (:), INTENT ( INOUT ) :: Line1 , Line2 REAL ( dp ), DIMENSION ( SIZE ( Line1 )) :: tmp tmp = Line1 Line1 = Line2 Line2 = tmp END SUBROUTINE exchange_vector SUBROUTINE scalar_exchange ( scal1 , scal2 ) REAL ( dp ) :: scal1 , scal2 REAL ( dp ) :: tmp tmp = scal1 scal1 = scal2 scal2 = tmp END SUBROUTINE scalar_exchange !################## direct methode ###################################################### FUNCTION Direct_methode ( A , b , method , pivot_method , check ) RESULT ( x ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: pivot_method REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x INTEGER :: N LOGICAL :: do_check = . TRUE . IF ( PRESENT ( check )) do_check = check N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( b , 1 ) /= N ) STOP \"ERROR :: Dimension mismatch in linear system\" IF (. NOT . PRESENT ( method )) THEN PRINT * , \"WARNING :: No method specified for linear system, using LU decomposition\" x = A_LU ( A , b ) END IF IF ( method == \"Gauss\" ) THEN x = Gauss ( A , b , pivot_method = pivot_method ) ELSE IF ( method == \"A_LU\" ) THEN x = A_LU ( A , b ) ELSE IF ( method == \"A_LDU\" ) THEN x = A_LDU ( A , b ) ELSE IF ( method == \"Cholesky\" ) THEN x = Cholesky ( A , b , check = do_check ) ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN x = A_QR ( A , b , method = method ) ELSE IF ( method == \"TDMA\" ) THEN x = TDMA ( A , b , check = do_check ) ELSE STOP \"ERROR : Wrong method for linear system (direct_methode)\" END IF END FUNCTION Direct_methode FUNCTION Gauss ( A , b , pivot_method ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: pivot_method REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 2 )) :: A_tmp , P , Q , Q_final REAL ( dp ), DIMENSION ( SIZE ( b )) :: b_tmp INTEGER , DIMENSION ( 1 ) :: vlmax_partial INTEGER , DIMENSION ( 2 ) :: vlmax_total REAL ( dp ) :: m , pivot INTEGER :: k , i , N , lmax , cmax A_tmp = A b_tmp = b N = SIZE ( A_tmp , 1 ) Q_final = Identity_n ( N ) DO k = 1 , N - 1 IF (. NOT . PRESENT ( pivot_method )) THEN PRINT * , \"WARNING :: No pivot method specified, using normal pivot\" END IF IF ( pivot_method == \"partial\" ) THEN ! Find the maximum absolute value in the column from row k to N vlmax_partial = MAXLOC ( ABS ( A_tmp ( k : N , k ))) lmax = vlmax_partial ( 1 ) + k - 1 !calculate permutation matrix P P = Identity_n ( N ) IF ( k /= lmax ) THEN P ( k , k ) = 0.0_dp P ( lmax , lmax ) = 0.0_dp P ( k , lmax ) = 1.0_dp P ( lmax , k ) = 1.0_dp END IF A_tmp = MATMUL ( P , A_tmp ) b_tmp = MATMUL ( P , b_tmp ) ELSE IF ( pivot_method == \"total\" ) THEN ! Find max abs element in submatrix vlmax_total = MAXLOC ( ABS ( A_tmp ( k : N , k : N ))) lmax = vlmax_total ( 1 ) + k - 1 cmax = vlmax_total ( 2 ) + k - 1 P = Identity_n ( N ) Q = Identity_n ( N ) ! permute line if necessary IF ( lmax /= k ) THEN P ( k , k ) = 0.0_dp P ( lmax , lmax ) = 0.0_dp P ( k , lmax ) = 1.0_dp P ( lmax , k ) = 1.0_dp END IF ! permute column if necessary IF ( cmax /= k ) THEN Q ( k , k ) = 0.0_dp Q ( cmax , cmax ) = 0.0_dp Q ( k , cmax ) = 1.0_dp Q ( cmax , k ) = 1.0_dp END IF Q_final = MATMUL ( Q , Q_final ) ! Apply permutations A_tmp = MATMUL ( P , A_tmp ) A_tmp = MATMUL ( A_tmp , Q ) b_tmp = MATMUL ( P , b_tmp ) END IF pivot = A_tmp ( k , k ) IF ( ABS ( pivot ) < epsi ) STOP \"ERROR :: Near-zero pivot – matrix may be singular\" DO i = k + 1 , N m = A_tmp ( i , k ) / pivot A_tmp ( i , k ) = 0 ! Vectorized operation A_tmp ( i , k + 1 : N ) = A_tmp ( i , k + 1 : N ) - m * A_tmp ( k , k + 1 : N ) b_tmp ( i ) = b_tmp ( i ) - m * b_tmp ( k ) END DO END DO x = backward ( A_tmp , b_tmp ) IF ( pivot_method == \"total\" ) x = MATMUL ( Q_final , x ) END FUNCTION Gauss FUNCTION A_LU ( A , b ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , U REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y CALL LU_decomposition ( A , L , U ) y = forward ( L , b ) x = backward ( U , y ) END FUNCTION A_LU FUNCTION A_LDU ( A , b ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L , U , D REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , z CALL LDU_decomposition ( A , L , D , U ) z = forward ( L , b ) y = forward ( D , z ) x = backward ( U , y ) END FUNCTION A_LDU FUNCTION Cholesky ( A , b , check ) RESULT ( x ) REAL ( dp ), DIMENSION (: ,:), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: L REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: y , lambda LOGICAL :: do_check = . TRUE . IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is positive definite and symmetric\" CALL Eigen ( A , lambda , method = \"Power_iteration\" ) IF ( MINVAL ( lambda ) < epsi ) STOP \"ERROR :: A is not a definite matrix (Cholesky)\" IF ( MAXVAL ( ABS ( A - TRANSPOSE ( A ))) > epsi ) STOP \"ERROR :: A is not symmetric (Cholesky)\" END IF CALL Cholesky_decomposition ( A , L ) y = forward ( L , b ) x = backward ( TRANSPOSE ( L ), y ) END FUNCTION Cholesky FUNCTION A_QR ( A , b , method ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 ) , SIZE ( A , 2 )) :: Q , R CALL QR_decomposition ( A , method , Q , R ) x = backward ( R , MATMUL ( TRANSPOSE ( Q ), b )) END FUNCTION A_QR FUNCTION TDMA ( A , b , check ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b LOGICAL , OPTIONAL , INTENT ( IN ) :: check REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: alpha , beta REAL ( dp ) :: denom INTEGER :: n , i , j LOGICAL :: do_check = . TRUE . N = SIZE ( A , 1 ) IF ( PRESENT ( check )) do_check = check IF ( do_check ) THEN PRINT * , \"Checking if the matrix A is tridiagonal\" DO i = 1 , N DO j = 1 , N IF ( ABS ( i - j ) > 1 ) THEN IF ( ABS ( A ( i , j )) > epsi ) STOP \"ERROR :: Matrix is not tridiagonal\" END IF END DO END DO END IF alpha = 0.0_dp beta = 0.0_dp alpha ( 1 ) = A ( 1 , 2 ) / A ( 1 , 1 ) beta ( 1 ) = b ( 1 ) / A ( 1 , 1 ) DO i = 2 , N denom = A ( i , i ) - A ( i , i - 1 ) * alpha ( i - 1 ) IF ( i < N ) alpha ( i ) = A ( i , i + 1 ) / denom beta ( i ) = ( b ( i ) - A ( i , i - 1 ) * beta ( i - 1 )) / denom END DO x ( n ) = beta ( n ) DO i = n - 1 , 1 , - 1 x ( i ) = beta ( i ) - alpha ( i ) * x ( i + 1 ) END DO END FUNCTION TDMA !################## Iterative methods ################################################### FUNCTION Iterative_methods ( A , b , method , x_init , max_iter , omega ) RESULT ( x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b REAL ( dp ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: x_init CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: max_iter REAL ( dp ), OPTIONAL , INTENT ( IN ) :: omega REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: x0 , x_new , residu INTEGER :: k , max_iter_choice , N N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( PRESENT ( max_iter )) THEN max_iter_choice = max_iter ELSE max_iter_choice = kmax END IF IF ( PRESENT ( x_init )) THEN IF ( SIZE ( x_init , 1 ) /= SIZE ( A , 1 )) STOP \"ERROR : Dimension of x_init different from A\" x0 = x_init ELSE x0 = 0.d0 END IF DO k = 1 , max_iter_choice IF ( k == kmax ) THEN PRINT * , \"WARNING :: non-convergence of the iterative method \" // method END IF IF ( method == \"Jacobi\" ) THEN CALL Jacobi ( A , b , x0 , x_new ) ELSE IF ( method == \"Gauss_Seidel\" ) THEN CALL Gauss_Seidel ( A , b , x0 , x_new ) ELSE IF ( method == \"SOR\" ) THEN IF ( PRESENT ( omega )) THEN CALL SOR ( A , b , x0 , x_new , omega ) ELSE CALL SOR ( A , b , x0 , x_new , 1.d0 ) END IF ELSE STOP \"ERROR : Wrong method for linear system (Iterative_methods)\" END IF residu = b - MATMUL ( A , x_new ) IF ( NORM2 ( residu ) < epsi ) EXIT x0 = x_new END DO x = x_new END FUNCTION Iterative_methods SUBROUTINE Jacobi ( A , b , x0 , x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x0 ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END SUBROUTINE Jacobi SUBROUTINE Gauss_Seidel ( A , b , x0 , x ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = x ( i ) / A ( i , i ) END DO END SUBROUTINE Gauss_Seidel SUBROUTINE SOR ( A , b , x0 , x , omega ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: b , x0 REAL ( dp ), INTENT ( IN ) :: omega REAL ( dp ), DIMENSION ( SIZE ( A , 1 )), INTENT ( OUT ) :: x INTEGER :: i , N N = SIZE ( A , 1 ) DO i = 1 , N x ( i ) = b ( i ) - DOT_PRODUCT ( A ( i , 1 : i - 1 ), x ( 1 : i - 1 )) - DOT_PRODUCT ( A ( i , i + 1 : N ), x0 ( i + 1 : N )) x ( i ) = omega * ( x ( i ) / A ( i , i ) - x0 ( i )) x ( i ) = x ( i ) + x0 ( i ) END DO END SUBROUTINE SOR !================== Eigen =============================================================== SUBROUTINE Eigen ( A , lambda , vp , method , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: method INTEGER , OPTIONAL , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:, :), OPTIONAL , INTENT ( OUT ) :: vp REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: vp_tmp CHARACTER ( LEN = 50 ) :: base_method INTEGER :: N , i , k_max , pos IF ( PRESENT ( k )) THEN IF ( k <= 0 ) STOP \"ERROR :: k must be a positive integer\" k_max = k ELSE k_max = kmax END IF N = SIZE ( A , 1 ) IF ( SIZE ( A , 2 ) /= N ) STOP \"ERROR :: Matrix A not square\" IF ( SIZE ( lambda , 1 ) /= N ) STOP \"ERROR :: dimension lambda\" IF ( PRESENT ( vp ) . AND . ( SIZE ( vp , 1 ) /= N . OR . SIZE ( vp , 2 ) /= N )) STOP \"ERROR :: dimension vp\" IF ( method == \"Power_iteration\" ) THEN A_tmp = A DO i = 1 , N CALL Power_iteration ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) A_tmp = deflation ( A_tmp , lambda ( i ), vp_tmp ( i , :), k_max ) END DO IF ( PRESENT ( vp )) vp = vp_tmp ELSE IF ( INDEX ( method , \"QR\" ) == 1 ) THEN IF ( PRESENT ( vp )) vp = 0 IF ( PRESENT ( vp )) PRINT * , \"WARNING :: No solution for eigenvectors with the QR method\" pos = INDEX ( TRIM ( method ), \"_Shifted\" ) IF ( pos > 0 . AND . pos + 7 == LEN_TRIM ( method )) THEN base_method = method (: pos - 1 ) CALL Eigen_QR_Shifted ( A , lambda , base_method , N , k_max ) ELSE CALL Eigen_QR ( A , lambda , method , N , k_max ) END IF ELSE STOP \"ERROR :: Wrong method for Eigen\" END IF END SUBROUTINE Eigen SUBROUTINE Eigen_QR ( A , lambda , method , N , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A CHARACTER ( LEN = * ), INTENT ( IN ) :: method INTEGER , INTENT ( IN ) :: N , k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: lambda_old REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R REAL ( dp ) :: diff INTEGER :: i , j A_tmp = A DO i = 1 , k lambda_old = lambda CALL QR_decomposition ( A_tmp , method , Q , R ) A_tmp = MATMUL ( R , Q ) diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR SUBROUTINE Eigen_QR_Shifted ( A , lambda , method , N , k ) INTEGER , INTENT ( IN ) :: N , k CHARACTER ( LEN = * ), INTENT ( IN ) :: method REAL ( dp ), DIMENSION ( N , N ), INTENT ( IN ) :: A REAL ( dp ), DIMENSION ( N ), INTENT ( OUT ) :: lambda INTEGER :: i , j REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: A_tmp , Q , R , Id REAL ( dp ) :: shift , diff A_tmp = A Id = Identity_n ( N ) DO i = 1 , k !choice of shift: last diagonal element shift = A_tmp ( N , N ) ! Gap : A - µI A_tmp = A_tmp - shift * Id ! QR Decomposition : A - µI = Q * R CALL QR_decomposition ( A_tmp , method , Q , R ) ! A = RQ + µI A_tmp = MATMUL ( R , Q ) + shift * Id diff = ABS ( A_tmp ( 2 , 1 )) DO j = 3 , N IF ( MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) > diff ) THEN diff = MAXVAL ( ABS ( A_tmp ( j , 1 : j - 1 ))) END IF END DO IF ( i == k ) THEN PRINT * , \" WARNING :: non-convergence of the Shifted QR Algorithm for eigenvalues \" // method PRINT * , \"convergence = \" , diff EXIT END IF IF ( diff <= epsi ) EXIT END DO ! Extract eigenvalues lambda = [( A_tmp ( i , i ), i = 1 , N )] END SUBROUTINE Eigen_QR_Shifted SUBROUTINE Power_iteration ( A , lambda , vp , k ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION (:), INTENT ( OUT ) :: vp REAL ( dp ), INTENT ( OUT ) :: lambda REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: u , vp_tmp , r INTEGER :: i , N N = SIZE ( A , 1 ) CALL RANDOM_NUMBER ( u ) u = normalise ( u ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) r = vp_tmp - lambda * u DO i = 1 , k u = normalise ( vp_tmp ) vp_tmp = MATMUL ( A , u ) lambda = DOT_PRODUCT ( vp_tmp , u ) IF ( NORM2 ( r ) <= epsi ) EXIT r = vp_tmp - lambda * u IF ( i == k ) THEN PRINT * , \"WARNING :: non-convergence of the power iteration method\" END IF END DO vp = u END SUBROUTINE Power_iteration FUNCTION deflation ( A , lambda , vp , k ) RESULT ( result ) REAL ( dp ), DIMENSION (:, :), INTENT ( IN ) :: A REAL ( dp ), DIMENSION (:), INTENT ( IN ) :: vp REAL ( dp ), INTENT ( IN ) :: lambda INTEGER , INTENT ( IN ) :: k REAL ( dp ), DIMENSION ( SIZE ( A , 1 ), SIZE ( A , 1 )) :: result REAL ( dp ), DIMENSION ( SIZE ( A , 1 )) :: wp INTEGER :: i , j , N REAL ( dp ) :: lambda1 N = SIZE ( A , 1 ) result = A CALL Power_iteration ( transpose ( A ), lambda1 , wp , k ) DO i = 1 , N DO j = 1 , N result ( i , j ) = result ( i , j ) - ( lambda * vp ( i ) * wp ( j )) / DOT_PRODUCT ( vp , wp ) END DO END DO END FUNCTION deflation END MODULE NAFPack_linear_algebra","tags":"","url":"sourcefile\\nafpack_linear_algebra.f90.html"}]}